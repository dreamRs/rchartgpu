(()=>{"use strict";HTMLWidgets;const e=Symbol("GPUContext.ownsDevice"),t=t=>t[e]??!0;function n(e){if(!e.canvas)throw new Error("GPUContext: Canvas is not configured. Provide a canvas element when creating the context.");if(!e.initialized||!e.canvasContext)throw new Error("GPUContext: not initialized. Call initializeGPUContext() first.");return e.canvasContext.getCurrentTexture()}class i{get adapter(){return this._state.adapter}get device(){return this._state.device}get initialized(){return this._state.initialized}get canvas(){return this._state.canvas}get canvasContext(){return this._state.canvasContext}get preferredFormat(){return this._state.preferredFormat}get devicePixelRatio(){return this._state.devicePixelRatio}get alphaMode(){return this._state.alphaMode}get powerPreference(){return this._state.powerPreference}constructor(t,n){this._state=function(t,n){const i=(null==n?void 0:n.devicePixelRatio)??(typeof window<"u"?window.devicePixelRatio:1),r=Number.isFinite(i)&&i>0?i:1,o=(null==n?void 0:n.alphaMode)??"opaque",a=(null==n?void 0:n.powerPreference)??"high-performance",s=!(null==n||!n.device||null==n||!n.adapter),l=!s;return{adapter:s?n.adapter:null,device:s?n.device:null,initialized:!1,canvas:t||null,canvasContext:null,preferredFormat:null,devicePixelRatio:r,alphaMode:o,powerPreference:a,[e]:l}}(t,n)}async initialize(){this._state=await async function(n){var i,r,o;if(n.initialized)throw new Error("GPUContext: already initialized. Call destroyGPUContext() before reinitializing.");const a=Number.isFinite(n.devicePixelRatio)&&n.devicePixelRatio>0?n.devicePixelRatio:1;if(!navigator.gpu)throw new Error("WebGPU is not available in this browser. Please use a browser that supports WebGPU (Chrome 113+, Edge 113+, or Safari 18+). Ensure WebGPU is enabled in browser flags if needed.");let s=null,l=null,u=t(n);try{if(n.adapter&&n.device){if(l=n.adapter,s=n.device,u=!1,"function"!=typeof(null==(i=navigator.gpu)?void 0:i.getPreferredCanvasFormat))throw new Error("GPUContext: Shared device requires navigator.gpu.getPreferredCanvasFormat() for canvas format selection, but it is not available in this environment. Use a browser with full WebGPU support.");const e=navigator.gpu.getPreferredCanvasFormat();if("bgra8unorm"!==e&&"rgba8unorm"!==e)throw new Error(`GPUContext: Shared device preferred canvas format is not supported by ChartGPU. Received navigator.gpu.getPreferredCanvasFormat()="${e}". Supported formats: "bgra8unorm", "rgba8unorm".`);const t=s.limits.maxBufferSize;if(t<33554432)throw new Error(`GPUContext: Injected device.limits.maxBufferSize is insufficient. Required >= 33554432 bytes, actual=${t} bytes.`);const r=s.limits.maxStorageBufferBindingSize;if(r<33554432)throw new Error(`GPUContext: Injected device.limits.maxStorageBufferBindingSize is insufficient. Required >= 33554432 bytes, actual=${r} bytes.`)}else{const e=await navigator.gpu.requestAdapter({powerPreference:n.powerPreference});if(!e)throw new Error("GPUContext: Failed to request WebGPU adapter. No compatible adapter found. This may occur if no GPU is available or WebGPU is disabled.");const t=await e.requestDevice();if(!t)throw new Error("GPUContext: Failed to request WebGPU device from adapter.");l=e,s=t,u=!0,s.addEventListener("uncapturederror",e=>{console.error("WebGPU uncaptured error:",e.error)})}let t=null,c=null;if(n.canvas){const e=n.canvas.getContext("webgpu");if(!e){if(u&&s)try{s.destroy()}catch(e){console.warn("Error destroying device during canvas setup failure:",e)}throw new Error("GPUContext: Failed to get WebGPU context from canvas.")}const{width:i,height:l}=function(e){const t=e.clientWidth||e.width||0,n=e.clientHeight||e.height||0;if(!Number.isFinite(t)||!Number.isFinite(n))throw new Error(`GPUContext: Invalid canvas dimensions detected: width=${e.clientWidth||e.width}, height=${e.clientHeight||e.height}. Canvas must have finite dimensions. Ensure canvas is properly sized before initialization.`);return{width:t,height:n}}(n.canvas),d=a,f=Math.floor(i*d),m=Math.floor(l*d),p=s.limits.maxTextureDimension2D;if(!u&&(f>p||m>p)){const e=Math.max(f,m);throw new Error(`GPUContext: Injected device.limits.maxTextureDimension2D is insufficient. Required >= ${e} (for ${f}x${m} at devicePixelRatio=${d}), actual=${p}.`)}const h=Math.max(1,Math.min(f,p)),g=Math.max(1,Math.min(m,p));n.canvas.width=h,n.canvas.height=g,c=(null==(o=(r=navigator.gpu).getPreferredCanvasFormat)?void 0:o.call(r))||"bgra8unorm",e.configure({device:s,format:c,alphaMode:n.alphaMode}),t=e}return{adapter:l,device:s,initialized:!0,canvas:n.canvas,canvasContext:t,preferredFormat:c,devicePixelRatio:a,alphaMode:n.alphaMode,powerPreference:n.powerPreference,[e]:u}}catch(e){if(u&&s)try{s.destroy()}catch(e){console.warn("Error destroying device during initialization failure:",e)}throw e instanceof Error?e:new Error(`Failed to initialize GPUContext: ${String(e)}`)}}(this._state)}static async create(e,t){const n=new i(e,t);return await n.initialize(),n}getCanvasTexture(){return n(this._state)}clearScreen(e,t,i,r){!function(e,t,i,r,o){if(t<0||t>1||i<0||i>1||r<0||r>1||o<0||o>1)throw new Error("GPUContext: Color components must be in the range [0.0, 1.0]");if(!e.canvas)throw new Error("GPUContext: Canvas is not configured. Provide a canvas element when creating the context.");if(!e.initialized||!e.device||!e.canvasContext)throw new Error("GPUContext: not initialized. Call initializeGPUContext() first.");const a=n(e),s=e.device.createCommandEncoder();s.beginRenderPass({colorAttachments:[{view:a.createView(),clearValue:{r:t,g:i,b:r,a:o},loadOp:"clear",storeOp:"store"}]}).end(),e.device.queue.submit([s.finish()])}(this._state,e,t,i,r)}destroy(){this._state=function(n){if(n.canvasContext)try{n.canvasContext.unconfigure()}catch(e){console.warn("Error unconfiguring GPU canvas context:",e)}if(!1!==t(n)&&n.device)try{n.device.destroy()}catch(e){console.warn("Error destroying GPU device:",e)}return{adapter:null,device:null,initialized:!1,canvas:n.canvas,canvasContext:null,preferredFormat:null,devicePixelRatio:n.devicePixelRatio,alphaMode:n.alphaMode,powerPreference:n.powerPreference,[e]:!1}}(this._state)}}function r(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)&&"x"in e&&"y"in e&&"object"==typeof e.x&&"object"==typeof e.y&&"length"in e.x&&"length"in e.y}function o(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)&&ArrayBuffer.isView(e)}function a(e){return Array.isArray(e)}function s(e){if(r(e))return Math.min(e.x.length,e.y.length);if(o(e)){if(e instanceof DataView)throw new Error("DataView is not supported for InterleavedXYData. Use typed arrays (Float32Array, Float64Array, etc.).");return Math.floor(e.length/2)}return e.length}function l(e,t){if(r(e))return e.x[t];if(o(e)){if(e instanceof DataView)throw new Error("DataView is not supported for InterleavedXYData. Use typed arrays (Float32Array, Float64Array, etc.).");return e[2*t]}const n=e[t];return null==n||"object"!=typeof n?NaN:a(n)?n[0]:n.x}function u(e,t){if(r(e))return e.y[t];if(o(e)){if(e instanceof DataView)throw new Error("DataView is not supported for InterleavedXYData. Use typed arrays (Float32Array, Float64Array, etc.).");return e[2*t+1]}const n=e[t];return null==n||"object"!=typeof n?NaN:a(n)?n[1]:n.y}function c(e,t){var n;if(r(e))return null==(n=e.size)?void 0:n[t];if(o(e))return;const i=e[t];return null!=i&&"object"==typeof i?a(i)?i[2]:i.size:void 0}function d(e,t,n,i,l,u){const c=s(n)-i,d=Math.min(l,c);if(d<=0)return;const f=t+2*d;if(f>e.length)throw new Error(`packXYInto: output buffer too small (need ${f} floats, have ${e.length})`);if(r(n))for(let r=0;r<d;r++){const o=i+r,a=t+2*r;e[a]=n.x[o]-u,e[a+1]=n.y[o]}else{if(o(n)){if(n instanceof DataView)throw new Error("DataView is not supported for InterleavedXYData. Use typed arrays (Float32Array, Float64Array, etc.).");const r=n;for(let n=0;n<d;n++){const o=2*(i+n),a=t+2*n;e[a]=r[o]-u,e[a+1]=r[o+1]}return}for(let r=0;r<d;r++){const o=t+2*r,s=n[i+r];if(null==s||"object"!=typeof s){e[o]=NaN,e[o+1]=NaN;continue}const l=a(s)?s[0]:s.x,c=a(s)?s[1]:s.y;e[o]=l-u,e[o+1]=c}}}function f(e){let t=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY,i=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;if(r(e)){const r=Math.min(e.x.length,e.y.length);for(let o=0;o<r;o++){const r=e.x[o],s=e.y[o];!Number.isFinite(r)||!Number.isFinite(s)||(r<t&&(t=r),r>n&&(n=r),s<i&&(i=s),s>a&&(a=s))}}else if(o(e)){if(e instanceof DataView)throw new Error("DataView is not supported for InterleavedXYData. Use typed arrays (Float32Array, Float64Array, etc.).");const r=e,o=Math.floor(r.length/2);for(let e=0;e<o;e++){const o=r[2*e],s=r[2*e+1];!Number.isFinite(o)||!Number.isFinite(s)||(o<t&&(t=o),o>n&&(n=o),s<i&&(i=s),s>a&&(a=s))}}else{const r=e.length;for(let o=0;o<r;o++){const r=l(e,o),s=u(e,o);!Number.isFinite(r)||!Number.isFinite(s)||(r<t&&(t=r),r>n&&(n=r),s<i&&(i=s),s>a&&(a=s))}}return Number.isFinite(t)&&Number.isFinite(n)&&Number.isFinite(i)&&Number.isFinite(a)?(t===n&&(n=t+1),i===a&&(a=i+1),{xMin:t,xMax:n,yMin:i,yMax:a}):null}function m(e){return e+3&-4}function p(e,t){const n=Math.max(4,m(t)),i=Math.max(4,function(e){if(!Number.isFinite(e)||e<=0)return 1;const t=Math.ceil(e);return 2**Math.ceil(Math.log2(t))}(n));return Math.max(e,i)}function h(e,t){let n=e>>>0;for(let e=0;e<t.length;e++)n^=t[e],n=Math.imul(n,16777619)>>>0;return n>>>0}function g(e){return h(2166136261,new Uint32Array(e.buffer,e.byteOffset,e.byteLength/4))}function b(e){return Array.isArray(e)}function v(e,t){const n=Math.floor(t);if(e instanceof Float32Array){const t=e.length>>>1;if(n<=0||0===t)return new Float32Array(0);if(t<=n)return e;const i=function(e,t){const n=e.length>>>1,i=n-1;if(t<=0||0===n)return new Int32Array(0);if(1===t)return new Int32Array([0]);if(2===t)return n>=2?new Int32Array([0,i]):new Int32Array([0]);if(n<=t){const e=new Int32Array(n);for(let t=0;t<n;t++)e[t]=t;return e}const r=new Int32Array(t);r[0]=0,r[t-1]=i;const o=(n-2)/(t-2);let a=0,s=1;const l=e[2*i+0],u=e[2*i+1];for(let n=0;n<t-2;n++){let t=Math.floor(o*n)+1,c=Math.min(Math.floor(o*(n+1))+1,i);t>=c&&(t=Math.min(t,i-1),c=Math.min(t+1,i));const d=Math.floor(o*(n+1))+1,f=Math.min(Math.floor(o*(n+2))+1,i);let m=l,p=u;if(d<f){let t=0,n=0,i=0;for(let r=d;r<f;r++)t+=e[2*r+0],n+=e[2*r+1],i++;i>0&&(m=t/i,p=n/i)}const h=e[2*a+0],g=e[2*a+1];let b=-1,v=t;for(let n=t;n<c;n++){const t=e[2*n+0],i=(h-m)*(e[2*n+1]-g)-(h-t)*(p-g),r=i<0?-i:i;r>b&&(b=r,v=n)}r[s++]=v,a=v}return r}(e,n),r=new Float32Array(2*i.length);for(let t=0;t<i.length;t++){const n=i[t];r[2*t+0]=e[2*n+0],r[2*t+1]=e[2*n+1]}return r}const i=e.length;if(n<=0||0===i)return[];if(i<=n)return e;const r=function(e,t){const n=e.length,i=n-1;if(t<=0||0===n)return new Int32Array(0);if(1===t)return new Int32Array([0]);if(2===t)return n>=2?new Int32Array([0,i]):new Int32Array([0]);if(n<=t){const e=new Int32Array(n);for(let t=0;t<n;t++)e[t]=t;return e}const r=new Int32Array(t);r[0]=0,r[t-1]=i;const o=(n-2)/(t-2);let a=0,s=1;const l=e[i],u=b(l)?l[0]:l.x,c=b(l)?l[1]:l.y;for(let n=0;n<t-2;n++){let t=Math.floor(o*n)+1,l=Math.min(Math.floor(o*(n+1))+1,i);t>=l&&(t=Math.min(t,i-1),l=Math.min(t+1,i));const d=Math.floor(o*(n+1))+1,f=Math.min(Math.floor(o*(n+2))+1,i);let m=u,p=c;if(d<f){let t=0,n=0,i=0;for(let r=d;r<f;r++){const o=e[r];t+=b(o)?o[0]:o.x,n+=b(o)?o[1]:o.y,i++}i>0&&(m=t/i,p=n/i)}const h=e[a],g=b(h)?h[0]:h.x,v=b(h)?h[1]:h.y;let y=-1,x=t;for(let n=t;n<l;n++){const t=e[n],i=b(t)?t[0]:t.x,r=(g-m)*((b(t)?t[1]:t.y)-v)-(g-i)*(p-v),o=r<0?-r:r;o>y&&(y=o,x=n)}r[s++]=x,a=x}return r}(e,n),o=new Array(r.length);for(let t=0;t<r.length;t++)o[t]=e[r[t]];return o}function y(e){const t=Math.floor(e);return Number.isFinite(t)?t:0}function x(e){const t=s(e),n=new Float32Array(2*t);for(let i=0;i<t;i++)n[2*i]=l(e,i),n[2*i+1]=u(e,i);return n}function w(e,t,n){const i=s(e),r=y(t);if(r<=0||0===i)return[];if(1===r){const t=l(e,0),n=u(e,0),i=c(e,0);return void 0!==i?[[t,n,i]]:[[t,n]]}if(2===r){if(i>=2){const t=l(e,0),n=u(e,0),r=c(e,0),o=l(e,i-1),a=u(e,i-1),s=c(e,i-1);return[void 0!==r?[t,n,r]:[t,n],void 0!==s?[o,a,s]:[o,a]]}{const t=l(e,0),n=u(e,0),i=c(e,0);return void 0!==i?[[t,n,i]]:[[t,n]]}}const o=i-1,a=new Array(r);{const t=l(e,0),n=u(e,0),i=c(e,0);a[0]=void 0!==i?[t,n,i]:[t,n];const s=l(e,o),d=u(e,o),f=c(e,o);a[r-1]=void 0!==f?[s,d,f]:[s,d]}const d=(i-2)/(r-2);for(let t=0;t<r-2;t++){let i=Math.floor(d*t)+1,r=Math.min(Math.floor(d*(t+1))+1,o);i>=r&&(i=Math.min(i,o-1),r=Math.min(i+1,o));let s=null;if("average"===n){let t=0,n=0,o=0,a=0,d=0;for(let s=i;s<r;s++){const i=l(e,s),r=u(e,s);if(!Number.isFinite(i)||!Number.isFinite(r))continue;t+=i,n+=r,a++;const f=c(e,s);"number"==typeof f&&Number.isFinite(f)&&(o+=f,d++)}if(a>0){const e=t/a,i=n/a;s=d>0?[e,i,o/d]:[e,i]}}else{let t="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,o=i;for(let a=i;a<r;a++){const i=u(e,a);Number.isFinite(i)&&("max"===n?i>t&&(t=i,o=a):i<t&&(t=i,o=a))}const a=l(e,o),d=u(e,o),f=c(e,o);s=void 0!==f?[a,d,f]:[a,d]}if(null===s){const t=l(e,i),n=u(e,i),r=c(e,i);s=void 0!==r?[t,n,r]:[t,n]}a[t+1]=s}return a}function M(e,t,n){const i=y(n),r=s(e);if("none"===t||!(i>0)||r<=i)return e;switch(t){case"lttb":return e instanceof Float32Array?v(e,i):function(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)&&ArrayBuffer.isView(e)}(e)||function(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)&&"x"in e&&"y"in e&&"object"==typeof e.x&&"object"==typeof e.y&&"length"in e.x&&"length"in e.y}(e)?v(x(e),i):v(e,i);case"average":return w(e,i,"average");case"max":return w(e,i,"max");case"min":return w(e,i,"min");default:return e}}function F(e,t){const n=Math.floor(t),i=e.length;if(n<2||i<=n)return e;const r=new Array(n);if(r[0]=e[0],r[n-1]=e[i-1],2===n)return r;const o=function(e){return Array.isArray(e)}(e[0]),a=(i-2)/(n-2);if(o){const t=e;for(let e=0;e<n-2;e++){let n=Math.floor(a*e)+1,o=Math.min(Math.floor(a*(e+1))+1,i-1);n>=o&&(n=Math.min(n,i-2),o=Math.min(n+1,i-1));const s=t[n],l=t[o-1],u=s[0],c=s[1],d=l[2];let f=-1/0,m=1/0;for(let e=n;e<o;e++){const n=t[e],i=n[3],r=n[4];r>f&&(f=r),i<m&&(m=i)}r[e+1]=[u,c,d,m,f]}}else{const t=e;for(let e=0;e<n-2;e++){let n=Math.floor(a*e)+1,o=Math.min(Math.floor(a*(e+1))+1,i-1);n>=o&&(n=Math.min(n,i-2),o=Math.min(n+1,i-1));const s=t[n],l=t[o-1],u=s.timestamp,c=s.open,d=l.close;let f=-1/0,m=1/0;for(let e=n;e<o;e++){const n=t[e],i=n.high,r=n.low;i>f&&(f=i),r<m&&(m=r)}r[e+1]={timestamp:u,open:c,close:d,low:m,high:f}}}return r}function N(e,t,n){return Math.min(n,Math.max(t,0|e))}function C(e){return Array.isArray(e)}const S=new WeakMap,A=new WeakMap;function I(e){const t="object"==typeof e&&null!==e?e:null;if(t){const e=S.get(t);if(void 0!==e)return e}let n=Number.NEGATIVE_INFINITY;const i=s(e);for(let r=0;r<i;r++){const i=l(e,r);if(!Number.isFinite(i)||i<n)return t&&S.set(t,!1),!1;n=i}return t&&S.set(t,!0),!0}function P(e,t){let n=0,i=s(e);for(;n<i;){const r=n+i>>>1;l(e,r)<t?n=r+1:i=r}return n}function R(e,t){let n=0,i=s(e);for(;n<i;){const r=n+i>>>1;l(e,r)<=t?n=r+1:i=r}return n}function E(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)&&"x"in e&&"y"in e&&"object"==typeof e.x&&"object"==typeof e.y&&"length"in e.x&&"length"in e.y}function B(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)&&ArrayBuffer.isView(e)}function T(e,t,n){const i=s(e);if(0===i||!Number.isFinite(t)||!Number.isFinite(n))return e;if(I(e)){const r=P(e,t),o=R(e,n);return r<=0&&o>=i?e:function(e,t,n){const i=s(e),r=Math.max(0,Math.min(t,i)),o=Math.max(r,Math.min(n,i));if(0===r&&o===i)return e;if(o<=r){if(E(e))return{x:[],y:[],...e.size?{size:[]}:{}};if(B(e)){if(e instanceof DataView)throw new Error("DataView is not supported for InterleavedXYData");return new(0,e.constructor)(0)}return[]}if(E(e)){const t={x:Array.isArray(e.x)?e.x.slice(r,o):"subarray"in e.x?e.x.subarray(r,o):Array.from(e.x).slice(r,o),y:Array.isArray(e.y)?e.y.slice(r,o):"subarray"in e.y?e.y.subarray(r,o):Array.from(e.y).slice(r,o)};if(e.size){const n=Array.isArray(e.size)?e.size.slice(r,o):"subarray"in e.size?e.size.subarray(r,o):Array.from(e.size).slice(r,o);t.size=n}return t}if(B(e)){if(e instanceof DataView)throw new Error("DataView is not supported for InterleavedXYData");return e.subarray(2*r,2*o)}return e.slice(r,o)}(e,r,o)}const r=[];for(let o=0;o<i;o++){const i=l(e,o);if(Number.isFinite(i)&&i>=t&&i<=n){const t=u(e,o);r.push([i,t])}}return r}function D(e,t,n){const i=s(e);if(0===i)return{start:0,end:0};if(!Number.isFinite(t)||!Number.isFinite(n))return{start:0,end:i};if(!I(e))return{start:0,end:i};const r=P(e,t),o=R(e,n),a=N(r,0,i),l=N(o,0,i);return l<=a?{start:a,end:a}:{start:a,end:l}}function U(e,t,n){const i=e.length;if(0===i||!Number.isFinite(t)||!Number.isFinite(n))return e;const r=function(e){const t=A.get(e);if(void 0!==t)return t;let n=Number.NEGATIVE_INFINITY;for(let t=0;t<e.length;t++){const i=e[t],r=C(i)?i[0]:i.timestamp;if(!Number.isFinite(r)||r<n)return A.set(e,!1),!1;n=r}return A.set(e,!0),!0}(e),o=i>0&&C(e[0]);if(r){const r=o?function(e,t){let n=0,i=e.length;for(;n<i;){const r=n+i>>>1;e[r][0]<t?n=r+1:i=r}return n}(e,t):function(e,t){let n=0,i=e.length;for(;n<i;){const r=n+i>>>1;e[r].timestamp<t?n=r+1:i=r}return n}(e,t),a=o?function(e,t){let n=0,i=e.length;for(;n<i;){const r=n+i>>>1;e[r][0]<=t?n=r+1:i=r}return n}(e,n):function(e,t){let n=0,i=e.length;for(;n<i;){const r=n+i>>>1;e[r].timestamp<=t?n=r+1:i=r}return n}(e,n);return r<=0&&a>=i?e:a<=r?[]:e.slice(r,a)}const a=[];for(let r=0;r<i;r++){const i=e[r],o=C(i)?i[0]:i.timestamp;Number.isFinite(o)&&o>=t&&o<=n&&a.push(i)}return a}const k=e=>Math.min(1,Math.max(0,e)),G=e=>Math.min(255,Math.max(0,e)),z=e=>{const t=Number.parseInt(e,16);return Number.isFinite(t)?t:0},V=e=>{const t=Number.parseInt(e,16);return Number.isFinite(t)?t:0},L=e=>{const t=e.trim();if(0===t.length)return null;if(t.endsWith("%")){const e=Number.parseFloat(t.slice(0,-1));return Number.isFinite(e)?G(e/100*255):null}const n=Number.parseFloat(t);return Number.isFinite(n)?G(n):null},W=e=>{if("string"!=typeof e)return null;const t=e.trim();if(0===t.length)return null;const n=(e=>{const t=e.trim();if(!t.startsWith("#"))return null;const n=t.slice(1);return 3===n.length?[17*z(n[0])/255,17*z(n[1])/255,17*z(n[2])/255,1]:4===n.length?[17*z(n[0])/255,17*z(n[1])/255,17*z(n[2])/255,17*z(n[3])/255]:6===n.length?[V(n.slice(0,2))/255,V(n.slice(2,4))/255,V(n.slice(4,6))/255,1]:8===n.length?[V(n.slice(0,2))/255,V(n.slice(2,4))/255,V(n.slice(4,6))/255,V(n.slice(6,8))/255]:null})(t);return n||((e=>{const t=e.trim(),n=/^(rgba?|RGBA?)\(\s*([^\)]*)\s*\)$/.exec(t);if(!n)return null;const i=n[1].toLowerCase(),r=n[2].split(",").map(e=>e.trim());if("rgb"===i){if(3!==r.length)return null;const e=L(r[0]),t=L(r[1]),n=L(r[2]);return null==e||null==t||null==n?null:[e/255,t/255,n/255,1]}if("rgba"===i){if(4!==r.length)return null;const e=L(r[0]),t=L(r[1]),n=L(r[2]),i=(e=>{const t=e.trim();if(0===t.length)return null;if(t.endsWith("%")){const e=Number.parseFloat(t.slice(0,-1));return Number.isFinite(e)?k(e/100):null}const n=Number.parseFloat(t);return Number.isFinite(n)?k(n):null})(r[3]);return null==e||null==t||null==n||null==i?null:[e/255,t/255,n/255,i]}return null})(t)||null)},O=e=>"number"==typeof e&&Number.isFinite(e)?e:void 0,_=e=>{throw new Error(`RenderCoordinator: unreachable value: ${String(e)}`)},Y=e=>Math.min(1,Math.max(0,e)),$=(e,t)=>(e+1)/2*t,X=(e,t)=>(1-e)/2*t,H=864e5,q=30*H,j=365*H,Z=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],J=(e,t)=>{if("number"==typeof e)return Number.isFinite(e)?e:null;if("string"!=typeof e)return null;const n=e.trim();if(0===n.length)return null;if(n.endsWith("%")){const e=Number.parseFloat(n.slice(0,-1));return Number.isFinite(e)?e/100*t:null}const i=Number.parseFloat(n);return Number.isFinite(i)?i:null},K=(e,t)=>{if(null==e)return{inner:0,outer:.7*t};if((e=>Array.isArray(e))(e)){const n=J(e[0],t),i=J(e[1],t),r=Math.max(0,Number.isFinite(n)?n:0),o=Math.max(r,Number.isFinite(i)?i:.7*t);return{inner:r,outer:Math.min(t,o)}}const n=J(e,t),i=Math.max(0,Number.isFinite(n)?n:.7*t);return{inner:0,outer:Math.min(t,i)}},Q=e=>String(Math.trunc(e)).padStart(2,"0"),ee=(e,t)=>{if(!Number.isFinite(e))return null;(!Number.isFinite(t)||t<0)&&(t=0);const n=new Date(e);if(!Number.isFinite(n.getTime()))return null;const i=n.getFullYear(),r=n.getMonth()+1,o=n.getDate(),a=n.getHours(),s=n.getMinutes();return t<H?`${Q(a)}:${Q(s)}`:t<=7*H?`${Q(r)}/${Q(o)} ${Q(a)}:${Q(s)}`:t<3*q?`${Q(r)}/${Q(o)}`:t<=j?`${Z[n.getMonth()]??Q(r)} ${Q(o)}`:`${i}/${Q(r)}`};function te(e){const t=function(e,t=8){const n=Math.abs(e);if(!Number.isFinite(n)||0===n)return 0;for(let e=0;e<=t;e++){const t=n*10**e,i=Math.round(t);if(Math.abs(t-i)<=1e-9*Math.max(1,Math.abs(t)))return e}return Math.max(0,Math.min(t,1-Math.floor(Math.log10(n))+1))}(e);return new Intl.NumberFormat(void 0,{maximumFractionDigits:t})}function ne(e,t){if(!Number.isFinite(t))return null;const n=Math.abs(t)<1e-12?0:t,i=e.format(n);return"NaN"===i?null:i}function ie(e,t){return(e+1)/2*t}function re(e,t){return(1-e)/2*t}function oe(e,t,n){e.style.fontFamily=n.fontFamily,e.style.fontWeight=t?"500":"400",e.style.userSelect="none",e.style.pointerEvents="none"}function ae(e){return"offsetLeft"in e}function se(e,t){return(e+1)/2*t}function le(e,t){return(1-e)/2*t}function ue(e,t){const n=W(e)??[0,0,0,1],i=Y(n[3]*Y(t));return`rgba(${Math.round(255*Y(n[0]))}, ${Math.round(255*Y(n[1]))}, ${Math.round(255*Y(n[2]))}, ${i})`}const ce=/\{(x|y|value|name)\}/g;function de(e,t,n){return ce.lastIndex=0,e.replace(ce,(e,i)=>{if("name"===i)return t.name??"";const r=t[i];return null==r?"":function(e,t){if(!Number.isFinite(e))return"";if(null==t)return String(e);const n=Math.min(20,Math.max(0,Math.floor(t)));return e.toFixed(n)}(r,n)})}function fe(e){switch(e){case"center":return"middle";case"end":return"end";default:return"start"}}function me(e,t){let n=0,i=s(e);for(;n<i;){const r=n+i>>>1;l(e,r)<t?n=r+1:i=r}return n}function pe(e,t,n){return e>=n.left&&e<=n.right&&t>=n.top&&t<=n.bottom}const he=e=>Math.min(1,Math.max(0,e)),ge=e=>{if("string"!=typeof e)return"";const t=e.trim();return t.length>0?t:""},be=e=>Array.isArray(e),ve=(e,t)=>{const n=(e=>{if(be(e)){const t=e[2];return"number"==typeof t&&Number.isFinite(t)?t:null}const t=e.size;return"number"==typeof t&&Number.isFinite(t)?t:null})(t);if(null!=n)return Math.max(0,n);const i=e.symbolSize;if("number"==typeof i)return Number.isFinite(i)?Math.max(0,i):4;if("function"==typeof i){const e=((e,t)=>{try{const n=e(t);return"number"==typeof n&&Number.isFinite(n)?n:null}catch{return null}})(i,(e=>be(e)?e:[e.x,e.y,e.size])(t));return null==e?4:Math.max(0,e)}return 4};function ye(e,t){const n=function(e){const t=new Map,n=new Array(e.length),i=new Array(e.length);let r=0;for(let o=0;o<e.length;o++){const a=ge(e[o].stack);if(i[o]=a,""!==a){const e=t.get(a);if(void 0!==e)n[o]=e;else{const e=r++;t.set(a,e),n[o]=e}}else n[o]=r++}return{clusterIndexBySeries:n,clusterCount:Math.max(1,r),stackIdBySeries:i}}(e),i=n.clusterCount,r=function(e){const t=[];for(let n=0;n<e.length;n++){const i=e[n].data,r=s(i);for(let e=0;e<r;e++){const n=l(i,e);Number.isFinite(n)&&t.push(n)}}if(t.length<2)return 1;t.sort((e,t)=>e-t);let n=Number.POSITIVE_INFINITY;for(let e=1;e<t.length;e++){const i=t[e]-t[e-1];i>0&&i<n&&(n=i)}return Number.isFinite(n)&&n>0?n:1}(e),o=function(e,t,n){if(Number.isFinite(n)&&n>0){const e=t.scale(0),i=t.scale(0+n),r=Math.abs(i-e);if(Number.isFinite(r)&&r>0)return r}const i=[];for(let n=0;n<e.length;n++){const r=e[n].data,o=s(r);for(let e=0;e<o;e++){const n=l(r,e);if(!Number.isFinite(n))continue;const o=t.scale(n);Number.isFinite(o)&&i.push(o)}}if(i.length<2)return 0;i.sort((e,t)=>e-t);let r=Number.POSITIVE_INFINITY;for(let e=1;e<i.length;e++){const t=i[e]-i[e-1];t>0&&t<r&&(r=t)}return Number.isFinite(r)&&r>0?r:0}(e,t,r),a=(e=>{let t,n,i;for(let r=0;r<e.length;r++){const o=e[r];void 0===t&&void 0!==o.barWidth&&(t=o.barWidth),void 0===n&&void 0!==o.barGap&&(n=o.barGap),void 0===i&&void 0!==o.barCategoryGap&&(i=o.barCategoryGap)}return{barWidth:t,barGap:n,barCategoryGap:i}})(e),u=he(a.barGap??.01),c=he(a.barCategoryGap??.2),d=Math.max(0,o*(1-c)),f=i+Math.max(0,i-1)*u,m=f>0?d/f:0;let p=0;const h=a.barWidth;if("number"==typeof h)p=Math.max(0,h),p=Math.min(p,m);else if("string"==typeof h){const e=(e=>{const t=e.trim().match(/^(\d+(?:\.\d+)?)%$/);if(!t)return null;const n=Number(t[1])/100;return Number.isFinite(n)?n:null})(h);p=null==e?0:m*he(e)}p>0||(p=m);const g=p*u;return{categoryStep:r,categoryWidthPx:o,barWidthPx:p,gapPx:g,clusterWidthPx:i*p+Math.max(0,i-1)*g,clusterSlots:n}}const xe=e=>{let t=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;for(let i=0;i<e.length;i++){const r=e[i].data,o=s(r);for(let e=0;e<o;e++){const i=u(r,e);Number.isFinite(i)&&(i<t&&(t=i),i>n&&(n=i))}}return!Number.isFinite(t)||!Number.isFinite(n)||t<=0&&0<=n?0:Math.abs(t)<Math.abs(n)?t:n};function we(e,t,n,i){return Number.isFinite(t)&&t>0&&Number.isFinite(e)?Math.round(e/t):Number.isFinite(i)&&i>0&&Number.isFinite(n)?Math.round(n/i):Math.round(1e6*n)}function Me(e,t,n,i,r,o=20){var a;if(!Number.isFinite(t)||!Number.isFinite(n))return null;const d=Number.isFinite(o)?Math.max(0,o):20,f=d*d,m=i.invert(t);if(!Number.isFinite(m))return null;let p=-1,h=-1,g=null,b=Number.POSITIVE_INFINITY;const v=[],y=[];for(let t=0;t<e.length;t++){const n=e[t];"bar"===(null==n?void 0:n.type)&&!1!==n.visible&&(v.push(n),y.push(t))}if(v.length>0){const o=ye(v,i);if(o.barWidthPx>0&&o.clusterWidthPx>=0){const d=function(e,t){let n=0;for(let i=0;i<e.length;i++){const r=e[i].data,o=s(r);for(let e=0;e<o;e++){const i=u(r,e);if(!Number.isFinite(i))continue;const o=t.scale(i);Number.isFinite(o)&&o>n&&(n=o)}}return Math.max(0,n)}(v,r),{baselineDomain:f,baselinePx:m}=function(e,t,n){const i=t.invert(n),r=t.invert(0),o=Math.min(i,r),a=Math.max(i,r);let s;s=Number.isFinite(o)&&Number.isFinite(a)?o<=0&&0<=a?0:o>0?o:a<0?a:xe(e):xe(e);let l=t.scale(s);return Number.isFinite(l)||(s=xe(e),l=t.scale(s)),Number.isFinite(l)||(s=0,l=t.scale(0)),{baselineDomain:s,baselinePx:l}}(v,r,d),{clusterSlots:p,barWidthPx:h,gapPx:g,clusterWidthPx:b,categoryWidthPx:x,categoryStep:w}=o,M=new Map;let F=null;for(let e=0;e<v.length;e++){const o=v[e],a=y[e]??-1;if(a<0)continue;const c=o.data,d=s(c),N=p.clusterIndexBySeries[e]??0,C=p.stackIdBySeries[e]??"";for(let e=0;e<d;e++){const o=l(c,e),s=u(c,e);if(!Number.isFinite(o)||!Number.isFinite(s))continue;const d=i.scale(o);if(!Number.isFinite(d))continue;const p=d-b/2+N*(h+g),v=p+h;let y=f,S=s;if(""!==C){let e=M.get(C);e||(e=new Map,M.set(C,e));const t=we(d,x,o,w);let n=e.get(t);n||(n={posSum:f,negSum:f},e.set(t,n)),s>=0?(y=n.posSum,S=y+s,n.posSum=S):(y=n.negSum,S=y+s,n.negSum=S)}else y=f,S=s;const A=""!==C?r.scale(y):m,I=r.scale(S);if(!Number.isFinite(A)||!Number.isFinite(I))continue;const P={left:p,right:v,top:Math.min(A,I),bottom:Math.max(A,I)};pe(t,n,P)&&(null===F||P.top<F.top||P.top===F.top&&a>F.seriesIndex)&&(F={seriesIndex:a,dataIndex:e,top:P.top})}}if(F){const t=null==(a=e[F.seriesIndex])?void 0:a.data;if(t){const e=l(t,F.dataIndex),n=u(t,F.dataIndex),i=c(t,F.dataIndex),r=void 0!==i?[e,n,i]:[e,n];return{seriesIndex:F.seriesIndex,dataIndex:F.dataIndex,point:r,distance:0}}}}}const x=[],w=[];for(let t=0;t<e.length;t++){const n=e[t];"pie"===n.type||"candlestick"===n.type||!1!==n.visible&&(x.push(n),w.push(t))}for(let e=0;e<x.length;e++){const o=x[e],a=w[e]??-1;if(a<0)continue;const v=o.data,y=s(v);if(0===y)continue;const M="scatter"===o.type?o:null;if(I(v)){const e=me(v,m);for(let o=e;o<y;o++){const e=l(v,o),s=u(v,o);if(!Number.isFinite(e)||!Number.isFinite(s))continue;const m=i.scale(e),y=r.scale(s);if(!Number.isFinite(m)||!Number.isFinite(y))continue;const x=m-t,w=y-n,F=x*x+w*w;if(x*x>b)break;let N=f;if(M){const t=c(v,o),n=d+ve(M,void 0!==t?[e,s,t]:[e,s]);N=n*n}if(!(F>N)&&(F<b||F===b&&(null===g||a<p||a===p&&o<h))){b=F,p=a,h=o;const t=c(v,o);g=void 0!==t?[e,s,t]:[e,s]}}for(let o=e-1;o>=0;o--){const e=l(v,o),s=u(v,o);if(!Number.isFinite(e)||!Number.isFinite(s))continue;const m=i.scale(e),y=r.scale(s);if(!Number.isFinite(m)||!Number.isFinite(y))continue;const x=m-t,w=y-n,F=x*x+w*w;if(x*x>b)break;let N=f;if(M){const t=c(v,o),n=d+ve(M,void 0!==t?[e,s,t]:[e,s]);N=n*n}if(!(F>N)&&(F<b||F===b&&(null===g||a<p||a===p&&o<h))){b=F,p=a,h=o;const t=c(v,o);g=void 0!==t?[e,s,t]:[e,s]}}}else for(let e=0;e<y;e++){const o=l(v,e),s=u(v,e);if(!Number.isFinite(o)||!Number.isFinite(s))continue;const m=i.scale(o),y=r.scale(s);if(!Number.isFinite(m)||!Number.isFinite(y))continue;const x=m-t,w=y-n,F=x*x+w*w;let N=f;if(M){const t=c(v,e),n=d+ve(M,void 0!==t?[o,s,t]:[o,s]);N=n*n}if(!(F>N)&&(F<b||F===b&&(null===g||a<p||a===p&&e<h))){b=F,p=a,h=e;const t=c(v,e);g=void 0!==t?[o,s,t]:[o,s]}}}return null!==g&&Number.isFinite(b)?{seriesIndex:p,dataIndex:h,point:g,distance:Math.sqrt(b)}:null}function Fe(e,t){var n;const{currentOptions:i,xScale:r,yScale:o,gridArea:a,xTickCount:s,hasCartesianSeries:l,effectivePointer:u,interactionScales:c,seriesForRender:d,withAlpha:f}=t,m=i.gridLines,p=m.show&&m.horizontal.show?m.horizontal.count:0,h=m.show&&m.vertical.show?m.vertical.count:0;if(0===p&&0===h)e.gridRenderer.prepare(a,{lineCount:{horizontal:0,vertical:0}});else if(p>0&&h>0&&m.horizontal.color!==m.vertical.color)e.gridRenderer.prepare(a,{lineCount:{horizontal:p,vertical:0},color:m.horizontal.color}),e.gridRenderer.prepare(a,{lineCount:{horizontal:0,vertical:h},color:m.vertical.color,append:!0});else{const t=p>0?m.horizontal.color:m.vertical.color;e.gridRenderer.prepare(a,{lineCount:{horizontal:p,vertical:h},color:t})}if(l&&(e.xAxisRenderer.prepare(i.xAxis,r,"x",a,i.theme.axisLineColor,i.theme.axisTickColor,s),e.yAxisRenderer.prepare(i.yAxis,o,"y",a,i.theme.axisLineColor,i.theme.axisTickColor,5)),u.hasPointer&&u.isInGrid){const t={showX:!0,showY:"sync"!==u.source,color:f(i.theme.axisLineColor,.6),lineWidth:1};e.crosshairRenderer.prepare(u.x,u.y,a,t),e.crosshairRenderer.setVisible(!0)}else e.crosshairRenderer.setVisible(!1);if("mouse"===u.source&&u.hasPointer&&u.isInGrid)if(c){const t=Me(d,u.gridX,u.gridY,c.xScale,c.yScale);if(t){const{x:r,y:o}=(e=>(e=>Array.isArray(e))(e)?{x:e[0],y:e[1]}:{x:e.x,y:e.y})(t.point),s=c.xScale.scale(r),l=c.yScale.scale(o);if(Number.isFinite(s)&&Number.isFinite(l)){const r=a.left+s,o=a.top+l,u=(e=>{const{canvasWidth:t,canvasHeight:n,devicePixelRatio:i}=e,r=e.left*i,o=t-e.right*i,a=e.top*i,s=n-e.bottom*i,l=N(Math.floor(r),0,Math.max(0,t)),u=N(Math.floor(a),0,Math.max(0,n)),c=N(Math.ceil(o),0,Math.max(0,t)),d=N(Math.ceil(s),0,Math.max(0,n));return{x:l,y:u,w:Math.max(0,c-l),h:Math.max(0,d-u)}})(a),c={centerDeviceX:r*a.devicePixelRatio,centerDeviceY:o*a.devicePixelRatio,devicePixelRatio:a.devicePixelRatio,canvasWidth:a.canvasWidth,canvasHeight:a.canvasHeight,scissor:u},d=(null==(n=i.series[t.seriesIndex])?void 0:n.color)??"#888";e.highlightRenderer.prepare(c,d,4),e.highlightRenderer.setVisible(!0)}else e.highlightRenderer.setVisible(!1)}else e.highlightRenderer.setVisible(!1)}else e.highlightRenderer.setVisible(!1);else e.highlightRenderer.setVisible(!1)}function Ne(e,t,n){const i=W(e??n)??W(n)??[1,1,1,1],r=null==t?1:Y(t);return[Y(i[0]),Y(i[1]),Y(i[2]),Y(i[3]*r)]}function Ce(e,t){const n=W(e)??[0,0,0,1],i=Y(n[3]*Y(t));return`rgba(${Math.round(255*Y(n[0]))}, ${Math.round(255*Y(n[1]))}, ${Math.round(255*Y(n[2]))}, ${i})`}function Se(e,t,n){return e.replace(/\{(x|y|value|name)\}/g,(e,i)=>{if("name"===i)return t.name??"";const r=t[i];return null==r?"":function(e,t){if(!Number.isFinite(e))return"";if(null==t)return String(e);const n=Math.min(20,Math.max(0,Math.floor(t)));return e.toFixed(n)}(r,n)})}function Ae(e){switch(e){case"center":return"middle";case"end":return"end";default:return"start"}}function Ie(e){return Math.max(0,Math.min(1,e))}function Pe(e){return"area"===e.type||"line"===e.type&&!!e.areaStyle}const Re="// grid.wgsl\n// Minimal grid line shader:\n// - Vertex input: vec2<f32> position in clip-space coordinates\n// - Uniforms: identity transform + solid RGBA color\n\nstruct VSUniforms {\n  transform: mat4x4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;\n\nstruct FSUniforms {\n  color: vec4<f32>,\n};\n\n@group(0) @binding(1) var<uniform> fsUniforms: FSUniforms;\n\nstruct VSIn {\n  @location(0) position: vec2<f32>,\n};\n\nstruct VSOut {\n  @builtin(position) clipPosition: vec4<f32>,\n};\n\n@vertex\nfn vsMain(in: VSIn) -> VSOut {\n  var out: VSOut;\n  out.clipPosition = vsUniforms.transform * vec4<f32>(in.position, 0.0, 1.0);\n  return out;\n}\n\n@fragment\nfn fsMain() -> @location(0) vec4<f32> {\n  return fsUniforms.color;\n}\n",Ee=(e,t,n)=>{if(n&&n.device!==e)throw new Error("getStageModule(pipelineCache): cache.device must match the provided GPUDevice.");return"module"in t?{module:t.module,entryPoint:t.entryPoint||"",constants:t.constants}:{module:Be(e,t.code,t.label,n),entryPoint:t.entryPoint||"",constants:t.constants}};function Be(e,t,n,i){if("string"!=typeof t||0===t.length)throw new Error("createShaderModule(code): WGSL code must be a non-empty string.");if(i){if(i.device!==e)throw new Error("createShaderModule(pipelineCache): cache.device must match the provided GPUDevice.");return i.getOrCreateShaderModule(t,n)}return e.createShaderModule({code:t,label:n})}function Te(e,t,n){if(n&&n.device!==e)throw new Error("createRenderPipeline(pipelineCache): cache.device must match the provided GPUDevice.");const i=Ee(e,t.vertex,n),r=i.entryPoint||"vsMain";let o;if(t.fragment){const i=Ee(e,t.fragment,n),r=i.entryPoint||"fsMain";let a;if(t.fragment.targets)a=[...t.fragment.targets];else{const e=t.fragment.formats;if(!e)throw new Error("createRenderPipeline(fragment): provide either `fragment.targets` or `fragment.formats` when a fragment stage is present.");if("string"==typeof e)a=[{format:e,blend:t.fragment.blend,writeMask:t.fragment.writeMask}];else{a=new Array(e.length);for(let n=0;n<e.length;n++)a[n]={format:e[n],blend:t.fragment.blend,writeMask:t.fragment.writeMask}}}o={module:i.module,entryPoint:r,targets:a,constants:i.constants}}const a=t.primitive??{topology:"triangle-list"},s=t.multisample??{count:1};let l;l=null!=t.layout?t.layout:t.bindGroupLayouts?e.createPipelineLayout({bindGroupLayouts:[...t.bindGroupLayouts]}):"auto";const u={label:t.label,layout:l,vertex:{module:i.module,entryPoint:r,buffers:t.vertex.buffers?[...t.vertex.buffers]:[],constants:i.constants},fragment:o,primitive:a,depthStencil:t.depthStencil,multisample:s};return n?n.getOrCreateRenderPipeline(u):e.createRenderPipeline(u)}function De(e,t,n){if(n&&n.device!==e)throw new Error("createComputePipeline(pipelineCache): cache.device must match the provided GPUDevice.");return n?n.getOrCreateComputePipeline(t):e.createComputePipeline(t)}function Ue(e,t,n){if(!Number.isFinite(t)||t<=0)throw new Error(`createUniformBuffer(size): size must be a positive number. Received: ${String(t)}`);const i=(null==n?void 0:n.alignment)??16,r=((e,t)=>{if(!Number.isFinite(e)||e<0)throw new Error(`alignTo(value): value must be a finite non-negative number. Received: ${String(e)}`);if(!(e=>Number.isInteger(e)&&e>0&&!(e&e-1))(t))throw new Error(`alignTo(alignment): alignment must be a positive power of two. Received: ${String(t)}`);return Math.floor(e)+t-1&~(t-1)})(t,Math.max(4,i)),o=e.limits.maxUniformBufferBindingSize;if(r>o)throw new Error(`createUniformBuffer(size): requested size ${r} exceeds device.limits.maxUniformBufferBindingSize (${o}).`);return e.createBuffer({label:null==n?void 0:n.label,size:r,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})}function ke(e,t,n){const i=n instanceof ArrayBuffer?{arrayBuffer:n,offset:0,size:n.byteLength}:{arrayBuffer:n.buffer,offset:n.byteOffset,size:n.byteLength};if(0!==i.size){if(3&i.offset||3&i.size)throw new Error(`writeUniformBuffer(data): data byteOffset (${i.offset}) and byteLength (${i.size}) must be multiples of 4 for queue.writeBuffer().`);if(i.size>t.size)throw new Error(`writeUniformBuffer(data): data byteLength (${i.size}) exceeds buffer.size (${t.size}).`);e.queue.writeBuffer(t,0,i.arrayBuffer,i.offset,i.size)}}const Ge=[1,1,1,.8],ze=e=>"number"==typeof e&&Number.isFinite(e)?e:void 0;function Ve(e,t){let n=!1;const i=(null==t?void 0:t.targetFormat)??"bgra8unorm",r=(null==t?void 0:t.sampleCount)??1,o=Number.isFinite(r)?Math.max(1,Math.floor(r)):1,a=null==t?void 0:t.pipelineCache,s=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),l=Ue(e,64,{label:"axisRenderer/vsUniforms"}),u=Ue(e,16,{label:"axisRenderer/fsUniformsLine"}),c=Ue(e,16,{label:"axisRenderer/fsUniformsTick"}),d=e.createBindGroup({layout:s,entries:[{binding:0,resource:{buffer:l}},{binding:1,resource:{buffer:u}}]}),f=e.createBindGroup({layout:s,entries:[{binding:0,resource:{buffer:l}},{binding:1,resource:{buffer:c}}]}),m=Te(e,{label:"axisRenderer/pipeline",bindGroupLayouts:[s],vertex:{code:Re,label:"grid.wgsl",buffers:[{arrayStride:8,stepMode:"vertex",attributes:[{shaderLocation:0,format:"float32x2",offset:0}]}]},fragment:{code:Re,label:"grid.wgsl",formats:i,blend:{color:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}}},primitive:{topology:"line-list",cullMode:"none"},multisample:{count:o}},a);let p=null,h=0;const g=()=>{if(n)throw new Error("AxisRenderer is disposed.")};return{prepare:(t,n,i,r,o,a,s)=>{if(g(),"x"!==i&&"y"!==i)throw new Error("AxisRenderer.prepare: orientation must be 'x' or 'y'.");const d=((e,t,n,i,r)=>{const{left:o,right:a,top:s,bottom:l,canvasWidth:u,canvasHeight:c}=i,d=Number.isFinite(i.devicePixelRatio)&&i.devicePixelRatio>0?i.devicePixelRatio:1;if(!(e=>Number.isFinite(e.left)&&Number.isFinite(e.right)&&Number.isFinite(e.top)&&Number.isFinite(e.bottom)&&Number.isFinite(e.canvasWidth)&&Number.isFinite(e.canvasHeight))(i))throw new Error("AxisRenderer.prepare: gridArea dimensions must be finite numbers.");if(u<=0||c<=0)throw new Error("AxisRenderer.prepare: canvas dimensions must be positive.");if(o<0||a<0||s<0||l<0)throw new Error("AxisRenderer.prepare: gridArea margins must be non-negative.");const f=o*d/u*2-1,m=(u-a*d)/u*2-1,p=1-s*d/c*2,h=1-(c-l*d)/c*2,g=e.tickLength??6;if(!Number.isFinite(g)||g<0)throw new Error("AxisRenderer.prepare: tickLength must be a finite non-negative number.");const b=r??5,v=Math.max(1,Math.floor(b));if(!Number.isFinite(b)||v<1)throw new Error("AxisRenderer.prepare: tickCount must be a finite number >= 1.");const y=g*d,x=y/u*2,w=y/c*2,M=((e,t)=>{let n=e,i=t;if((!Number.isFinite(n)||!Number.isFinite(i))&&(n=0,i=1),n===i)i=n+1;else if(n>i){const e=n;n=i,i=e}return{min:n,max:i}})(ze(e.min)??("x"===n?t.invert(f):t.invert(h)),ze(e.max)??("x"===n?t.invert(m):t.invert(p))),F=M.min,N=M.max,C=new Float32Array(2*(1+v)*2);let S=0;if("x"===n){C[S++]=f,C[S++]=h,C[S++]=m,C[S++]=h;const e=h,n=e-w;for(let i=0;i<v;i++){const r=F+(1===v?.5:i/(v-1))*(N-F),o=t.scale(r);C[S++]=o,C[S++]=e,C[S++]=o,C[S++]=n}}else{C[S++]=f,C[S++]=h,C[S++]=f,C[S++]=p;const e=f,n=e-x;for(let i=0;i<v;i++){const r=F+(1===v?.5:i/(v-1))*(N-F),o=t.scale(r);C[S++]=e,C[S++]=o,C[S++]=n,C[S++]=o}}return C})(t,n,i,r,s),f=d.byteLength,m=Math.max(4,f);if(!p||p.size<m){if(p)try{p.destroy()}catch{}p=e.createBuffer({label:"axisRenderer/vertexBuffer",size:m,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST})}e.queue.writeBuffer(p,0,d.buffer,0,d.byteLength),h=d.length/2,ke(e,l,(()=>{const e=new ArrayBuffer(64);return new Float32Array(e).set([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),e})());const b=o??"rgba(255,255,255,0.8)",v=a??b,y=W(b)??Ge,x=W(v)??y,w=new ArrayBuffer(16);new Float32Array(w).set([y[0],y[1],y[2],y[3]]),ke(e,u,w);const M=new ArrayBuffer(16);new Float32Array(M).set([x[0],x[1],x[2],x[3]]),ke(e,c,M)},render:e=>{g(),0!==h&&p&&(e.setPipeline(m),e.setVertexBuffer(0,p),e.setBindGroup(0,d),e.draw(Math.min(2,h)),h>2&&(e.setBindGroup(0,f),e.draw(h-2,1,2,0)))},dispose:()=>{if(!n){n=!0;try{l.destroy()}catch{}try{u.destroy()}catch{}try{c.destroy()}catch{}if(p)try{p.destroy()}catch{}p=null,h=0}}}}const Le=[1,1,1,.15];const We='// area.wgsl\n// Minimal area-fill shader (triangle-strip):\n// - Vertex input: vec2<f32> position in data coords\n// - Uniforms: clip-space transform + baseline value + solid RGBA color\n// - Topology: triangle-strip\n// - CPU duplicates vertices as p0,p0,p1,p1,... and we use vertex_index parity:\n//   even index -> "top" vertex (original y)\n//   odd index  -> "baseline" vertex (uniform baseline)\n\nstruct VSUniforms {\n  transform: mat4x4<f32>,\n  baseline: f32,\n  // Pad to 16-byte multiple (uniform buffer layout requirements).\n  _pad0: vec3<f32>,\n};\n\n@group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;\n\nstruct FSUniforms {\n  color: vec4<f32>,\n};\n\n@group(0) @binding(1) var<uniform> fsUniforms: FSUniforms;\n\nstruct VSIn {\n  @location(0) position: vec2<f32>,\n};\n\nstruct VSOut {\n  @builtin(position) clipPosition: vec4<f32>,\n};\n\n@vertex\nfn vsMain(in: VSIn, @builtin(vertex_index) vertexIndex: u32) -> VSOut {\n  var out: VSOut;\n  let useBaseline = (vertexIndex & 1u) == 1u;\n  let y = select(in.position.y, vsUniforms.baseline, useBaseline);\n  let pos = vec2<f32>(in.position.x, y);\n  out.clipPosition = vsUniforms.transform * vec4<f32>(pos, 0.0, 1.0);\n  return out;\n}\n\n@fragment\nfn fsMain() -> @location(0) vec4<f32> {\n  return fsUniforms.color;\n}\n\n',Oe=e=>Math.min(1,Math.max(0,e)),_e=(e,t,n)=>{const i=e.scale(t),r=e.scale(n);if(!(Number.isFinite(t)&&Number.isFinite(n)&&t!==n&&Number.isFinite(i)&&Number.isFinite(r)))return{a:0,b:Number.isFinite(i)?i:0};const o=(r-i)/(n-t),a=i-o*t;return{a:Number.isFinite(o)?o:0,b:Number.isFinite(a)?a:0}};function Ye(e,t){let n=!1;const i=(null==t?void 0:t.targetFormat)??"bgra8unorm",r=null==t?void 0:t.sampleCount,o=Number.isFinite(r)?Math.max(1,Math.floor(r)):1,a=null==t?void 0:t.pipelineCache,c=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),d=Ue(e,96,{label:"areaRenderer/vsUniforms"}),m=Ue(e,16,{label:"areaRenderer/fsUniforms"}),p=new ArrayBuffer(96),h=new Float32Array(p),g=new Float32Array(4),b=e.createBindGroup({layout:c,entries:[{binding:0,resource:{buffer:d}},{binding:1,resource:{buffer:m}}]}),v=Te(e,{label:"areaRenderer/pipeline",bindGroupLayouts:[c],vertex:{code:We,label:"area.wgsl",buffers:[{arrayStride:8,stepMode:"vertex",attributes:[{shaderLocation:0,format:"float32x2",offset:0}]}]},fragment:{code:We,label:"area.wgsl",formats:i,blend:{color:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}}},primitive:{topology:"triangle-strip",cullMode:"none"},multisample:{count:o}},a);let y=null,x=0;const w=()=>{if(n)throw new Error("AreaRenderer is disposed.")};return{prepare:(t,n,i,r,o)=>{w();const a=(e=>{const t=s(e),n=new Float32Array(2*t*2);let i=0;for(let r=0;r<t;r++){const t=l(e,r),o=u(e,r);n[i++]=t,n[i++]=o,n[i++]=t,n[i++]=o}return n})(n),c=a.byteLength,b=Math.max(4,c);if(!y||y.size<b){if(y)try{y.destroy()}catch{}y=e.createBuffer({label:"areaRenderer/vertexBuffer",size:b,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST})}a.byteLength>0&&e.queue.writeBuffer(y,0,a.buffer,0,a.byteLength),x=a.length/2;const v=f(n),{xMin:M,xMax:F,yMin:N,yMax:C}=v??{xMin:0,xMax:1,yMin:0,yMax:1},{a:S,b:A}=_e(i,M,F),{a:I,b:P}=_e(r,N,C);((t,n,i,r,o)=>{((e,t,n,i,r)=>{e[0]=t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=n,e[13]=r,e[14]=0,e[15]=1})(h,t,n,i,r),h[16]=o,h[17]=0,h[18]=0,h[19]=0,h[20]=0,h[21]=0,h[22]=0,h[23]=0,ke(e,d,p)})(S,A,I,P,Number.isFinite(o??Number.NaN)?o:Number.isFinite(N)?N:0);const[R,E,B,T]=(e=>W(e)??[0,0,0,1])(t.areaStyle.color),D=Oe(t.areaStyle.opacity);g[0]=R,g[1]=E,g[2]=B,g[3]=Oe(T*D),ke(e,m,g)},render:e=>{w(),y&&!(x<4)&&(e.setPipeline(v),e.setBindGroup(0,b),e.setVertexBuffer(0,y),e.draw(x))},dispose:()=>{if(!n){if(n=!0,y)try{y.destroy()}catch{}y=null,x=0;try{d.destroy()}catch{}try{m.destroy()}catch{}}}}}const $e='// line.wgsl — Screen-space quad expansion with SDF-based anti-aliasing.\n//\n// Each "instance" draws one line segment (point[i] → point[i+1]).\n// 6 vertices per instance (2 triangles = 1 quad per segment).\n//\n// The vertex shader:\n//   1. Reads endpoints from a storage buffer.\n//   2. Transforms both to clip space using the mat4x4 transform.\n//   3. Converts clip→screen (NDC * canvasSize * 0.5).\n//   4. Computes the perpendicular direction in screen space.\n//   5. Offsets vertices by ±(halfWidth + AA_PADDING) along the perpendicular.\n//   6. Converts back to clip space.\n//   7. Outputs `acrossDevice` varying for SDF-based AA.\n//\n// The fragment shader applies smoothstep AA on the distance-from-edge.\n\nconst AA_PADDING: f32 = 1.5;\n\nstruct VSUniforms {\n  transform       : mat4x4<f32>,  // 64 bytes: data-coord → clip-space\n  canvasSize      : vec2<f32>,     //  8 bytes: device pixels (width, height)\n  devicePixelRatio: f32,           //  4 bytes\n  lineWidthCssPx  : f32,           //  4 bytes: line width in CSS pixels\n};\n// Total: 80 bytes (aligned to 16).\n\n@group(0) @binding(0) var<uniform> vsUniforms : VSUniforms;\n\nstruct FSUniforms {\n  color : vec4<f32>,\n};\n\n@group(0) @binding(1) var<uniform> fsUniforms : FSUniforms;\n\n@group(0) @binding(2) var<storage, read> points : array<vec2<f32>>;\n\nstruct VSOut {\n  @builtin(position) clipPosition : vec4<f32>,\n  @location(0) acrossDevice       : f32,\n  @location(1) @interpolate(flat) widthDevice : f32,\n};\n\n// Returns UV for the 6 vertices of a quad (2 triangles):\n//   uv.x: 0 → endpoint A, 1 → endpoint B\n//   uv.y: 0 → +side, 1 → −side\nfn quadUv(vid : u32) -> vec2<f32> {\n  switch (vid) {\n    case 0u: { return vec2<f32>(0.0, 0.0); }\n    case 1u: { return vec2<f32>(1.0, 0.0); }\n    case 2u: { return vec2<f32>(0.0, 1.0); }\n    case 3u: { return vec2<f32>(0.0, 1.0); }\n    case 4u: { return vec2<f32>(1.0, 0.0); }\n    default: { return vec2<f32>(1.0, 1.0); }\n  }\n}\n\n@vertex\nfn vsMain(\n  @builtin(vertex_index) vid : u32,\n  @builtin(instance_index) iid : u32,\n) -> VSOut {\n  let uv = quadUv(vid);\n\n  // Read segment endpoints in data coordinates.\n  let pA_data = points[iid];\n  let pB_data = points[iid + 1u];\n\n  // Transform to clip space.\n  let clipA = vsUniforms.transform * vec4<f32>(pA_data, 0.0, 1.0);\n  let clipB = vsUniforms.transform * vec4<f32>(pB_data, 0.0, 1.0);\n\n  // Convert clip → screen (device pixels). \n  // screen = (ndc * 0.5 + 0.5) * canvasSize, but Y is flipped.\n  let ndcA = clipA.xy / clipA.w;\n  let ndcB = clipB.xy / clipB.w;\n  let screenA = vec2<f32>(\n    (ndcA.x * 0.5 + 0.5) * vsUniforms.canvasSize.x,\n    (1.0 - (ndcA.y * 0.5 + 0.5)) * vsUniforms.canvasSize.y,\n  );\n  let screenB = vec2<f32>(\n    (ndcB.x * 0.5 + 0.5) * vsUniforms.canvasSize.x,\n    (1.0 - (ndcB.y * 0.5 + 0.5)) * vsUniforms.canvasSize.y,\n  );\n\n  // Segment direction and perpendicular in screen space.\n  let delta = screenB - screenA;\n  let segLen = length(delta);\n\n  // Degenerate segment: collapse quad to a degenerate triangle.\n  if (segLen < 1e-6) {\n    var out : VSOut;\n    out.clipPosition = clipA;\n    out.acrossDevice = 0.0;\n    out.widthDevice = 0.0;\n    return out;\n  }\n\n  let dir = delta / segLen;\n  // Perpendicular: rotate 90° CW → (dy, -dx).\n  let perp = vec2<f32>(dir.y, -dir.x);\n\n  // Compute line width in device pixels + AA padding.\n  let dpr = max(vsUniforms.devicePixelRatio, 1e-6);\n  let widthDevice = max(1.0, vsUniforms.lineWidthCssPx * dpr);\n  let halfExtent = widthDevice * 0.5 + AA_PADDING;\n\n  // Select endpoint: uv.x=0 → A, uv.x=1 → B.\n  let baseScreen = mix(screenA, screenB, uv.x);\n\n  // Offset perpendicular: uv.y selects +side (0) vs −side (1).\n  let side = mix(1.0, -1.0, uv.y);\n  let screenPos = baseScreen + perp * halfExtent * side;\n\n  // acrossDevice: 0 at −side edge, widthDevice at +side edge.\n  // Map from [−halfExtent, +halfExtent] to [0, widthDevice + 2*AA_PADDING].\n  let totalExtent = 2.0 * halfExtent;\n  let acrossDevice = (side * halfExtent + halfExtent) / totalExtent * totalExtent;\n  // Simplified: acrossDevice = halfExtent * (1 + side) = halfExtent + halfExtent * side\n  // But for the fragment shader we want [0, totalExtent]:\n  // Let\'s define it properly:\n  // At side=+1: screenPos is at +halfExtent from center → acrossDevice = totalExtent\n  // At side=-1: screenPos is at -halfExtent from center → acrossDevice = 0\n  let acrossDeviceVal = halfExtent * (1.0 + side);\n\n  // Convert screen → clip.\n  let clipX = (screenPos.x / vsUniforms.canvasSize.x) * 2.0 - 1.0;\n  let clipY = 1.0 - (screenPos.y / vsUniforms.canvasSize.y) * 2.0;\n\n  var out : VSOut;\n  out.clipPosition = vec4<f32>(clipX, clipY, 0.0, 1.0);\n  out.acrossDevice = acrossDeviceVal;\n  out.widthDevice = widthDevice;\n  return out;\n}\n\n@fragment\nfn fsMain(in : VSOut) -> @location(0) vec4<f32> {\n  let totalExtent = in.widthDevice + 2.0 * AA_PADDING;\n  let edgeDist = min(in.acrossDevice, totalExtent - in.acrossDevice);\n\n  // Smooth step from 0 to AA zone for anti-aliased edges.\n  let aa = max(fwidth(in.acrossDevice), 1e-3) * 1.25;\n  let edgeCoverage = smoothstep(0.0, aa, edgeDist);\n\n  // Also fade out in the AA_PADDING region (beyond the nominal half-width).\n  // The padding zone is [0, AA_PADDING] at each edge.\n  // Distance from the nominal edge = edgeDist - AA_PADDING (negative means inside).\n  // Actually, remap: the nominal line occupies [AA_PADDING, AA_PADDING + widthDevice].\n  let nominalDist = min(in.acrossDevice - AA_PADDING, (AA_PADDING + in.widthDevice) - in.acrossDevice);\n  let paddingCoverage = smoothstep(0.0, aa, nominalDist);\n\n  // Combine: paddingCoverage handles the SDF fade, edgeCoverage handles the outer trim.\n  // For thin lines (< 1 device px), paddingCoverage alone provides the desired fade.\n  let coverage = min(edgeCoverage, paddingCoverage);\n\n  var color = fsUniforms.color;\n  color = vec4<f32>(color.rgb, color.a * coverage);\n  return color;\n}\n',Xe=e=>Math.min(1,Math.max(0,e)),He=(e,t,n)=>{const i=e.scale(t),r=e.scale(n);if(!(Number.isFinite(t)&&Number.isFinite(n)&&t!==n&&Number.isFinite(i)&&Number.isFinite(r)))return{a:0,b:Number.isFinite(i)?i:0};const o=(r-i)/(n-t),a=i-o*t;return{a:Number.isFinite(o)?o:0,b:Number.isFinite(a)?a:0}};function qe(e,t){let n=!1;const i=(null==t?void 0:t.targetFormat)??"bgra8unorm",r=null==t?void 0:t.sampleCount,o=Number.isFinite(r)?Math.max(1,Math.floor(r)):1,a=null==t?void 0:t.pipelineCache,l=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]}),u=Ue(e,80,{label:"lineRenderer/vsUniforms"}),c=Ue(e,16,{label:"lineRenderer/fsUniforms"}),d=new ArrayBuffer(80),m=new Float32Array(d),p=new Float32Array(4);let h=null;const g=Te(e,{label:"lineRenderer/pipeline",bindGroupLayouts:[l],vertex:{code:$e,label:"line.wgsl",buffers:[]},fragment:{code:$e,label:"line.wgsl",formats:i,blend:{color:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}}},primitive:{topology:"triangle-list",cullMode:"none"},multisample:{count:o}},a);let b=0;const v=()=>{if(n)throw new Error("LineRenderer is disposed.")};return{prepare:(t,n,i,r,o=0,a=1,g=1,y=1)=>{v(),b=s(t.data);const x=f(t.data),{xMin:w,xMax:M,yMin:F,yMax:N}=x??{xMin:0,xMax:1,yMin:0,yMax:1},{a:C,b:S}=He(i,w,M),{a:A,b:I}=He(r,F,N);((e,t,n,i,r)=>{e[0]=t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=n,e[13]=r,e[14]=0,e[15]=1})(m,C,S+C*o,A,I);const P=Number.isFinite(a)&&a>0?a:1,R=Number.isFinite(g)&&g>0?g:1,E=Number.isFinite(y)&&y>0?y:1,B=Number.isFinite(t.lineStyle.width)&&t.lineStyle.width>0?t.lineStyle.width:2;m[16]=R,m[17]=E,m[18]=P,m[19]=B,ke(e,u,d);const[T,D,U,k]=(e=>W(e)??[0,0,0,1])(t.color),G=Xe(t.lineStyle.opacity);p[0]=T,p[1]=D,p[2]=U,p[3]=Xe(k*G),ke(e,c,p),h=e.createBindGroup({layout:l,entries:[{binding:0,resource:{buffer:u}},{binding:1,resource:{buffer:c}},{binding:2,resource:{buffer:n}}]})},render:e=>{v(),h&&!(b<2)&&(e.setPipeline(g),e.setBindGroup(0,h),e.draw(6,b-1))},dispose:()=>{if(!n){n=!0,h=null,b=0;try{u.destroy()}catch{}try{c.destroy()}catch{}}}}}const je="// scatter.wgsl\n// Instanced anti-aliased circle shader (SDF):\n// - Per-instance vertex input:\n//   - center   = vec2<f32> point center (transformed by VSUniforms.transform)\n//   - radiusPx = f32 circle radius in pixels\n// - Draw call: draw(6, instanceCount) using triangle-list expansion in VS\n// - Uniforms:\n//   - @group(0) @binding(0): VSUniforms { transform, viewportPx }\n//   - @group(0) @binding(1): FSUniforms { color }\n//\n// Notes:\n// - `viewportPx` is the current render target size in pixels (width, height).\n// - The quad is expanded in clip space using `radiusPx` and `viewportPx`.\n\nstruct VSUniforms {\n  transform: mat4x4<f32>,\n  viewportPx: vec2<f32>,\n  // Pad to 16-byte alignment (mat4x4 is 64B; vec2 adds 8B; pad to 80B).\n  _pad0: vec2<f32>,\n};\n\n@group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;\n\nstruct FSUniforms {\n  color: vec4<f32>,\n};\n\n@group(0) @binding(1) var<uniform> fsUniforms: FSUniforms;\n\nstruct VSIn {\n  @location(0) center: vec2<f32>,\n  @location(1) radiusPx: f32,\n};\n\nstruct VSOut {\n  @builtin(position) clipPosition: vec4<f32>,\n  @location(0) localPx: vec2<f32>,\n  @location(1) radiusPx: f32,\n};\n\n@vertex\nfn vsMain(in: VSIn, @builtin(vertex_index) vertexIndex: u32) -> VSOut {\n  // Fixed local corners for 2 triangles (triangle-list).\n  // `localNdc` is a quad in [-1, 1]^2; we convert it to pixel offsets via radiusPx.\n  let localNdc = array<vec2<f32>, 6>(\n    vec2<f32>(-1.0, -1.0),\n    vec2<f32>( 1.0, -1.0),\n    vec2<f32>(-1.0,  1.0),\n    vec2<f32>(-1.0,  1.0),\n    vec2<f32>( 1.0, -1.0),\n    vec2<f32>( 1.0,  1.0)\n  );\n\n  let corner = localNdc[vertexIndex];\n  let localPx = corner * in.radiusPx;\n\n  // Convert pixel offset to clip-space offset.\n  // Clip space spans [-1, 1] across the viewport, so px -> clip is (2 / viewportPx).\n  let localClip = localPx * (2.0 / vsUniforms.viewportPx);\n\n  let centerClip = (vsUniforms.transform * vec4<f32>(in.center, 0.0, 1.0)).xy;\n\n  var out: VSOut;\n  out.clipPosition = vec4<f32>(centerClip + localClip, 0.0, 1.0);\n  out.localPx = localPx;\n  out.radiusPx = in.radiusPx;\n  return out;\n}\n\n@fragment\nfn fsMain(in: VSOut) -> @location(0) vec4<f32> {\n  // Signed distance to the circle boundary (negative inside).\n  let dist = length(in.localPx) - in.radiusPx;\n\n  // Analytic-ish AA: smooth edge based on derivative of dist in screen space.\n  let w = fwidth(dist);\n  let a = 1.0 - smoothstep(0.0, w, dist);\n\n  // Discard fully outside to avoid unnecessary blending work.\n  if (a <= 0.0) {\n    discard;\n  }\n\n  return vec4<f32>(fsUniforms.color.rgb, fsUniforms.color.a * a);\n}\n\n",Ze=(e,t,n)=>Math.min(n,Math.max(t,0|e)),Je=e=>{if(!Number.isFinite(e)||e<=0)return 1;const t=Math.ceil(e);return 2**Math.ceil(Math.log2(t))},Ke=(e,t,n)=>{const i=e.scale(t),r=e.scale(n);if(!(Number.isFinite(t)&&Number.isFinite(n)&&t!==n&&Number.isFinite(i)&&Number.isFinite(r)))return{a:0,b:Number.isFinite(i)?i:0};const o=(r-i)/(n-t),a=i-o*t;return{a:Number.isFinite(o)?o:0,b:Number.isFinite(a)?a:0}};function Qe(e,t){let n=!1;const i=(null==t?void 0:t.targetFormat)??"bgra8unorm",r=null==t?void 0:t.sampleCount,o=Number.isFinite(r)?Math.max(1,Math.floor(r)):1,a=null==t?void 0:t.pipelineCache,d=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),m=Ue(e,80,{label:"scatterRenderer/vsUniforms"}),p=Ue(e,16,{label:"scatterRenderer/fsUniforms"}),h=new ArrayBuffer(80),g=new Float32Array(h),b=new Float32Array(4),v=e.createBindGroup({layout:d,entries:[{binding:0,resource:{buffer:m}},{binding:1,resource:{buffer:p}}]}),y=Te(e,{label:"scatterRenderer/pipeline",bindGroupLayouts:[d],vertex:{code:je,label:"scatter.wgsl",buffers:[{arrayStride:16,stepMode:"instance",attributes:[{shaderLocation:0,format:"float32x2",offset:0},{shaderLocation:1,format:"float32",offset:8}]}]},fragment:{code:je,label:"scatter.wgsl",formats:i,blend:{color:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}}},primitive:{topology:"triangle-list",cullMode:"none"},multisample:{count:o}},a);let x=null,w=0,M=new ArrayBuffer(0),F=new Float32Array(M),N=0,C=0,S=[1,1],A=null;const I=()=>{if(n)throw new Error("ScatterRenderer is disposed.")},P=(t,n,i,r,o,a)=>{const s=Number.isFinite(o)&&o>0?o:1,l=Number.isFinite(a)&&a>0?a:1;((e,t,n,i,r)=>{e[0]=t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=n,e[13]=r,e[14]=0,e[15]=1})(g,t,n,i,r),g[16]=s,g[17]=l,g[18]=0,g[19]=0,ke(e,m,h),S=[s,l]};return{prepare:(t,n,i,r,o)=>{I();const a=f(n),{xMin:d,xMax:m,yMin:h,yMax:g}=a??{xMin:0,xMax:1,yMin:0,yMax:1},{a:v,b:y}=Ke(i,d,m),{a:R,b:E}=Ke(r,h,g);o?(N=o.canvasWidth,C=o.canvasHeight,P(v,y,R,E,o.canvasWidth,o.canvasHeight),A=(e=>{const{canvasWidth:t,canvasHeight:n,devicePixelRatio:i}=e,r=e.left*i,o=t-e.right*i,a=e.top*i,s=n-e.bottom*i,l=Ze(Math.floor(r),0,Math.max(0,t)),u=Ze(Math.floor(a),0,Math.max(0,n)),c=Ze(Math.ceil(o),0,Math.max(0,t)),d=Ze(Math.ceil(s),0,Math.max(0,n));return{x:l,y:u,w:Math.max(0,c-l),h:Math.max(0,d-u)}})(o)):(P(v,y,R,E,S[0],S[1]),A=null);const[B,T,D,U]=(e=>W(e)??[0,0,0,1])(t.color);b[0]=B,b[1]=T,b[2]=D,b[3]=(e=>Math.min(1,Math.max(0,e)))(U),ke(e,p,b);const k=(null==o?void 0:o.devicePixelRatio)??1,G=k>0&&Number.isFinite(k),z=t.symbolSize,V=[0,0,void 0],L="function"==typeof z?(e,t,n)=>{V[0]=e,V[1]=t,V[2]=n;const i=z(V);return"number"==typeof i&&Number.isFinite(i)?i:4}:"number"==typeof z&&Number.isFinite(z)?(e,t,n)=>z:(e,t,n)=>4,O=s(n);(e=>{if(e<=F.length)return;const t=Math.max(8,Je(e));M=new ArrayBuffer(4*t),F=new Float32Array(M)})(4*O);const _=F;let Y=0;for(let e=0;e<O;e++){const t=l(n,e),i=u(n,e);if(!Number.isFinite(t)||!Number.isFinite(i))continue;const r=c(n,e),o=r??L(t,i,r),a=Number.isFinite(o)?Math.max(0,o):4,s=G?a*k:a;s>0&&(_[Y+0]=t,_[Y+1]=i,_[Y+2]=s,_[Y+3]=0,Y+=4)}w=Y/4;const $=Math.max(4,16*w);if(!x||x.size<$){const t=Math.max(Math.max(4,Je($)),x?x.size:0);if(x)try{x.destroy()}catch{}x=e.createBuffer({label:"scatterRenderer/instanceBuffer",size:t,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST})}x&&w>0&&e.queue.writeBuffer(x,0,M,0,16*w)},render:e=>{I(),x&&0!==w&&(A&&N>0&&C>0&&e.setScissorRect(A.x,A.y,A.w,A.h),e.setPipeline(y),e.setBindGroup(0,v),e.setVertexBuffer(0,x),e.draw(6,w),A&&N>0&&C>0&&e.setScissorRect(0,0,N,C))},dispose:()=>{if(!n){if(n=!0,x)try{x.destroy()}catch{}x=null,w=0;try{m.destroy()}catch{}try{p.destroy()}catch{}N=0,C=0,S=[1,1],A=null}}}}const et="struct RenderUniforms {\n  plotOriginPx: vec2<u32>,\n  plotSizePx: vec2<u32>,\n  binSizePx: u32,\n  binCountX: u32,\n  binCountY: u32,\n  normalization: u32,\n  _pad: vec2<u32>,\n};\n\n@group(0) @binding(0) var<uniform> u: RenderUniforms;\n@group(0) @binding(1) var<storage, read> bins: array<u32>;\n@group(0) @binding(2) var<storage, read> maxBuf: array<u32>;\n@group(0) @binding(3) var lutTex: texture_2d<f32>;\n\nstruct VsOut {\n  @builtin(position) position: vec4f,\n};\n\n@vertex\nfn vsMain(@builtin(vertex_index) vid: u32) -> VsOut {\n  // Fullscreen triangle (covers clip space).\n  // (0,0)->(-1,-1), (2,0)->(3,-1), (0,2)->(-1,3)\n  var pos = array<vec2f, 3>(\n    vec2f(-1.0, -1.0),\n    vec2f(3.0, -1.0),\n    vec2f(-1.0, 3.0)\n  );\n  var out: VsOut;\n  out.position = vec4f(pos[vid], 0.0, 1.0);\n  return out;\n}\n\nfn applyNormalization(count: f32, maxCount: f32, mode: u32) -> f32 {\n  if (maxCount <= 0.0) {\n    return 0.0;\n  }\n  let t = clamp(count / maxCount, 0.0, 1.0);\n  if (mode == 1u) { // sqrt\n    return sqrt(t);\n  }\n  if (mode == 2u) { // log\n    // log1p(count) / log1p(max)\n    return clamp(log(1.0 + count) / max(1e-9, log(1.0 + maxCount)), 0.0, 1.0);\n  }\n  return t; // linear\n}\n\n@fragment\nfn fsMain(@builtin(position) pos: vec4f) -> @location(0) vec4f {\n  // pos.xy is framebuffer pixel coords (device px) with origin top-left.\n  let x = pos.x;\n  let y = pos.y;\n\n  let left = f32(u.plotOriginPx.x);\n  let top = f32(u.plotOriginPx.y);\n  // plot scissor also applied on CPU; keep a guard anyway.\n  if (x < left || y < top) {\n    return vec4f(0.0);\n  }\n\n  let localX = u32((x - left) / f32(u.binSizePx));\n  let localY = u32((y - top) / f32(u.binSizePx));\n  if (localX >= u.binCountX || localY >= u.binCountY) {\n    return vec4f(0.0);\n  }\n\n  let idx = localY * u.binCountX + localX;\n  let c = f32(bins[idx]);\n  let maxC = f32(maxBuf[0]);\n\n  let t = applyNormalization(c, maxC, u.normalization);\n  let lutX = i32(round(t * 255.0));\n  let lut = textureLoad(lutTex, vec2<i32>(lutX, 0), 0);\n  return vec4f(lut.rgb, 1.0);\n}\n\n",tt=e=>Math.min(1,Math.max(0,e)),nt=(e,t,n)=>Math.min(n,Math.max(t,0|e)),it=(e,t,n)=>{const i=e.scale(t),r=e.scale(n);if(!(Number.isFinite(t)&&Number.isFinite(n)&&t!==n&&Number.isFinite(i)&&Number.isFinite(r)))return{a:0,b:Number.isFinite(i)?i:0};const o=(r-i)/(n-t),a=i-o*t;return{a:Number.isFinite(o)?o:0,b:Number.isFinite(a)?a:0}},rt=(e,t,n)=>e+(t-e)*n,ot=(e,t,n)=>[rt(e[0],t[0],n),rt(e[1],t[1],n),rt(e[2],t[2],n),rt(e[3],t[3],n)],at=e=>W(e)??[0,0,0,1],st=e=>"plasma"===e?["#0d0887","#6a00a8","#b12a90","#e16462","#fca636","#f0f921"]:"inferno"===e?["#000004","#420a68","#932667","#dd513a","#fca50a","#fcffa4"]:["#440154","#3b528b","#21918c","#5ec962","#fde725"],lt=new Uint32Array([0]).buffer;function ut(e,t){let n=!1;const i=(null==t?void 0:t.targetFormat)??"bgra8unorm",r=null==t?void 0:t.sampleCount,o=Number.isFinite(r)?Math.max(1,Math.floor(r)):1,a=null==t?void 0:t.pipelineCache,s=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),l=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float"}}]}),u=Ue(e,128,{label:"scatterDensity/computeUniforms"}),c=new ArrayBuffer(128),d=new Float32Array(c,0,20),f=new Uint32Array(c),m=Ue(e,48,{label:"scatterDensity/renderUniforms"}),p=new ArrayBuffer(48),h=new Uint32Array(p),g=Be(e,"struct ComputeUniforms {\n  transform: mat4x4<f32>,\n  viewportPx: vec2f,\n  _pad0: vec2f,\n  plotOriginPx: vec2<u32>,\n  plotSizePx: vec2<u32>,\n  binSizePx: u32,\n  binCountX: u32,\n  binCountY: u32,\n  visibleStart: u32,\n  visibleEnd: u32,\n  normalization: u32,\n  _pad1: vec2<u32>,\n};\n\n@group(0) @binding(0) var<uniform> u: ComputeUniforms;\n@group(0) @binding(1) var<storage, read> points: array<vec2f>;\n@group(0) @binding(2) var<storage, read_write> bins: array<atomic<u32>>;\n\nstruct MaxBuffer {\n  value: atomic<u32>,\n};\n@group(0) @binding(3) var<storage, read_write> maxBuf: MaxBuffer;\n\nfn clipToDevicePx(clip: vec2f) -> vec2f {\n  // clip in [-1,1] -> device pixel in [0, viewport]\n  return vec2f(\n    (clip.x * 0.5 + 0.5) * u.viewportPx.x,\n    (-clip.y * 0.5 + 0.5) * u.viewportPx.y\n  );\n}\n\n@compute @workgroup_size(256)\nfn binPoints(@builtin(global_invocation_id) gid: vec3<u32>) {\n  let idx = u.visibleStart + gid.x;\n  if (idx >= u.visibleEnd) {\n    return;\n  }\n\n  let p = points[idx];\n  let clip4 = u.transform * vec4f(p.x, p.y, 0.0, 1.0);\n  let clip = clip4.xy / max(1e-9, clip4.w);\n  let px = clipToDevicePx(clip);\n\n  // Scissor bounds in device px\n  let left = f32(u.plotOriginPx.x);\n  let top = f32(u.plotOriginPx.y);\n  let right = left + f32(u.plotSizePx.x);\n  let bottom = top + f32(u.plotSizePx.y);\n\n  if (px.x < left || px.x >= right || px.y < top || px.y >= bottom) {\n    return;\n  }\n\n  let localX = u32((px.x - left) / f32(u.binSizePx));\n  let localY = u32((px.y - top) / f32(u.binSizePx));\n  if (localX >= u.binCountX || localY >= u.binCountY) {\n    return;\n  }\n\n  let binIndex = localY * u.binCountX + localX;\n  atomicAdd(&bins[binIndex], 1u);\n}\n\n@compute @workgroup_size(256)\nfn reduceMax(@builtin(global_invocation_id) gid: vec3<u32>) {\n  let binTotal = u.binCountX * u.binCountY;\n  let i = gid.x;\n  if (i >= binTotal) {\n    return;\n  }\n\n  let v = atomicLoad(&bins[i]);\n  atomicMax(&maxBuf.value, v);\n}\n\n","scatterDensityBinning.wgsl",a),b=e.createPipelineLayout({bindGroupLayouts:[s]}),v=De(e,{label:"scatterDensity/binPointsPipeline",layout:b,compute:{module:g,entryPoint:"binPoints"}},a),y=De(e,{label:"scatterDensity/reduceMaxPipeline",layout:b,compute:{module:g,entryPoint:"reduceMax"}},a),x=Te(e,{label:"scatterDensity/renderPipeline",bindGroupLayouts:[l],vertex:{code:et,label:"scatterDensityColormap.wgsl"},fragment:{code:et,label:"scatterDensityColormap.wgsl",formats:i,blend:void 0},primitive:{topology:"triangle-list",cullMode:"none"},multisample:{count:o}},a);let w=null,M=null,F=0,N=null,C=null,S="",A=null,I=null,P=null,R=-1,E=0,B=0,T=0,D=0,U=0,k=null,G=0,z=0,V=2,L=!0,W=!1,O=new Uint32Array(0);const _=()=>{if(n)throw new Error("ScatterDensityRenderer is disposed.")};return{prepare:(t,n,i,r,o,a,g,b,v)=>{_(),W=!0;const y=(e=>{const{canvasWidth:t,canvasHeight:n,devicePixelRatio:i}=e,r=e.left*i,o=t-e.right*i,a=e.top*i,s=n-e.bottom*i,l=nt(Math.floor(r),0,Math.max(0,t)),u=nt(Math.floor(a),0,Math.max(0,n)),c=nt(Math.ceil(o),0,Math.max(0,t)),d=nt(Math.ceil(s),0,Math.max(0,n));return{x:l,y:u,w:Math.max(0,c-l),h:Math.max(0,d-u)}})(b),x=b.devicePixelRatio,Y=Number.isFinite(t.binSize)?Math.max(1e-6,t.binSize):2,$=Math.max(1,Math.round(Y*(Number.isFinite(x)&&x>0?x:1))),X=Math.max(1,Math.ceil(y.w/$)),H=Math.max(1,Math.ceil(y.h/$));((t,n)=>{const i=Math.max(1,0|t)*Math.max(1,0|n);if(w&&M&&i<=F)return;const r=Math.max(1,i);if(F=Math.max(256,(e=>{if(!Number.isFinite(e)||e<=0)return 1;const t=Math.ceil(e);return 2**Math.ceil(Math.log2(t))})(r)),w){try{w.destroy()}catch{}w=null}if(M){try{M.destroy()}catch{}M=null}w=e.createBuffer({label:"scatterDensity/binsBuffer",size:4*F,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),M=e.createBuffer({label:"scatterDensity/maxBuffer",size:4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),O=new Uint32Array(F),A=null,I=null,L=!0})(X,H),(t=>{const n=(e=>{if("string"==typeof e)return e;try{return JSON.stringify(e)}catch{return"custom"}})(t.densityColormap);if(N||(N=e.createTexture({label:"scatterDensity/lutTexture",size:{width:256,height:1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),C=N.createView(),S=""),n===S)return;const i=(e=>{const t=("string"==typeof e?st(e):Array.isArray(e)&&e.length>0?e:st("viridis")).map(at),n=Math.max(2,t.length),i=new Uint8Array(new ArrayBuffer(1024));for(let e=0;e<256;e++){const r=e/255*(n-1),o=Math.min(n-2,Math.max(0,Math.floor(r))),a=r-o,s=ot(t[o],t[o+1],a);i[4*e+0]=nt(Math.round(255*tt(s[0])),0,255),i[4*e+1]=nt(Math.round(255*tt(s[1])),0,255),i[4*e+2]=nt(Math.round(255*tt(s[2])),0,255),i[4*e+3]=nt(Math.round(255*tt(s[3])),0,255)}return i})(t.densityColormap);e.queue.writeTexture({texture:N},i,{bytesPerRow:1024,rowsPerImage:1},{width:256,height:1,depthOrArrayLayers:1}),S=n})(t);const q=(e=>"sqrt"===e?1:"log"===e?2:0)(t.densityNormalization);P!==n&&(P=n,A=null,I=null,L=!0),R!==i&&(R=i,L=!0),(E!==r||B!==o)&&(E=r,B=o,L=!0),(T!==$||D!==X||U!==H)&&(T=$,D=X,U=H,L=!0),(!k||k.x!==y.x||k.y!==y.y||k.w!==y.w||k.h!==y.h)&&(k=y,L=!0),(G!==b.canvasWidth||z!==b.canvasHeight)&&(G=b.canvasWidth,z=b.canvasHeight,L=!0),V!==q&&(V=q,L=!0);const j=v,Z=(null==j?void 0:j.xMin)??0,J=(null==j?void 0:j.xMax)??1,K=(null==j?void 0:j.yMin)??0,Q=(null==j?void 0:j.yMax)??1,{a:ee,b:te}=it(a,Z,J),{a:ne,b:ie}=it(g,K,Q);((e,t,n,i,r)=>{e[0]=t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=n,e[13]=r,e[14]=0,e[15]=1})(d,ee,te,ne,ie),d[16]=b.canvasWidth>0?b.canvasWidth:1,d[17]=b.canvasHeight>0?b.canvasHeight:1,d[18]=0,d[19]=0,f[20]=y.x>>>0,f[21]=y.y>>>0,f[22]=y.w>>>0,f[23]=y.h>>>0,f[24]=$>>>0,f[25]=X>>>0,f[26]=H>>>0,f[27]=(0|Math.max(0,r))>>>0,f[28]=(0|Math.max(0,o))>>>0,f[29]=q>>>0,ke(e,u,c),h[0]=y.x>>>0,h[1]=y.y>>>0,h[2]=y.w>>>0,h[3]=y.h>>>0,h[4]=$>>>0,h[5]=X>>>0,h[6]=H>>>0,h[7]=q>>>0,ke(e,m,p),!w||!M||!C||!P||(A||(A=e.createBindGroup({label:"scatterDensity/computeBindGroup",layout:s,entries:[{binding:0,resource:{buffer:u}},{binding:1,resource:{buffer:P}},{binding:2,resource:{buffer:w}},{binding:3,resource:{buffer:M}}]})),I||(I=e.createBindGroup({label:"scatterDensity/renderBindGroup",layout:l,entries:[{binding:0,resource:{buffer:m}},{binding:1,resource:{buffer:w}},{binding:2,resource:{buffer:M}},{binding:3,resource:C}]})))},encodeCompute:t=>{if(_(),!W||!L)return;if(!w||!M||!A||R<=0)return void(L=!1);if(!k||k.w<=0||k.h<=0)return void(L=!1);e.queue.writeBuffer(w,0,O.buffer,0,4*F),e.queue.writeBuffer(M,0,lt);const n=D*U|0,i=Math.max(0,B-E|0),r=t.beginComputePass({label:"scatterDensity/computePass"});r.setBindGroup(0,A),r.setPipeline(v);const o=Math.ceil(i/256);o>0&&r.dispatchWorkgroups(o),r.setPipeline(y);const a=Math.ceil(n/256);a>0&&r.dispatchWorkgroups(a),r.end(),L=!1},render:e=>{_(),W&&(!I||!k||!C||k.w<=0||k.h<=0||(e.setScissorRect(k.x,k.y,k.w,k.h),e.setPipeline(x),e.setBindGroup(0,I),e.draw(3),G>0&&z>0&&e.setScissorRect(0,0,G,z)))},dispose:()=>{if(!n){n=!0;try{u.destroy()}catch{}try{m.destroy()}catch{}if(w)try{w.destroy()}catch{}if(M)try{M.destroy()}catch{}if(w=null,M=null,F=0,N)try{N.destroy()}catch{}N=null,C=null,A=null,I=null,P=null}}}}const ct="// pie.wgsl\n// Instanced anti-aliased pie-slice shader (instanced quad + SDF mask).\n//\n// - Per-instance vertex input:\n//   - center        = vec2<f32> slice center (transformed by VSUniforms.transform)\n//   - startAngleRad = f32 start angle in radians\n//   - endAngleRad   = f32 end angle in radians\n//   - radiiPx       = vec2<f32>(innerRadiusPx, outerRadiusPx) in *device pixels*\n//   - color         = vec4<f32> RGBA color in [0..1]\n//\n// - Draw call: draw(6, instanceCount) using triangle-list expansion in VS\n//\n// - Uniforms:\n//   - @group(0) @binding(0): VSUniforms { transform, viewportPx }\n//\n// Notes:\n// - The quad is expanded in clip space using `radiusPx` and `viewportPx`.\n// - Fragment uses an SDF mask for the circle boundary + an angular wedge mask.\n// - Fully outside fragments are discarded to avoid unnecessary blending work.\n//\n// Conventions: matches other shaders in this repo (vsMain/fsMain, group 0 bindings,\n// and explicit uniform padding/alignment where needed).\n\nconst PI: f32 = 3.141592653589793;\nconst TAU: f32 = 6.283185307179586; // 2*pi\n\nstruct VSUniforms {\n  transform: mat4x4<f32>,\n  viewportPx: vec2<f32>,\n  // Pad to 16-byte alignment (mat4x4 is 64B; vec2 adds 8B; pad to 80B).\n  _pad0: vec2<f32>,\n};\n\n@group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;\n\nstruct VSIn {\n  @location(0) center: vec2<f32>,\n  @location(1) startAngleRad: f32,\n  @location(2) endAngleRad: f32,\n  @location(3) radiiPx: vec2<f32>, // (innerPx, outerPx)\n  @location(4) color: vec4<f32>,\n};\n\nstruct VSOut {\n  @builtin(position) clipPosition: vec4<f32>,\n  @location(0) localPx: vec2<f32>,\n  @location(1) startAngleRad: f32,\n  @location(2) endAngleRad: f32,\n  @location(3) radiiPx: vec2<f32>,\n  @location(4) color: vec4<f32>,\n};\n\n@vertex\nfn vsMain(in: VSIn, @builtin(vertex_index) vertexIndex: u32) -> VSOut {\n  // Fixed local corners for 2 triangles (triangle-list).\n  // `localNdc` is a quad in [-1, 1]^2; we convert it to pixel offsets via radiusPx.\n  let localNdc = array<vec2<f32>, 6>(\n    vec2<f32>(-1.0, -1.0),\n    vec2<f32>( 1.0, -1.0),\n    vec2<f32>(-1.0,  1.0),\n    vec2<f32>(-1.0,  1.0),\n    vec2<f32>( 1.0, -1.0),\n    vec2<f32>( 1.0,  1.0)\n  );\n\n  let corner = localNdc[vertexIndex];\n  let outerPx = in.radiiPx.y;\n  let localPx = corner * outerPx;\n\n  // Convert pixel offset to clip-space offset.\n  // Clip space spans [-1, 1] across the viewport, so px -> clip is (2 / viewportPx).\n  let localClip = localPx * (2.0 / vsUniforms.viewportPx);\n\n  let centerClip = (vsUniforms.transform * vec4<f32>(in.center, 0.0, 1.0)).xy;\n\n  var out: VSOut;\n  out.clipPosition = vec4<f32>(centerClip + localClip, 0.0, 1.0);\n  out.localPx = localPx;\n  out.startAngleRad = in.startAngleRad;\n  out.endAngleRad = in.endAngleRad;\n  out.radiiPx = in.radiiPx;\n  out.color = in.color;\n  return out;\n}\n\nfn wrapToTau(theta: f32) -> f32 {\n  // Maps theta to [0, TAU). (Input often comes from atan2 in [-PI, PI].)\n  return select(theta, theta + TAU, theta < 0.0);\n}\n\n@fragment\nfn fsMain(in: VSOut) -> @location(0) vec4<f32> {\n  let p = in.localPx;\n  let r = length(p);\n\n  let innerPx = in.radiiPx.x;\n  let outerPx = in.radiiPx.y;\n\n  // --- Radial mask: ring between inner and outer radii (inner==0 => pie) ---\n  // Positive inside the ring, negative outside.\n  let radialDist = min(r - innerPx, outerPx - r);\n  let radialW = fwidth(radialDist);\n  let radialA = smoothstep(-radialW, radialW, radialDist);\n\n  if (radialA <= 0.0) {\n    discard;\n  }\n\n  // Compute fragment angle in [0, TAU).\n  let angle = wrapToTau(atan2(p.y, p.x));\n\n  // --- Angular mask: wedge between start/end angles with wrap ---\n  let start = in.startAngleRad;\n  let end = in.endAngleRad;\n\n  // Compute span in [0, 2π) with wrap.\n  var span = end - start;\n  span = span + select(0.0, TAU, span < 0.0);\n\n  // Compute rel in [0, 2π) with wrap.\n  var rel = angle - start;\n  rel = rel + select(0.0, TAU, rel < 0.0);\n\n  let inside = rel <= span;\n\n  // Signed angular distance (in radians) to nearest boundary.\n  // - Inside: +min(rel, span-rel)\n  // - Outside: -min(rel-span, 2π-rel)\n  let dIn = min(rel, max(span - rel, 0.0));\n  let dOutA = max(rel - span, 0.0);\n  let dOutB = max(TAU - rel, 0.0);\n  let dOut = min(dOutA, dOutB);\n\n  let signedAngleDist = select(-dOut, dIn, inside);\n\n  // Convert to approximate pixel distance to the boundary ray.\n  // (For small angles, perpendicular distance to a ray ≈ r * angle.)\n  let angleDistPx = signedAngleDist * max(r, 1.0);\n\n  let angW = fwidth(angleDistPx);\n  let angularA = smoothstep(-angW, angW, angleDistPx);\n\n  let aOut = radialA * angularA;\n  if (aOut <= 0.0) {\n    discard;\n  }\n\n  return vec4<f32>(in.color.rgb, in.color.a * aOut);\n}\n\n",dt=2*Math.PI,ft=e=>Math.min(1,Math.max(0,e)),mt=(e,t,n)=>Math.min(n,Math.max(t,0|e)),pt=e=>{if(!Number.isFinite(e)||e<=0)return 1;const t=Math.ceil(e);return 2**Math.ceil(Math.log2(t))},ht=e=>{if(!Number.isFinite(e))return 0;const t=e%dt;return t<0?t+dt:t},gt=(e,t)=>{const n=W(e);if(n)return[n[0],n[1],n[2],ft(n[3])];const i=W(t);return i?[i[0],i[1],i[2],ft(i[3])]:[0,0,0,1]},bt=(e,t)=>{if("number"==typeof e)return Number.isFinite(e)?e:null;if("string"!=typeof e)return null;const n=e.trim();if(0===n.length)return null;if(n.endsWith("%")){const e=Number.parseFloat(n.slice(0,-1));return Number.isFinite(e)?e/100*t:null}const i=Number.parseFloat(n);return Number.isFinite(i)?i:null},vt=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);function yt(e,t){let n=!1;const i=(null==t?void 0:t.targetFormat)??"bgra8unorm",r=null==t?void 0:t.sampleCount,o=Number.isFinite(r)?Math.max(1,Math.floor(r)):1,a=null==t?void 0:t.pipelineCache,s=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),l=Ue(e,80,{label:"pieRenderer/vsUniforms"}),u=new ArrayBuffer(80),c=new Float32Array(u),d=e.createBindGroup({layout:s,entries:[{binding:0,resource:{buffer:l}}]}),f=Te(e,{label:"pieRenderer/pipeline",bindGroupLayouts:[s],vertex:{code:ct,label:"pie.wgsl",buffers:[{arrayStride:40,stepMode:"instance",attributes:[{shaderLocation:0,format:"float32x2",offset:0},{shaderLocation:1,format:"float32",offset:8},{shaderLocation:2,format:"float32",offset:12},{shaderLocation:3,format:"float32x2",offset:16},{shaderLocation:4,format:"float32x4",offset:24}]}]},fragment:{code:ct,label:"pie.wgsl",formats:i,blend:{color:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}}},primitive:{topology:"triangle-list",cullMode:"none"},multisample:{count:o}},a);let m=null,p=0,h=new ArrayBuffer(0),g=new Float32Array(h),b=0,v=0,y=null;const x=()=>{if(n)throw new Error("PieRenderer is disposed.")};return{prepare:(t,n)=>{x();const i=n.devicePixelRatio,r=i>0&&Number.isFinite(i)?i:1;b=n.canvasWidth,v=n.canvasHeight,((t,n)=>{const i=Number.isFinite(t)&&t>0?t:1,r=Number.isFinite(n)&&n>0?n:1;c.set(vt,0),c[16]=i,c[17]=r,c[18]=0,c[19]=0,ke(e,l,u)})(n.canvasWidth,n.canvasHeight),y=(e=>{const{canvasWidth:t,canvasHeight:n,devicePixelRatio:i}=e,r=e.left*i,o=t-e.right*i,a=e.top*i,s=n-e.bottom*i,l=mt(Math.floor(r),0,Math.max(0,t)),u=mt(Math.floor(a),0,Math.max(0,n)),c=mt(Math.ceil(o),0,Math.max(0,t)),d=mt(Math.ceil(s),0,Math.max(0,n));return{x:l,y:u,w:Math.max(0,c-l),h:Math.max(0,d-u)}})(n);const o=n.canvasWidth/r,a=n.canvasHeight/r;if(!(o>0&&a>0))return void(p=0);const s=o-n.left-n.right,d=a-n.top-n.bottom;if(!(s>0&&d>0))return void(p=0);const f=.5*Math.min(s,d);if(!(f>0))return void(p=0);const w=((e,t,n)=>{const i=(null==e?void 0:e[0])??"50%",r=(null==e?void 0:e[1])??"50%",o=bt(i,t),a=bt(r,n);return{x:Number.isFinite(o)?o:.5*t,y:Number.isFinite(a)?a:.5*n}})(t.center,s,d),M=(n.left+w.x)/o*2-1,F=1-(n.top+w.y)/a*2;if(!Number.isFinite(M)||!Number.isFinite(F))return void(p=0);const N=((e,t)=>{if(null==e)return{inner:0,outer:.7*t};if((e=>Array.isArray(e))(e)){const n=bt(e[0],t),i=bt(e[1],t),r=Math.max(0,Number.isFinite(n)?n:0),o=Math.max(r,Number.isFinite(i)?i:.7*t);return{inner:r,outer:Math.min(t,o)}}const n=bt(e,t),i=Math.max(0,Number.isFinite(n)?n:.7*t);return{inner:0,outer:Math.min(t,i)}})(t.radius,f),C=Math.max(0,Math.min(N.inner,N.outer)),S=C*r,A=Math.max(C,N.outer)*r;if(!(A>0))return void(p=0);let I=0,P=0;for(let e=0;e<t.data.length;e++){const n=t.data[e],i=null==n?void 0:n.value;"number"==typeof i&&Number.isFinite(i)&&i>0&&!1!==n.visible&&(I+=i,P++)}if(!(I>0)||0===P)return void(p=0);(e=>{if(e<=g.length)return;const t=Math.max(8,pt(e));h=new ArrayBuffer(4*t),g=new Float32Array(h)})(10*P);const R=g,E="number"==typeof t.startAngle&&Number.isFinite(t.startAngle)?t.startAngle:90;let B=ht(E*Math.PI/180),T=0,D=0,U=0;for(let e=0;e<t.data.length;e++){const n=t.data[e],i=null==n?void 0:n.value;if("number"!=typeof i||!Number.isFinite(i)||i<=0||!1===n.visible)continue;U++;let r=i/I*dt;if(r=U===P?Math.max(0,dt-T):Math.max(0,Math.min(dt,r)),T+=r,!(r>0))continue;const o=B,a=1===P?B+dt:ht(B+r);B=ht(B+r);const[s,l,u,c]=gt(n.color,t.color);R[D+0]=M,R[D+1]=F,R[D+2]=o,R[D+3]=a,R[D+4]=S,R[D+5]=A,R[D+6]=s,R[D+7]=l,R[D+8]=u,R[D+9]=c,D+=10}p=D/10;const k=Math.max(4,40*p);if(!m||m.size<k){const t=Math.max(Math.max(4,pt(k)),m?m.size:0);if(m)try{m.destroy()}catch{}m=e.createBuffer({label:"pieRenderer/instanceBuffer",size:t,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST})}m&&p>0&&e.queue.writeBuffer(m,0,h,0,40*p)},render:e=>{x(),m&&0!==p&&(y&&b>0&&v>0&&e.setScissorRect(y.x,y.y,y.w,y.h),e.setPipeline(f),e.setBindGroup(0,d),e.setVertexBuffer(0,m),e.draw(6,p),y&&b>0&&v>0&&e.setScissorRect(0,0,b,v))},dispose:()=>{if(!n){if(n=!0,m)try{m.destroy()}catch{}m=null,p=0;try{l.destroy()}catch{}b=0,v=0,y=null}}}}const xt="// candlestick.wgsl\n// Instanced candlestick shader (bodies + wicks):\n// - Per-instance vertex input:\n//   - xClip, openClip, closeClip, lowClip, highClip, bodyWidthClip (6 floats)\n//   - bodyColor rgba (4 floats)\n// - Draw call: draw(18, instanceCount) using triangle-list expansion in VS\n//   - vertices 0-5: body quad (2 triangles)\n//   - vertices 6-11: upper wick (2 triangles)\n//   - vertices 12-17: lower wick (2 triangles)\n// - Uniforms:\n//   - @group(0) @binding(0): VSUniforms { transform, wickWidthClip }\n\nstruct VSUniforms {\n  transform: mat4x4<f32>,\n  wickWidthClip: f32,\n  _pad0: f32,\n  _pad1: f32,\n  _pad2: f32,\n};\n\n@group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;\n\nstruct VSIn {\n  @location(0) xClip: f32,\n  @location(1) openClip: f32,\n  @location(2) closeClip: f32,\n  @location(3) lowClip: f32,\n  @location(4) highClip: f32,\n  @location(5) bodyWidthClip: f32,\n  @location(6) bodyColor: vec4<f32>,\n};\n\nstruct VSOut {\n  @builtin(position) clipPosition: vec4<f32>,\n  @location(0) color: vec4<f32>,\n};\n\n@vertex\nfn vsMain(in: VSIn, @builtin(vertex_index) vertexIndex: u32) -> VSOut {\n  // Compute body bounds\n  let bodyTop = max(in.openClip, in.closeClip);\n  let bodyBottom = min(in.openClip, in.closeClip);\n  let bodyLeft = in.xClip - in.bodyWidthClip * 0.5;\n  let bodyRight = in.xClip + in.bodyWidthClip * 0.5;\n\n  // Wick bounds\n  let wickLeft = in.xClip - vsUniforms.wickWidthClip * 0.5;\n  let wickRight = in.xClip + vsUniforms.wickWidthClip * 0.5;\n\n  var pos: vec2<f32>;\n\n  if (vertexIndex < 6u) {\n    // Body quad (vertices 0-5)\n    let corners = array<vec2<f32>, 6>(\n      vec2<f32>(0.0, 0.0),\n      vec2<f32>(1.0, 0.0),\n      vec2<f32>(0.0, 1.0),\n      vec2<f32>(0.0, 1.0),\n      vec2<f32>(1.0, 0.0),\n      vec2<f32>(1.0, 1.0)\n    );\n    let corner = corners[vertexIndex];\n    let bodyMin = vec2<f32>(bodyLeft, bodyBottom);\n    let bodyMax = vec2<f32>(bodyRight, bodyTop);\n    pos = bodyMin + corner * (bodyMax - bodyMin);\n  } else if (vertexIndex < 12u) {\n    // Upper wick (vertices 6-11): from bodyTop to highClip\n    let idx = vertexIndex - 6u;\n    let corners = array<vec2<f32>, 6>(\n      vec2<f32>(0.0, 0.0),\n      vec2<f32>(1.0, 0.0),\n      vec2<f32>(0.0, 1.0),\n      vec2<f32>(0.0, 1.0),\n      vec2<f32>(1.0, 0.0),\n      vec2<f32>(1.0, 1.0)\n    );\n    let corner = corners[idx];\n    let wickMin = vec2<f32>(wickLeft, bodyTop);\n    let wickMax = vec2<f32>(wickRight, in.highClip);\n    pos = wickMin + corner * (wickMax - wickMin);\n  } else {\n    // Lower wick (vertices 12-17): from lowClip to bodyBottom\n    let idx = vertexIndex - 12u;\n    let corners = array<vec2<f32>, 6>(\n      vec2<f32>(0.0, 0.0),\n      vec2<f32>(1.0, 0.0),\n      vec2<f32>(0.0, 1.0),\n      vec2<f32>(0.0, 1.0),\n      vec2<f32>(1.0, 0.0),\n      vec2<f32>(1.0, 1.0)\n    );\n    let corner = corners[idx];\n    let wickMin = vec2<f32>(wickLeft, in.lowClip);\n    let wickMax = vec2<f32>(wickRight, bodyBottom);\n    pos = wickMin + corner * (wickMax - wickMin);\n  }\n\n  var out: VSOut;\n  out.clipPosition = vsUniforms.transform * vec4<f32>(pos, 0.0, 1.0);\n  out.color = in.bodyColor;\n  return out;\n}\n\n@fragment\nfn fsMain(in: VSOut) -> @location(0) vec4<f32> {\n  return in.color;\n}\n",wt=10,Mt=(e,t,n)=>Math.min(n,Math.max(t,0|e)),Ft=e=>W(e)??[0,0,0,1],Nt=e=>{if(!Number.isFinite(e)||e<=0)return 1;const t=Math.ceil(e);return 2**Math.ceil(Math.log2(t))},Ct=e=>(e=>Array.isArray(e))(e)?{timestamp:e[0],open:e[1],close:e[2],low:e[3],high:e[4]}:{timestamp:e.timestamp,open:e.open,close:e.close,low:e.low,high:e.high};function St(e,t){let n=!1;const i=(null==t?void 0:t.targetFormat)??"bgra8unorm",r=null==t?void 0:t.sampleCount,o=Number.isFinite(r)?Math.max(1,Math.floor(r)):1,a=null==t?void 0:t.pipelineCache,s=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),l=Ue(e,80,{label:"candlestickRenderer/vsUniforms"});ke(e,l,(()=>{const e=new ArrayBuffer(64);return new Float32Array(e).set([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),e})());const u=new ArrayBuffer(80),c=new Float32Array(u),d=e.createBindGroup({layout:s,entries:[{binding:0,resource:{buffer:l}}]}),f=Te(e,{label:"candlestickRenderer/pipeline",bindGroupLayouts:[s],vertex:{code:xt,label:"candlestick.wgsl",buffers:[{arrayStride:40,stepMode:"instance",attributes:[{shaderLocation:0,format:"float32",offset:0},{shaderLocation:1,format:"float32",offset:4},{shaderLocation:2,format:"float32",offset:8},{shaderLocation:3,format:"float32",offset:12},{shaderLocation:4,format:"float32",offset:16},{shaderLocation:5,format:"float32",offset:20},{shaderLocation:6,format:"float32x4",offset:24}]}]},fragment:{code:xt,label:"candlestick.wgsl",formats:i,blend:{color:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}}},primitive:{topology:"triangle-list",cullMode:"none"},multisample:{count:o}},a);let m=null,p=0,h=new ArrayBuffer(0),g=new Float32Array(h),b=0,v=0,y=null,x=!1,w=null,M=0,F=new ArrayBuffer(0),N=new Float32Array(F);const C=()=>{if(n)throw new Error("CandlestickRenderer is disposed.")};return{prepare:(t,n,i,r,o,a)=>{if(C(),0===n.length)return p=0,void(M=0);const s=(e=>{const t=e.devicePixelRatio;if(!(t>0))return null;const n=e.canvasWidth/t,i=e.canvasHeight/t,r=n-e.left-e.right,o=i-e.top-e.bottom;return r>0&&o>0?{plotWidthCss:r,plotHeightCss:o}:null})(o);if(!s)return p=0,void(M=0);const d=(e=>{const{left:t,right:n,top:i,bottom:r,canvasWidth:o,canvasHeight:a,devicePixelRatio:s}=e,l=t*s/o*2-1,u=(o-n*s)/o*2-1,c=1-i*s/a*2,d=1-(a-r*s)/a*2;return{left:l,right:u,top:c,bottom:d,width:u-l,height:c-d}})(o),f=s.plotWidthCss>0?d.width/s.plotWidthCss:0;b=o.canvasWidth,v=o.canvasHeight,y=(e=>{const{canvasWidth:t,canvasHeight:n,devicePixelRatio:i}=e,r=e.left*i,o=t-e.right*i,a=e.top*i,s=n-e.bottom*i,l=Mt(Math.floor(r),0,Math.max(0,t)),u=Mt(Math.floor(a),0,Math.max(0,n)),c=Mt(Math.ceil(o),0,Math.max(0,t)),d=Mt(Math.ceil(s),0,Math.max(0,n));return{x:l,y:u,w:Math.max(0,c-l),h:Math.max(0,d-u)}})(o);const S=(e=>{const t=[];for(let n=0;n<e.length;n++){const{timestamp:i}=Ct(e[n]);Number.isFinite(i)&&t.push(i)}if(t.length<2)return 1;t.sort((e,t)=>e-t);let n=Number.POSITIVE_INFINITY;for(let e=1;e<t.length;e++){const i=t[e]-t[e-1];i>0&&i<n&&(n=i)}return Number.isFinite(n)&&n>0?n:1})(n),A=((e,t,n,i)=>{if(Number.isFinite(t)&&t>0){const n=e.scale(0),i=e.scale(0+t),r=Math.abs(i-n);if(Number.isFinite(r)&&r>0)return r}const r=Math.abs(n.width);return r>0?r/Math.max(1,Math.floor(i)):0})(i,S,d,n.length);let I=0;const P=t.barWidth;if("number"==typeof P)I=Math.max(0,P)*f;else if("string"==typeof P){const e=(e=>{const t=e.trim().match(/^(\d+(?:\.\d+)?)%$/);if(!t)return null;const n=Number(t[1])/100;return Number.isFinite(n)?n:null})(P);I=null==e?0:A*(e=>Math.min(1,Math.max(0,e)))(e)}const R=t.barMinWidth*f,E=t.barMaxWidth*f;I=Math.min(Math.max(I,R),E);const B=t.itemStyle.borderWidth??1,T=Math.max(0,B)*f;c.set([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,T,0,0,0]),ke(e,l,u);const D=Ft(t.itemStyle.upColor),U=Ft(t.itemStyle.downColor),k=Ft(t.itemStyle.upBorderColor),G=Ft(t.itemStyle.downBorderColor),z=a?Ft(a):[0,0,0,1];x="hollow"===t.style,(e=>{if(e<=g.length)return;const t=Math.max(8,Nt(e));h=new ArrayBuffer(4*t),g=new Float32Array(h)})(n.length*wt);const V=g;let L=0;x&&(e=>{if(e<=N.length)return;const t=Math.max(8,Nt(e));F=new ArrayBuffer(4*t),N=new Float32Array(F)})(n.length*wt);const W=N;let O=0;for(let e=0;e<n.length;e++){const{timestamp:o,open:a,close:s,low:l,high:u}=Ct(n[e]);if(!(Number.isFinite(o)&&Number.isFinite(a)&&Number.isFinite(s)&&Number.isFinite(l)&&Number.isFinite(u)))continue;const c=i.scale(o),d=r.scale(a),m=r.scale(s),p=r.scale(l),h=r.scale(u);if(!(Number.isFinite(c)&&Number.isFinite(d)&&Number.isFinite(m)&&Number.isFinite(p)&&Number.isFinite(h)))continue;const g=s>a;if(x){const e=g?k:G;if(V[L+0]=c,V[L+1]=d,V[L+2]=m,V[L+3]=p,V[L+4]=h,V[L+5]=I,V[L+6]=e[0],V[L+7]=e[1],V[L+8]=e[2],V[L+9]=e[3],L+=wt,g){const e=t.itemStyle.borderWidth*f,n=Math.max(0,I-2*e);W[O+0]=c,W[O+1]=d,W[O+2]=m,W[O+3]=p,W[O+4]=h,W[O+5]=n,W[O+6]=z[0],W[O+7]=z[1],W[O+8]=z[2],W[O+9]=z[3],O+=wt}}else{const e=g?D:U;V[L+0]=c,V[L+1]=d,V[L+2]=m,V[L+3]=p,V[L+4]=h,V[L+5]=I,V[L+6]=e[0],V[L+7]=e[1],V[L+8]=e[2],V[L+9]=e[3],L+=wt}}p=L/wt,M=O/wt;const _=Math.max(4,40*p);if(!m||m.size<_){const t=Math.max(Math.max(4,Nt(_)),m?m.size:0);if(m)try{m.destroy()}catch{}m=e.createBuffer({label:"candlestickRenderer/instanceBuffer",size:t,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST})}if(p>0&&e.queue.writeBuffer(m,0,h,0,40*p),x&&M>0){const t=Math.max(4,40*M);if(!w||w.size<t){const n=Math.max(Math.max(4,Nt(t)),w?w.size:0);if(w)try{w.destroy()}catch{}w=e.createBuffer({label:"candlestickRenderer/hollowInstanceBuffer",size:n,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST})}e.queue.writeBuffer(w,0,F,0,40*M)}},render:e=>{C(),m&&0!==p&&(y&&b>0&&v>0&&e.setScissorRect(y.x,y.y,y.w,y.h),e.setPipeline(f),e.setBindGroup(0,d),e.setVertexBuffer(0,m),e.draw(18,p),x&&w&&M>0&&(e.setVertexBuffer(0,w),e.draw(6,M)),y&&b>0&&v>0&&e.setScissorRect(0,0,b,v))},dispose:()=>{if(!n){if(n=!0,m)try{m.destroy()}catch{}if(m=null,p=0,w)try{w.destroy()}catch{}w=null,M=0;try{l.destroy()}catch{}b=0,v=0,y=null}}}}const At="// bar.wgsl\n// Instanced bar/rect shader:\n// - Per-instance vertex input:\n//   - rect  = vec4<f32>(x, y, width, height) in CLIP space\n//   - color = vec4<f32>(r, g, b, a) in [0..1]\n// - Draw call: draw(6, instanceCount) using triangle-list expansion in VS\n// - Uniforms:\n//   - @group(0) @binding(0): VSUniforms { transform }\n\nstruct VSUniforms {\n  transform: mat4x4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;\n\nstruct VSIn {\n  // rect.xy = origin, rect.zw = size (width, height)\n  @location(0) rect: vec4<f32>,\n  @location(1) color: vec4<f32>,\n};\n\nstruct VSOut {\n  @builtin(position) clipPosition: vec4<f32>,\n  @location(0) color: vec4<f32>,\n};\n\n@vertex\nfn vsMain(in: VSIn, @builtin(vertex_index) vertexIndex: u32) -> VSOut {\n  // Fixed local corners for 2 triangles (triangle-list).\n  let corners = array<vec2<f32>, 6>(\n    vec2<f32>(0.0, 0.0),\n    vec2<f32>(1.0, 0.0),\n    vec2<f32>(0.0, 1.0),\n    vec2<f32>(0.0, 1.0),\n    vec2<f32>(1.0, 0.0),\n    vec2<f32>(1.0, 1.0)\n  );\n\n  // Normalize negative width/height by computing min/max extents.\n  let p0 = in.rect.xy;\n  let p1 = in.rect.xy + in.rect.zw;\n  let rectMin = min(p0, p1);\n  let rectMax = max(p0, p1);\n  let rectSize = rectMax - rectMin;\n\n  let corner = corners[vertexIndex];\n  let pos = rectMin + corner * rectSize;\n\n  var out: VSOut;\n  out.clipPosition = vsUniforms.transform * vec4<f32>(pos, 0.0, 1.0);\n  out.color = in.color;\n  return out;\n}\n\n@fragment\nfn fsMain(in: VSOut) -> @location(0) vec4<f32> {\n  return in.color;\n}\n\n",It=e=>Math.min(1,Math.max(0,e)),Pt=e=>W(e)??[0,0,0,1],Rt=e=>{if(!Number.isFinite(e)||e<=0)return 1;const t=Math.ceil(e);return 2**Math.ceil(Math.log2(t))},Et=e=>{if("string"!=typeof e)return"";const t=e.trim();return t.length>0?t:""};const Bt="\nstruct VSOut { @builtin(position) pos: vec4f };\n\n@vertex\nfn vsMain(@builtin(vertex_index) i: u32) -> VSOut {\n  var positions = array<vec2f, 3>(\n    vec2f(-1.0, -1.0),\n    vec2f( 3.0, -1.0),\n    vec2f(-1.0,  3.0)\n  );\n  var o: VSOut;\n  o.pos = vec4f(positions[i], 0.0, 1.0);\n  return o;\n}\n\n// Using textureLoad (no filtering) for pixel-exact blit into the MSAA overlay pass.\n@group(0) @binding(0) var srcTex: texture_2d<f32>;\n\n@fragment\nfn fsMain(@builtin(position) pos: vec4f) -> @location(0) vec4f {\n  let xy = vec2<i32>(pos.xy);\n  return textureLoad(srcTex, xy, 0);\n}\n";function Tt(e){if(e)try{e.destroy()}catch{}}const Dt="// crosshair.wgsl\n// Minimal crosshair line shader:\n// - Vertex input: vec2<f32> position in clip-space coordinates\n// - VS uniform: transform mat4 (identity)\n// - FS uniform: solid RGBA color\n\nstruct VSUniforms {\n  transform: mat4x4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;\n\nstruct FSUniforms {\n  color: vec4<f32>,\n};\n\n@group(0) @binding(1) var<uniform> fsUniforms: FSUniforms;\n\nstruct VSIn {\n  @location(0) position: vec2<f32>,\n};\n\nstruct VSOut {\n  @builtin(position) clipPosition: vec4<f32>,\n};\n\n@vertex\nfn vsMain(in: VSIn) -> VSOut {\n  var out: VSOut;\n  out.clipPosition = vsUniforms.transform * vec4<f32>(in.position, 0.0, 1.0);\n  return out;\n}\n\n@fragment\nfn fsMain() -> @location(0) vec4<f32> {\n  return fsUniforms.color;\n}\n\n";const Ut=[1,1,1,.8],kt=(e,t,n)=>Math.min(n,Math.max(t,0|e)),Gt=(e,t)=>e/t*2-1,zt=(e,t)=>1-e/t*2,Vt=(e,t)=>{e.push(t[0],t[1],t[2],t[3])},Lt=(e,t)=>{if(!Number.isFinite(e)||!Number.isFinite(t))return[];const n=Math.min(e,t),i=Math.max(e,t);if(i<=n)return[];if(!Number.isFinite(10))return[];const r=Math.ceil((i-n)/10);if(!Number.isFinite(r)||r<=0)return[];const o=[];let a=n;for(;a<i;){const e=a,t=Math.min(a+6,i);t>e&&o.push([e,t]),a+=10}return o};function Wt(e,t){let n=!1,i=!0;const r=(null==t?void 0:t.targetFormat)??"bgra8unorm",o=(null==t?void 0:t.sampleCount)??1,a=Number.isFinite(o)?Math.max(1,Math.floor(o)):1,s=null==t?void 0:t.pipelineCache,l=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),u=Ue(e,64,{label:"crosshairRenderer/vsUniforms"}),c=Ue(e,16,{label:"crosshairRenderer/fsUniforms"}),d=e.createBindGroup({layout:l,entries:[{binding:0,resource:{buffer:u}},{binding:1,resource:{buffer:c}}]}),f=Te(e,{label:"crosshairRenderer/pipeline",bindGroupLayouts:[l],vertex:{code:Dt,label:"crosshair.wgsl",buffers:[{arrayStride:8,stepMode:"vertex",attributes:[{shaderLocation:0,format:"float32x2",offset:0}]}]},fragment:{code:Dt,label:"crosshair.wgsl",formats:r,blend:{color:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}}},primitive:{topology:"line-list",cullMode:"none"},multisample:{count:a}},s),m=function(e,t){if(!Number.isFinite(t)||t<=0)throw new Error(`createStreamBuffer(maxSize): maxSize (bytes) must be a positive number. Received: ${String(t)}`);const n=(e=>e+3&-4)(Math.max(4,Math.floor(t))),i=e.limits.maxBufferSize;if(n>i)throw new Error(`createStreamBuffer(maxSize): requested size ${n} bytes exceeds device.limits.maxBufferSize (${i}).`);const r=n>>>2,o=t=>({buffer:e.createBuffer({label:t,size:n,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),mirror:new Uint32Array(r)}),a=[o("streamBuffer/a"),o("streamBuffer/b")];let s=!1,l=0,u=0;const c=()=>{if(s)throw new Error("createStreamBuffer: StreamBuffer is disposed.")},d=(t,n,i)=>{const r=a[t],o=r.mirror;if(i<0||i>n.length)throw new Error("createStreamBuffer.write: internal error (invalid usedWords).");if(0===i)return;const s=i<<2;e.queue.writeBuffer(r.buffer,0,n.buffer,n.byteOffset,s),o.set(n.subarray(0,i),0)};return{write:t=>{if(c(),1&t.length)throw new Error("createStreamBuffer.write: data length must be even (vec2<f32> vertices).");const i=t.byteLength;if(i>n)throw new Error(`createStreamBuffer.write: data.byteLength (${i}) exceeds capacity (${n}). Increase maxSize.`);const r=t.length>>>1;if(0===i)return void(u=r);const o=(e=>{if(3&e.byteOffset)throw new Error("createStreamBuffer.write: data.byteOffset must be 4-byte aligned.");return new Uint32Array(e.buffer,e.byteOffset,e.byteLength>>>2)})(t),s=1-l;((t,n,i)=>{const r=a[t],o=r.mirror;if(i<0||i>n.length)throw new Error("createStreamBuffer.write: internal error (invalid usedWords).");const s=i<<2;if(s>0&&s<=1024)return void d(t,n,i);const l=[];let u=0,c=0,f=0;for(;f<i;){for(;f<i&&o[f]===n[f];)f++;if(f>=i)break;const e=f;for(f++;f<i&&o[f]!==n[f];)f++;const r=f;if(l.push([e,r]),u++,c+=r-e,u>128||c>16384)return void d(t,n,i)}for(let t=0;t<l.length;t++){const[i,a]=l[t],s=i<<2,u=a-i<<2;e.queue.writeBuffer(r.buffer,s,n.buffer,n.byteOffset+s,u),o.set(n.subarray(i,a),i)}})(s,o,o.length),l=s,u=r},getBuffer:()=>(c(),a[l].buffer),getVertexCount:()=>(c(),u),dispose:()=>{if(!s){s=!0,u=0;for(const e of a)try{e.buffer.destroy()}catch{}}}}}(e,65536);let p=0,h=0,g=0,b={x:0,y:0,w:0,h:0};const v=()=>{if(n)throw new Error("CrosshairRenderer is disposed.")};return{prepare:(t,n,i,r)=>{if(v(),"boolean"!=typeof r.showX||"boolean"!=typeof r.showY)throw new Error("CrosshairRenderer.prepare: showX/showY must be boolean.");if("string"!=typeof r.color)throw new Error("CrosshairRenderer.prepare: color must be a string.");if(!Number.isFinite(r.lineWidth)||r.lineWidth<0)throw new Error("CrosshairRenderer.prepare: lineWidth must be a finite non-negative number.");const{vertices:o,scissor:a}=((e,t,n,i)=>{if(!Number.isFinite(e)||!Number.isFinite(t))throw new Error("CrosshairRenderer.prepare: x and y must be finite numbers.");if(!(e=>Number.isFinite(e.left)&&Number.isFinite(e.right)&&Number.isFinite(e.top)&&Number.isFinite(e.bottom)&&Number.isFinite(e.canvasWidth)&&Number.isFinite(e.canvasHeight))(n))throw new Error("CrosshairRenderer.prepare: gridArea dimensions must be finite numbers.");if(n.canvasWidth<=0||n.canvasHeight<=0)throw new Error("CrosshairRenderer.prepare: canvas dimensions must be positive.");if(n.left<0||n.right<0||n.top<0||n.bottom<0)throw new Error("CrosshairRenderer.prepare: gridArea margins must be non-negative.");const{canvasWidth:r,canvasHeight:o}=n,a=Number.isFinite(n.devicePixelRatio)&&n.devicePixelRatio>0?n.devicePixelRatio:1,s=n.left*a,l=r-n.right*a,u=n.top*a,c=o-n.bottom*a,d=kt(Math.floor(s),0,Math.max(0,r)),f=kt(Math.floor(u),0,Math.max(0,o)),m=kt(Math.ceil(l),0,Math.max(0,r)),p=kt(Math.ceil(c),0,Math.max(0,o)),h=Math.max(0,m-d),g=Math.max(0,p-f),b=e*a,v=t*a,y=((e,t)=>{if(!Number.isFinite(e)||e<0)throw new Error("CrosshairRenderer.prepare: lineWidth must be a finite non-negative number.");if(0===e)return[];const n=e*t,i=Math.max(1,Math.min(8,Math.round(n))),r=(i-1)/2,o=[];for(let e=0;e<i;e++)o.push(e-r);return o})(i.lineWidth,a);if(0===y.length||!i.showX&&!i.showY)return{vertices:new Float32Array(0),scissor:{x:d,y:f,w:h,h:g}};const x=[],w=i.showX?Lt(u,c):[],M=i.showY?Lt(s,l):[],F=((i.showX?w.length:0)+(i.showY?M.length:0))*y.length*2,N=F>0&&F<=8192,C=e=>{const t=Gt(e,r),n=zt(u,o),i=zt(c,o);Vt(x,[t,n,t,i])},S=e=>{const t=zt(e,o),n=Gt(s,r),i=Gt(l,r);Vt(x,[n,t,i,t])};if(i.showX)for(let e=0;e<y.length;e++){const t=b+y[e];if(!N){C(t);continue}const n=Gt(t,r);for(let e=0;e<w.length;e++){const[t,i]=w[e],r=zt(t,o),a=zt(i,o);Vt(x,[n,r,n,a])}}if(i.showY)for(let e=0;e<y.length;e++){const t=v+y[e];if(!N){S(t);continue}const n=zt(t,o);for(let e=0;e<M.length;e++){const[t,i]=M[e],o=Gt(t,r),a=Gt(i,r);Vt(x,[o,n,a,n])}}return{vertices:new Float32Array(x),scissor:{x:d,y:f,w:h,h:g}}})(t,n,i,r);0===o.byteLength?p=0:(m.write(o),p=m.getVertexCount()),ke(e,u,(()=>{const e=new ArrayBuffer(64);return new Float32Array(e).set([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),e})());const s=W(r.color)??Ut,l=new ArrayBuffer(16);new Float32Array(l).set([s[0],s[1],s[2],s[3]]),ke(e,c,l),h=i.canvasWidth,g=i.canvasHeight,b=a},render:e=>{v(),i&&0!==p&&(h<=0||g<=0||(e.setScissorRect(b.x,b.y,b.w,b.h),e.setPipeline(f),e.setBindGroup(0,d),e.setVertexBuffer(0,m.getBuffer()),e.draw(p),e.setScissorRect(0,0,h,g)))},setVisible:e=>{v(),i=!!e},dispose:()=>{if(!n){n=!0;try{u.destroy()}catch{}try{c.destroy()}catch{}m.dispose(),p=0,h=0,g=0,b={x:0,y:0,w:0,h:0}}}}}const Ot="// highlight.wgsl\n// Draws an anti-aliased ring highlight around a point.\n//\n// Contract:\n// - `@builtin(position)` in the fragment stage is framebuffer-space pixels.\n// - The renderer supplies `center` and ring sizes in *device pixels*.\n\nstruct Uniforms {\n  center: vec2<f32>,\n  radius: f32,\n  thickness: f32,\n  color: vec4<f32>,\n  outlineColor: vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> u: Uniforms;\n\nstruct VSOut {\n  @builtin(position) position: vec4<f32>,\n};\n\n@vertex\nfn vsMain(@builtin(vertex_index) vertexIndex: u32) -> VSOut {\n  // Fullscreen triangle.\n  // Covers clip-space [-1,1] with 3 verts: (-1,-1), (3,-1), (-1,3)\n  let positions = array<vec2<f32>, 3>(\n    vec2<f32>(-1.0, -1.0),\n    vec2<f32>(3.0, -1.0),\n    vec2<f32>(-1.0, 3.0)\n  );\n\n  var out: VSOut;\n  out.position = vec4<f32>(positions[vertexIndex], 0.0, 1.0);\n  return out;\n}\n\nfn ringCoverage(distancePx: f32, radiusPx: f32, thicknessPx: f32) -> f32 {\n  let aa = 1.0; // ~1px antialias band (device pixels)\n  let halfT = max(0.5, thicknessPx * 0.5);\n  let a0 = smoothstep(radiusPx - halfT - aa, radiusPx - halfT + aa, distancePx);\n  let a1 = smoothstep(radiusPx + halfT - aa, radiusPx + halfT + aa, distancePx);\n  return clamp(a0 - a1, 0.0, 1.0);\n}\n\n@fragment\nfn fsMain(@builtin(position) fragPos: vec4<f32>) -> @location(0) vec4<f32> {\n  let d = distance(fragPos.xy, u.center);\n\n  let ring = ringCoverage(d, u.radius, u.thickness);\n  let outline = ringCoverage(d, u.radius, u.thickness + 2.0);\n\n  let cover = max(ring, outline);\n  if (cover <= 0.0) {\n    discard;\n  }\n\n  // Blend between outline and ring color based on relative coverage,\n  // then apply total coverage as alpha.\n  let t = clamp(select(0.0, ring / cover, cover > 0.0), 0.0, 1.0);\n  let rgb = mix(u.outlineColor.rgb, u.color.rgb, t);\n  let a = mix(u.outlineColor.a, u.color.a, t) * cover;\n  return vec4<f32>(rgb, a);\n}\n\n",_t=[1,1,1,1],Yt=e=>Math.min(1,Math.max(0,e)),$t=(e,t,n)=>Math.min(n,Math.max(t,0|e));const Xt='// Reference line renderer (axis-aligned, instanced quads).\n//\n// Coordinate conventions:\n// - Instance position is provided in CANVAS-LOCAL CSS pixels (same coordinate space as pointer events).\n// - Plot rect is provided in DEVICE pixels (computed from grid margins + DPR).\n// - Line width and dash lengths are provided in CSS pixels and converted in-shader using DPR.\n//\n// Scissoring/clipping:\n// - The render coordinator is expected to set a scissor rect for the plot area before drawing.\n// - This shader simply draws full-height/full-width quads; clipping is handled by scissor.\n//\n// Dash semantics:\n// - lineDash is a repeating on/off sequence in CSS pixels, starting with "on" at t=0.\n// - Up to 8 dash entries are supported per line (truncated on CPU).\n//\n// Performance:\n// - Vertex stage expands each instance into a quad (2 triangles, 6 vertices).\n// - We intentionally avoid snapping to integer device pixels to prevent visible stepping/jiggle\n//   while zooming; edge AA is handled in the fragment stage.\n\nstruct VSUniforms {\n  canvasSize : vec2<f32>,     // device pixels (canvas.width, canvas.height)\n  plotOrigin : vec2<f32>,     // device pixels (plotLeft, plotTop)\n  plotSize : vec2<f32>,       // device pixels (plotWidth, plotHeight)\n  devicePixelRatio : f32,\n  _pad0 : f32,\n};\n\n@group(0) @binding(0) var<uniform> u : VSUniforms;\n\nstruct VSIn {\n  // axisPos.x = axis (0 = vertical, 1 = horizontal)\n  // axisPos.y = position in CANVAS-LOCAL CSS pixels (x for vertical, y for horizontal)\n  @location(0) axisPos : vec2<f32>,\n\n  // widthDashCount.x = lineWidth in CSS px\n  // widthDashCount.y = dashCount (float, cast to u32)\n  @location(1) widthDashCount : vec2<f32>,\n\n  // dashMeta.x = dashTotal (CSS px)\n  // dashMeta.y = reserved (unused)\n  @location(2) dashMeta : vec2<f32>,\n\n  @location(3) dash0_3 : vec4<f32>,\n  @location(4) dash4_7 : vec4<f32>,\n\n  // Premultiplied or straight alpha is fine; blending is handled by pipeline state.\n  @location(5) color : vec4<f32>,\n};\n\nstruct VSOut {\n  @builtin(position) position : vec4<f32>,\n\n  // Distance along the line in CSS pixels (0..plotLengthCss).\n  @location(0) alongCss : f32,\n\n  // Packed dash metadata to avoid extra varyings.\n  // dashInfo.x = dashCount (float, cast to u32)\n  // dashInfo.y = dashTotal (CSS px)\n  @location(1) @interpolate(flat) dashInfo : vec2<f32>,\n\n  @location(2) @interpolate(flat) dash0_3 : vec4<f32>,\n  @location(3) @interpolate(flat) dash4_7 : vec4<f32>,\n  @location(4) @interpolate(flat) color : vec4<f32>,\n\n  // Axis-aligned quad anti-aliasing (device pixels).\n  // acrossDevice ranges [0..widthDevice] across the stroke thickness.\n  @location(5) acrossDevice : f32,\n  @location(6) @interpolate(flat) widthDevice : f32,\n};\n\nfn quadUv(vid : u32) -> vec2<f32> {\n  // Two triangles covering [0,1]x[0,1].\n  // 0: (0,0) 1:(1,0) 2:(0,1) 3:(0,1) 4:(1,0) 5:(1,1)\n  switch (vid) {\n    case 0u: { return vec2<f32>(0.0, 0.0); }\n    case 1u: { return vec2<f32>(1.0, 0.0); }\n    case 2u: { return vec2<f32>(0.0, 1.0); }\n    case 3u: { return vec2<f32>(0.0, 1.0); }\n    case 4u: { return vec2<f32>(1.0, 0.0); }\n    default: { return vec2<f32>(1.0, 1.0); }\n  }\n}\n\n@vertex\nfn vsMain(in : VSIn, @builtin(vertex_index) vid : u32) -> VSOut {\n  let uv = quadUv(vid);\n  let dpr = max(1e-6, u.devicePixelRatio);\n  // IMPORTANT: Do NOT snap reference lines to integer device pixels.\n  // Snapping looks crisp at rest but causes visible "jiggle" / stepping while zooming because\n  // the line position is continuously changing (data-space → screen-space), and rounding\n  // quantizes that motion to adjacent pixels. We rely on analytic AA in the fragment stage\n  // to keep strokes stable and reasonably crisp across DPRs.\n\n  let axis = in.axisPos.x;\n  let posCss = in.axisPos.y;\n  let widthCss = max(0.0, in.widthDashCount.x);\n  let widthDevice = max(1.0, widthCss * dpr);\n\n  var xDevice : f32;\n  var yDevice : f32;\n  var alongCss : f32;\n  var acrossDevice : f32;\n\n  if (axis < 0.5) {\n    // Vertical line at x = posCss (canvas-local CSS px), spanning plot height.\n    let centerX = posCss * dpr;\n    let startX = centerX - 0.5 * widthDevice;\n    xDevice = startX + uv.x * widthDevice;\n    yDevice = u.plotOrigin.y + uv.y * u.plotSize.y;\n    alongCss = (uv.y * u.plotSize.y) / dpr;\n    acrossDevice = uv.x * widthDevice;\n  } else {\n    // Horizontal line at y = posCss (canvas-local CSS px), spanning plot width.\n    let centerY = posCss * dpr;\n    let startY = centerY - 0.5 * widthDevice;\n    xDevice = u.plotOrigin.x + uv.x * u.plotSize.x;\n    yDevice = startY + uv.y * widthDevice;\n    alongCss = (uv.x * u.plotSize.x) / dpr;\n    acrossDevice = uv.y * widthDevice;\n  }\n\n  let clipX = (xDevice / u.canvasSize.x) * 2.0 - 1.0;\n  let clipY = 1.0 - (yDevice / u.canvasSize.y) * 2.0;\n\n  var out : VSOut;\n  out.position = vec4<f32>(clipX, clipY, 0.0, 1.0);\n  out.alongCss = alongCss;\n  out.dashInfo = vec2<f32>(in.widthDashCount.y, in.dashMeta.x);\n  out.dash0_3 = in.dash0_3;\n  out.dash4_7 = in.dash4_7;\n  out.color = in.color;\n  out.acrossDevice = acrossDevice;\n  out.widthDevice = widthDevice;\n  return out;\n}\n\nfn dashValue(i : u32, d0 : vec4<f32>, d1 : vec4<f32>) -> f32 {\n  switch (i) {\n    case 0u: { return d0.x; }\n    case 1u: { return d0.y; }\n    case 2u: { return d0.z; }\n    case 3u: { return d0.w; }\n    case 4u: { return d1.x; }\n    case 5u: { return d1.y; }\n    case 6u: { return d1.z; }\n    default: { return d1.w; }\n  }\n}\n\n@fragment\nfn fsMain(in : VSOut) -> @location(0) vec4<f32> {\n  // Analytic edge anti-aliasing for axis-aligned quads (reduces shimmering during zoom).\n  // This is a lightweight alternative to full MSAA for thin strokes.\n  let edgeDist = min(in.acrossDevice, in.widthDevice - in.acrossDevice);\n  // Slightly widen AA to reduce temporal shimmer on moving 1-2px strokes.\n  // Keep conservative so lines remain reasonably crisp.\n  let aa = max(fwidth(in.acrossDevice), 1e-3) * 1.25;\n  let edgeCoverage = smoothstep(0.0, aa, edgeDist);\n  var color = in.color;\n  color.a = color.a * edgeCoverage;\n\n  let dashCount = u32(round(in.dashInfo.x));\n  let dashTotal = in.dashInfo.y;\n\n  // IMPORTANT: derivative ops (fwidth) must execute in uniform control flow.\n  // So compute the dash parameterization unconditionally (using a safe total) BEFORE any early-return.\n  let dashTotalSafe = max(dashTotal, 1.0);\n  let t = in.alongCss - floor(in.alongCss / dashTotalSafe) * dashTotalSafe;\n  // Anti-alias dash edges along the line axis (CSS pixels).\n  // This reduces shimmer during zoom for dashed reference lines without requiring MSAA.\n  let dashAa = max(fwidth(t), 1e-3);\n\n  // Solid line (no dash pattern).\n  if (dashCount == 0u || dashTotal <= 0.0) {\n    return color;\n  }\n\n  var acc = 0.0;\n  var on = true;\n\n  for (var i : u32 = 0u; i < 8u; i = i + 1u) {\n    if (i >= dashCount) { break; }\n    let seg = dashValue(i, in.dash0_3, in.dash4_7);\n    if (seg <= 0.0) { continue; }\n\n    if (t < acc + seg) {\n      // IMPORTANT: Avoid `discard` for off segments.\n      // Discard can cause temporal popping on moving dashed edges; prefer a smooth alpha mask.\n      //\n      // Fade in/out near dash boundaries for smooth edges. This produces coverage in [0..1]\n      // within the current segment, going to 0 at segment boundaries.\n      let inFromStart = smoothstep(0.0, dashAa, t - acc);\n      let inFromEnd = smoothstep(0.0, dashAa, (acc + seg) - t);\n      let segCoverage = min(inFromStart, inFromEnd);\n\n      // On segments contribute alpha; off segments contribute 0 alpha (no discard).\n      let dashMask = select(0.0, segCoverage, on);\n      color.a = color.a * dashMask;\n      return color;\n    }\n\n    acc = acc + seg;\n    on = !on;\n  }\n\n  // Defensive fallback if the dash list is degenerate.\n  // If we didn\'t find a segment (shouldn\'t happen), default to transparent (safer than solid).\n  color.a = 0.0;\n  return color;\n}\n',Ht=e=>{if(!e||0===e.length)return{dashCount:0,dashTotal:0,values:new Array(8).fill(0)};const t=[];for(let n=0;n<e.length;n++){const i=e[n];"number"==typeof i&&Number.isFinite(i)&&i>0&&t.push(i)}if(0===t.length)return{dashCount:0,dashTotal:0,values:new Array(8).fill(0)};const n=t.length%2==1?t.concat(t):t,i=Math.min(8,n.length),r=new Array(8).fill(0);let o=0;for(let e=0;e<i;e++)r[e]=n[e],o+=n[e];return!Number.isFinite(o)||o<=0?{dashCount:0,dashTotal:0,values:new Array(8).fill(0)}:{dashCount:i,dashTotal:o,values:r}};function qt(e,t){let n=!1;const i=(null==t?void 0:t.targetFormat)??"bgra8unorm",r=(null==t?void 0:t.sampleCount)??1,o=Number.isFinite(r)?Math.max(1,Math.floor(r)):1,a=null==t?void 0:t.pipelineCache,s=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),l=Ue(e,32,{label:"referenceLineRenderer/vsUniforms"}),u=e.createBindGroup({layout:s,entries:[{binding:0,resource:{buffer:l}}]}),c=Te(e,{label:"referenceLineRenderer/pipeline",bindGroupLayouts:[s],vertex:{code:Xt,label:"referenceLine.wgsl",buffers:[{arrayStride:72,stepMode:"instance",attributes:[{shaderLocation:0,format:"float32x2",offset:0},{shaderLocation:1,format:"float32x2",offset:8},{shaderLocation:2,format:"float32x2",offset:16},{shaderLocation:3,format:"float32x4",offset:24},{shaderLocation:4,format:"float32x4",offset:40},{shaderLocation:5,format:"float32x4",offset:56}]}]},fragment:{code:Xt,label:"referenceLine.wgsl",formats:i,blend:{color:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}}},primitive:{topology:"triangle-list",cullMode:"none"},multisample:{count:o}},a);let d=null,f=0,m=0;const p=()=>{if(n)throw new Error("ReferenceLineRenderer is disposed.")};return{prepare:(t,n)=>{if(p(),!Array.isArray(n))throw new Error("ReferenceLineRenderer.prepare: lines must be an array.");if(!(e=>Number.isFinite(e.left)&&Number.isFinite(e.right)&&Number.isFinite(e.top)&&Number.isFinite(e.bottom)&&Number.isFinite(e.canvasWidth)&&Number.isFinite(e.canvasHeight))(t))throw new Error("ReferenceLineRenderer.prepare: gridArea dimensions must be finite numbers.");if(t.canvasWidth<=0||t.canvasHeight<=0)throw new Error("ReferenceLineRenderer.prepare: canvas dimensions must be positive.");if(t.left<0||t.right<0||t.top<0||t.bottom<0)throw new Error("ReferenceLineRenderer.prepare: gridArea margins must be non-negative.");const i=Number.isFinite(t.devicePixelRatio)&&t.devicePixelRatio>0?t.devicePixelRatio:1,r=t.left*i,o=t.top*i,a=t.canvasWidth-t.right*i-r,s=t.canvasHeight-t.bottom*i-o;if(!(a>0&&s>0))return void(m=0);const u=new Float32Array(8);if(u[0]=t.canvasWidth,u[1]=t.canvasHeight,u[2]=r,u[3]=o,u[4]=a,u[5]=s,u[6]=i,u[7]=0,ke(e,l,u),0===n.length)return void(m=0);if(!d||f<n.length){const t=Math.max(1,Math.ceil(1.5*n.length)),i=Math.max(4,72*t);if(d)try{d.destroy()}catch{}d=e.createBuffer({label:"referenceLineRenderer/instanceBuffer",size:i,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),f=t}const c=new Float32Array(18*n.length);for(let e=0;e<n.length;e++){const t=n[e],i=18*e;if("vertical"!==t.axis&&"horizontal"!==t.axis)throw new Error("ReferenceLineRenderer.prepare: line.axis must be 'vertical' or 'horizontal'.");if(!Number.isFinite(t.positionCssPx))throw new Error("ReferenceLineRenderer.prepare: line.positionCssPx must be a finite number.");if(!Number.isFinite(t.lineWidth)||t.lineWidth<0)throw new Error("ReferenceLineRenderer.prepare: line.lineWidth must be a finite non-negative number.");const r=t.rgba;if(!Array.isArray(r)||4!==r.length)throw new Error("ReferenceLineRenderer.prepare: line.rgba must be a tuple [r,g,b,a].");const o=Ht(t.lineDash);c[i+0]="vertical"===t.axis?0:1,c[i+1]=t.positionCssPx,c[i+2]=t.lineWidth,c[i+3]=o.dashCount,c[i+4]=o.dashTotal,c[i+5]=0;for(let e=0;e<8;e++)c[i+6+e]=o.values[e];c[i+14]=r[0],c[i+15]=r[1],c[i+16]=r[2],c[i+17]=r[3]}e.queue.writeBuffer(d,0,c.buffer,c.byteOffset,c.byteLength),m=n.length},render:(e,t=0,n)=>{if(p(),0===m||!d)return;const i=Number.isFinite(t)?Math.max(0,Math.floor(t)):0,r=Math.max(0,m-i),o=null==n?r:Number.isFinite(n)?Math.max(0,Math.min(r,Math.floor(n))):r;0!==o&&(e.setPipeline(c),e.setBindGroup(0,u),e.setVertexBuffer(0,d),e.draw(6,o,0,i))},dispose:()=>{if(!n){n=!0;try{l.destroy()}catch{}if(d)try{d.destroy()}catch{}d=null,f=0,m=0}}}}const jt="// annotationMarker.wgsl\n// Instanced annotation marker shader (circle SDF with optional stroke).\n//\n// Coordinate contract:\n// - Instance center is CANVAS-LOCAL CSS pixels (xCssPx, yCssPx)\n// - Instance size is diameter in CSS pixels (sizeCssPx)\n// - Uniform provides render target size in *device* pixels and DPR for CSS→device conversion.\n//\n// Draw call: draw(6, instanceCount) using triangle-list quad expansion in VS.\n\nstruct VSUniforms {\n  viewportPx: vec2<f32>, // render target size in device pixels (width, height)\n  dpr: f32,              // device pixel ratio (CSS px -> device px)\n  _pad0: f32,\n};\n\n@group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;\n\nstruct VSIn {\n  // Center in CANVAS-LOCAL CSS pixels.\n  @location(0) centerCssPx: vec2<f32>,\n  // Marker diameter in CSS pixels.\n  @location(1) sizeCssPx: f32,\n  // Stroke width in CSS pixels (0 disables stroke).\n  @location(2) strokeWidthCssPx: f32,\n  // Colors are straight-alpha RGBA in 0..1.\n  @location(3) fillRgba: vec4<f32>,\n  @location(4) strokeRgba: vec4<f32>,\n};\n\nstruct VSOut {\n  @builtin(position) clipPosition: vec4<f32>,\n  // Local quad coordinates in [-1, 1]^2 (used for circle SDF).\n  @location(0) local: vec2<f32>,\n  // Half-size in device pixels (radius in screen space).\n  @location(1) halfSizePx: f32,\n  @location(2) strokeWidthPx: f32,\n  @location(3) fillRgba: vec4<f32>,\n  @location(4) strokeRgba: vec4<f32>,\n};\n\n@vertex\nfn vsMain(in: VSIn, @builtin(vertex_index) vertexIndex: u32) -> VSOut {\n  // Fixed local corners for 2 triangles (triangle-list).\n  let localCorners = array<vec2<f32>, 6>(\n    vec2<f32>(-1.0, -1.0),\n    vec2<f32>( 1.0, -1.0),\n    vec2<f32>(-1.0,  1.0),\n    vec2<f32>(-1.0,  1.0),\n    vec2<f32>( 1.0, -1.0),\n    vec2<f32>( 1.0,  1.0)\n  );\n\n  let corner = localCorners[vertexIndex];\n\n  let dpr = select(1.0, vsUniforms.dpr, vsUniforms.dpr > 0.0);\n  let centerPx = in.centerCssPx * dpr;\n  let halfSizePx = 0.5 * max(0.0, in.sizeCssPx) * dpr;\n  let strokeWidthPx = max(0.0, in.strokeWidthCssPx) * dpr;\n\n  let posPx = centerPx + corner * halfSizePx;\n\n  // Convert device pixels to clip-space with origin at top-left:\n  // x: [0..w] -> [-1..1], y: [0..h] -> [1..-1]\n  let clipX = (posPx.x / vsUniforms.viewportPx.x) * 2.0 - 1.0;\n  let clipY = 1.0 - (posPx.y / vsUniforms.viewportPx.y) * 2.0;\n\n  var out: VSOut;\n  out.clipPosition = vec4<f32>(clipX, clipY, 0.0, 1.0);\n  out.local = corner;\n  out.halfSizePx = halfSizePx;\n  out.strokeWidthPx = strokeWidthPx;\n  out.fillRgba = in.fillRgba;\n  out.strokeRgba = in.strokeRgba;\n  return out;\n}\n\n@fragment\nfn fsMain(in: VSOut) -> @location(0) vec4<f32> {\n  if (in.halfSizePx <= 0.0) {\n    discard;\n  }\n\n  // Circle SDF in normalized space: dist == 1 at the circle boundary.\n  let dist = length(in.local);\n  let aa = max(1e-6, fwidth(dist));\n\n  // Coverage inside the circle.\n  let outerCoverage = 1.0 - smoothstep(1.0 - aa, 1.0 + aa, dist);\n  if (outerCoverage <= 0.0) {\n    discard;\n  }\n\n  // Optional stroke: compute inner radius in normalized units.\n  let strokeNorm = clamp(in.strokeWidthPx / max(1e-6, in.halfSizePx), 0.0, 1.0);\n  let inner = max(0.0, 1.0 - strokeNorm);\n  let innerCoverage = 1.0 - smoothstep(inner - aa, inner + aa, dist);\n\n  let fillCoverage = clamp(innerCoverage, 0.0, 1.0);\n  let strokeCoverage = clamp(outerCoverage - innerCoverage, 0.0, 1.0);\n\n  let fillA = clamp(in.fillRgba.a, 0.0, 1.0) * fillCoverage;\n  let strokeA = clamp(in.strokeRgba.a, 0.0, 1.0) * strokeCoverage;\n  let outA = fillA + strokeA;\n  if (outA <= 0.0) {\n    discard;\n  }\n\n  // Straight-alpha output: compute a weighted average RGB for correct blending.\n  let rgb = (in.fillRgba.rgb * fillA + in.strokeRgba.rgb * strokeA) / outA;\n  return vec4<f32>(rgb, outA);\n}\n\n",Zt=e=>Math.min(1,Math.max(0,e)),Jt=e=>{if(!Number.isFinite(e)||e<=0)return 1;const t=Math.ceil(e);return 2**Math.ceil(Math.log2(t))};function Kt(e,t){let n=!1;const i=(null==t?void 0:t.targetFormat)??"bgra8unorm",r=(null==t?void 0:t.sampleCount)??1,o=Number.isFinite(r)?Math.max(1,Math.floor(r)):1,a=null==t?void 0:t.pipelineCache,s=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),l=Ue(e,16,{label:"annotationMarkerRenderer/vsUniforms"}),u=new Float32Array(4),c=e.createBindGroup({layout:s,entries:[{binding:0,resource:{buffer:l}}]}),d=Te(e,{label:"annotationMarkerRenderer/pipeline",bindGroupLayouts:[s],vertex:{code:jt,label:"annotationMarker.wgsl",buffers:[{arrayStride:48,stepMode:"instance",attributes:[{shaderLocation:0,format:"float32x2",offset:0},{shaderLocation:1,format:"float32",offset:8},{shaderLocation:2,format:"float32",offset:12},{shaderLocation:3,format:"float32x4",offset:16},{shaderLocation:4,format:"float32x4",offset:32}]}]},fragment:{code:jt,label:"annotationMarker.wgsl",formats:i,blend:{color:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}}},primitive:{topology:"triangle-list",cullMode:"none"},multisample:{count:o}},a);let f=null,m=0,p=new ArrayBuffer(0),h=new Float32Array(p);const g=()=>{if(n)throw new Error("AnnotationMarkerRenderer is disposed.")};return{prepare:({canvasWidth:t,canvasHeight:n,devicePixelRatio:i,instances:r})=>{if(g(),!Number.isFinite(t)||!Number.isFinite(n)||t<=0||n<=0)throw new Error("AnnotationMarkerRenderer.prepare: canvasWidth/canvasHeight must be positive finite numbers.");if(!Array.isArray(r))throw new Error("AnnotationMarkerRenderer.prepare: instances must be an array.");((t,n,i)=>{const r=Number.isFinite(t)&&t>0?t:1,o=Number.isFinite(n)&&n>0?n:1,a=Number.isFinite(i)&&i>0?i:1;u[0]=r,u[1]=o,u[2]=a,u[3]=0,ke(e,l,u)})(t,n,i),(e=>{if(e<=h.length)return;const t=Math.max(32,Jt(e));p=new ArrayBuffer(4*t),h=new Float32Array(p)})(12*r.length);const o=h;let a=0;for(let e=0;e<r.length;e++){const t=r[e];if(!Number.isFinite(t.xCssPx)||!Number.isFinite(t.yCssPx)||!Number.isFinite(t.sizeCssPx)||t.sizeCssPx<=0)continue;const n=t.strokeWidthCssPx??0,i=t.strokeRgba??[0,0,0,0],s=Zt(t.fillRgba[0]),l=Zt(t.fillRgba[1]),u=Zt(t.fillRgba[2]),c=Zt(t.fillRgba[3]),d=Zt(i[0]),f=Zt(i[1]),m=Zt(i[2]),p=Zt(i[3]);o[a+0]=t.xCssPx,o[a+1]=t.yCssPx,o[a+2]=t.sizeCssPx,o[a+3]=Number.isFinite(n)?Math.max(0,n):0,o[a+4]=s,o[a+5]=l,o[a+6]=u,o[a+7]=c,o[a+8]=d,o[a+9]=f,o[a+10]=m,o[a+11]=p,a+=12}if(m=a/12,0===m)return;const s=Math.max(4,48*m);if(!f||f.size<s){const t=Math.max(Math.max(4,Jt(s)),f?f.size:0);if(f)try{f.destroy()}catch{}f=e.createBuffer({label:"annotationMarkerRenderer/instanceBuffer",size:t,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST})}e.queue.writeBuffer(f,0,p,0,48*m)},render:(e,t=0,n)=>{if(g(),!f||0===m)return;const i=Number.isFinite(t)?Math.max(0,Math.floor(t)):0,r=Math.max(0,m-i),o=null==n?r:Number.isFinite(n)?Math.max(0,Math.min(r,Math.floor(n))):r;0!==o&&(e.setPipeline(d),e.setBindGroup(0,c),e.setVertexBuffer(0,f),e.draw(6,o,0,i))},dispose:()=>{if(!n){if(n=!0,f)try{f.destroy()}catch{}f=null,m=0;try{l.destroy()}catch{}}}}}const Qt=(e,t,n)=>Math.min(n,Math.max(t,e));const en=(e,t,n)=>Math.min(n,Math.max(t,e)),tn=e=>en(e,0,1),nn=e=>Object.is(e,-0)?0:e;const rn=new WeakMap,on=e=>{const t="object"==typeof e&&null!==e?e:null;if(t&&rn.has(t))return rn.get(t);let n=!1;const i=s(e);for(let t=0;t<i;t++){const i=l(e,t);if(Number.isNaN(i)){n=!0;break}}return t&&rn.set(t,n),n},an=(e,t)=>{let n=0,i=s(e);for(;n<i;){const r=n+i>>>1;l(e,r)<t?n=r+1:i=r}return n};function sn(e,t,n,i){if(!Number.isFinite(t))return[];const r=Number.POSITIVE_INFINITY,o=r*r,a=n.invert(t);if(!Number.isFinite(a))return[];const d=[],f=((e,t)=>{const n=[];for(let t=0;t<e.length;t++){const i=e[t];"bar"===(null==i?void 0:i.type)&&n.push({globalSeriesIndex:t,s:i})}if(0===n.length)return null;const i=ye(n.map(e=>e.s),t),r=i.barWidthPx,o=i.gapPx,a=i.clusterWidthPx;if(!(Number.isFinite(r)&&r>0))return null;const s=new Map;for(let e=0;e<n.length;e++){const t=n[e].globalSeriesIndex,r=i.clusterSlots.clusterIndexBySeries[e]??0;s.set(t,r)}return{barWidth:r,gap:o,clusterWidth:a,clusterIndexByGlobalSeriesIndex:s}})(e,n);for(let i=0;i<e.length;i++){const r=e[i];if("pie"===r.type||"candlestick"===r.type||!1===r.visible)continue;const m=r.data,p=s(m);if(0===p)continue;if("bar"===r.type&&f){const e=f.clusterIndexByGlobalSeriesIndex.get(i);if(void 0!==e){const{barWidth:r,gap:o,clusterWidth:a}=f,s=-a/2+e*(r+o),h=0;if(Number.isFinite(r)&&r>0&&Number.isFinite(s)){let e=-1;const o=e=>{if(!Number.isFinite(e))return!1;const n=e+s;return t>=n-h&&t<n+r+h};if(on(m))for(let t=0;t<p;t++){const i=l(m,t);Number.isFinite(i)&&(o(n.scale(i))&&(e=e<0?t:Math.min(e,t)))}else{const i=n.invert(t-s);if(Number.isFinite(i)){const o=an(m,i),a=e=>{if(e<0||e>=p)return null;const t=l(m,e);if(!Number.isFinite(t))return null;const i=n.scale(t);return Number.isFinite(i)?i:null};for(let n=o-1;n>=0;n--){const i=a(n);if(null===i)continue;const o=i+s,l=o+r;if(l+h<=t)break;t>=o-h&&t<l+h&&(e=e<0?n:Math.min(e,n))}for(let n=o;n<p;n++){const i=a(n);if(null===i)continue;const o=i+s;if(o-h>t)break;t<o+r+h&&(e=e<0?n:Math.min(e,n))}}}if(e>=0){const t=l(m,e),n=u(m,e),r=c(m,e),o=void 0!==r?[t,n,r]:[t,n];d.push({seriesIndex:i,dataIndex:e,point:o});continue}}}}let h=-1,g=null,b=o;const v=(e,t)=>{if(!Number.isFinite(t)||!(t<b||t===b&&(h<0||e<h)))return;b=t,h=e;const n=l(m,e),i=u(m,e),r=c(m,e);g=void 0!==r?[n,i,r]:[n,i]};if(on(m))for(let e=0;e<p;e++){const i=l(m,e);if(!Number.isFinite(i))continue;const r=n.scale(i);if(!Number.isFinite(r))continue;const o=r-t;v(e,o*o)}else{const e=an(m,a);let i=e-1,r=e;const o=e=>{const i=l(m,e);if(!Number.isFinite(i))return null;const r=n.scale(i);if(!Number.isFinite(r))return null;const o=r-t;return o*o};for(;i>=0||r<p;){for(;i>=0&&null===o(i);)i--;for(;r<p&&null===o(r);)r++;if(i<0&&r>=p)break;const e=i>=0?o(i)??Number.POSITIVE_INFINITY:Number.POSITIVE_INFINITY,t=r<p?o(r)??Number.POSITIVE_INFINITY:Number.POSITIVE_INFINITY;if(e>b&&t>b)break;e<=t?(i>=0&&e<=b&&v(i,e),i--,r<p&&t<=b&&t===e&&(v(r,t),r++)):(r<p&&t<=b&&v(r,t),r++)}}null!==g&&d.push({seriesIndex:i,dataIndex:h,point:g})}return d}const ln=e=>Array.isArray(e),un=e=>ln(e)?e[0]:e.timestamp,cn=new WeakMap;function dn(e,t,n,i){if(0===t.length)return 0;const r=(e=>{const t=cn.get(e);if(void 0!==t)return t;const n=[];for(let t=0;t<e.length;t++){const i=un(e[t]);Number.isFinite(i)&&n.push(i)}if(n.length<2)return 1;n.sort((e,t)=>e-t);let i=Number.POSITIVE_INFINITY;for(let e=1;e<n.length;e++){const t=n[e]-n[e-1];t>0&&t<i&&(i=t)}const r=Number.isFinite(i)&&i>0?i:1;return cn.set(e,r),r})(t);let o=0;if(Number.isFinite(r)&&r>0){let e=null;for(let n=0;n<t.length;n++){const i=un(t[n]);if(Number.isFinite(i)){e=i;break}}if(null!=e){const t=n.scale(e),i=n.scale(e+r),a=Math.abs(i-t);Number.isFinite(a)&&a>0&&(o=a)}}(!(o>0)||!Number.isFinite(o))&&(o=(Number.isFinite(i??Number.NaN)?i:0)/Math.max(1,t.length));let a=0;const s=e.barWidth;if("number"==typeof s)a=Number.isFinite(s)?Math.max(0,s):0;else if("string"==typeof s){const e=(e=>{const t=e.trim().match(/^(\d+(?:\.\d+)?)%$/);if(!t)return null;const n=Number(t[1])/100;return Number.isFinite(n)?n:null})(s);a=null==e?0:o*(e=>Math.min(1,Math.max(0,e)))(e)}const l=Number.isFinite(e.barMinWidth)?Math.max(0,e.barMinWidth):0,u=Number.isFinite(e.barMaxWidth)?Math.max(0,e.barMaxWidth):Number.POSITIVE_INFINITY,c=Math.max(l,u);return a=Math.min(Math.max(a,l),c),Number.isFinite(a)?a:0}const fn=new WeakMap,mn=e=>{const t=fn.get(e);if(void 0!==t)return t;let n=Number.NEGATIVE_INFINITY;for(let t=0;t<e.length;t++){const i=un(e[t]);if(!Number.isFinite(i)||i<n)return fn.set(e,!1),!1;n=i}return fn.set(e,!0),!0},pn=(e,t)=>{let n=0,i=e.length;for(;n<i;){const r=n+i>>>1;un(e[r])<t?n=r+1:i=r}return n};function hn(e,t,n,i,r,o){if(!(Number.isFinite(t)&&Number.isFinite(n)&&Number.isFinite(o)&&o>0))return null;const a=i.invert(t);if(!Number.isFinite(a))return null;const s=o/2;let l=null,u=Number.POSITIVE_INFINITY;const c=(e,t,n,i)=>{if(Number.isFinite(i)){if(i<u)return u=i,void(l={seriesIndex:e,dataIndex:t,point:n});i===u&&l&&(t<l.dataIndex||t===l.dataIndex&&e<l.seriesIndex)&&(l={seriesIndex:e,dataIndex:t,point:n})}},d=e=>{const t=(e=>ln(e)?e[1]:e.open)(e),i=(e=>ln(e)?e[2]:e.close)(e);if(!Number.isFinite(t)||!Number.isFinite(i))return!1;const o=r.scale(t),a=r.scale(i);if(!Number.isFinite(o)||!Number.isFinite(a))return!1;const s=Math.min(o,a),l=Math.max(o,a);return n>=s&&n<=l};for(let n=0;n<e.length;n++){const r=e[n].data,o=r.length;if(0===o)continue;if(!mn(r)){for(let e=0;e<o;e++){const o=r[e],a=un(o);if(!Number.isFinite(a))continue;const l=i.scale(a);if(!Number.isFinite(l))continue;const u=Math.abs(t-l);u>s||d(o)&&c(n,e,o,u)}continue}const l=pn(r,a);for(let e=l-1;e>=0;e--){const o=r[e],a=un(o),l=i.scale(a);if(!Number.isFinite(l))continue;if(l<t-s)break;const u=Math.abs(t-l);u>s||d(o)&&c(n,e,o,u)}for(let e=l;e<o;e++){const o=r[e],a=un(o),l=i.scale(a);if(!Number.isFinite(l))continue;if(l>t+s)break;const u=Math.abs(t-l);u>s||d(o)&&c(n,e,o,u)}}return l}const gn=2*Math.PI,bn=e=>{if(!Number.isFinite(e))return 0;const t=e%gn;return t<0?t+gn:t};function vn(e,t,n,i,r){if(!(Number.isFinite(e)&&Number.isFinite(t)&&Number.isFinite(i.x)&&Number.isFinite(i.y)))return null;const o=Number.isFinite(r.inner)?Math.max(0,r.inner):0,a=Number.isFinite(r.outer)?Math.max(0,r.outer):0;if(!(a>0))return null;const s=e-i.x,l=i.y-t,u=Math.hypot(s,l);if(!Number.isFinite(u)||u<=o||u>a)return null;const c=bn(Math.atan2(l,s)),d=n.series,f=d.data;let m=0,p=0;for(let e=0;e<f.length;e++){const t=f[e],n=null==t?void 0:t.value;"number"==typeof n&&Number.isFinite(n)&&n>0&&!1!==t.visible&&(m+=n,p++)}if(!(m>0)||0===p)return null;const h="number"==typeof d.startAngle&&Number.isFinite(d.startAngle)?d.startAngle:90;let g=bn(h*Math.PI/180),b=0,v=0;for(let e=0;e<f.length;e++){const t=f[e],i=null==t?void 0:t.value;if("number"!=typeof i||!Number.isFinite(i)||i<=0||!1===(null==t?void 0:t.visible))continue;v++;let r=i/m*gn;if(r=v===p?Math.max(0,gn-b):Math.max(0,Math.min(gn,r)),b+=r,!(r>0))continue;const o=g,a=1===p?g+gn:bn(g+r);g=bn(g+r);let s=a-o;s<0&&(s+=gn);let l=c-o;if(l<0&&(l+=gn),l<=s)return{seriesIndex:n.seriesIndex,dataIndex:e,slice:t}}return null}const yn=(e,t)=>{if(!Number.isFinite(t))throw new Error(`${e} must be a finite number. Received: ${String(t)}`)};function xn(){let e=0,t=1,n=0,i=1;const r={domain:(n,i)=>(yn("domain min",n),yn("domain max",i),e=n,t=i,r),range:(e,t)=>(yn("range min",e),yn("range max",t),n=e,i=t,r),scale:r=>Number.isFinite(r)?e===t?(n+i)/2:n+(r-e)/(t-e)*(i-n):Number.NaN,invert:r=>Number.isFinite(r)?e===t?e:n===i?(e+t)/2:e+(r-n)/(i-n)*(t-e):Number.NaN};return r}function wn(e,t){const n=getComputedStyle(e),i=n.position,r=n.overflow,o=(null==t?void 0:t.clip)??!1,a="static"===i,s=!o&&("hidden"===r||"scroll"===r||"auto"===r),l=a?e.style.position:null,u=s?e.style.overflow:null;a&&(e.style.position="relative"),s&&(e.style.overflow="visible");const c=document.createElement("div");c.style.position="absolute",c.style.inset="0",c.style.pointerEvents="none",c.style.overflow=o?"hidden":"visible",c.style.zIndex="10",e.appendChild(c);let d=!1;return{clear:()=>{d||c.replaceChildren()},addLabel:(e,t,n,i)=>{if(d)return document.createElement("span");const r=document.createElement("span");r.textContent=e,r.style.position="absolute",r.style.left=`${t}px`,r.style.top=`${n}px`,r.style.pointerEvents="none",r.style.userSelect="none",r.style.whiteSpace="nowrap",r.style.lineHeight="1",null!=(null==i?void 0:i.fontSize)&&(r.style.fontSize=`${i.fontSize}px`),null!=(null==i?void 0:i.color)&&(r.style.color=i.color);const o=(null==i?void 0:i.rotation)??0,a=(null==i?void 0:i.anchor)??"start",{translateX:s,originX:l}=(e=>{switch(e){case"start":return{translateX:"0%",originX:"0%"};case"middle":return{translateX:"-50%",originX:"50%"};case"end":return{translateX:"-100%",originX:"100%"}}})(a);return r.style.transformOrigin=`${l} 50%`,r.style.transform=`translateX(${s}) translateY(-50%) rotate(${o}deg)`,c.appendChild(r),r},dispose:()=>{if(!d){d=!0;try{c.remove()}finally{null!==l&&(e.style.position=l),null!==u&&(e.style.overflow=u)}}}}}const Mn=(e,t)=>{var n;return(null==(n=e.name)?void 0:n.trim())||`Series ${t+1}`},Fn=(e,t,n)=>{var i;const r=null==(i=e.color)?void 0:i.trim();if(r)return r;const o=n.colorPalette;return o.length>0?o[t%o.length]??"#000000":"#000000"},Nn=(e,t)=>(null==e?void 0:e.trim())||`Slice ${t+1}`,Cn=(e,t,n,i)=>{const r=null==e?void 0:e.trim();if(r)return r;const o=i.colorPalette,a=o.length;return a>0?o[(t+n)%a]??"#000000":"#000000"},Sn=(e,t,n)=>n<t||e<t?t:e>n?n:e;function An(e){const t="static"===getComputedStyle(e).position,n=t?e.style.position:null;t&&(e.style.position="relative");const i=document.createElement("div");i.style.position="absolute",i.style.left="0",i.style.top="0",i.style.pointerEvents="none",i.style.userSelect="none",i.style.boxSizing="border-box",i.style.zIndex="var(--chartgpu-tooltip-z, 10)",i.style.padding="var(--chartgpu-tooltip-padding, 6px 8px)",i.style.borderRadius="var(--chartgpu-tooltip-radius, 8px)",i.style.borderStyle="solid",i.style.borderWidth="var(--chartgpu-tooltip-border-width, 1px)",i.style.borderColor="var(--chartgpu-tooltip-border, rgba(224,224,224,0.35))",i.style.boxShadow="var(--chartgpu-tooltip-shadow, 0 6px 18px rgba(0,0,0,0.35))",i.style.maxWidth="var(--chartgpu-tooltip-max-width, min(320px, 100%))",i.style.overflow="hidden",i.style.fontFamily='var(--chartgpu-tooltip-font-family, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji")',i.style.fontSize="var(--chartgpu-tooltip-font-size, 12px)",i.style.lineHeight="var(--chartgpu-tooltip-line-height, 1.2)",i.style.color="var(--chartgpu-tooltip-color, #e0e0e0)",i.style.background="var(--chartgpu-tooltip-bg, rgba(26,26,46,0.95))",i.style.whiteSpace="normal",i.style.opacity="0",i.style.transitionProperty="opacity",i.style.transitionDuration="140ms",i.style.transitionTimingFunction="ease",i.style.willChange="opacity",i.style.display="none",i.style.visibility="hidden",i.setAttribute("role","tooltip"),e.appendChild(i);let r=!1,o=0,a=null,s=null;const l=()=>{null!=a&&(window.clearTimeout(a),a=null),null!=s&&(window.cancelAnimationFrame(s),s=null)};return{show:(t,n,a)=>{if(r)return;o+=1,l();const u="none"===i.style.display||"hidden"===i.style.visibility;i.innerHTML=a,i.style.display="block",i.style.visibility="hidden";const{width:c,height:d}=(()=>{const e=i.style.visibility;i.style.visibility="hidden";const t=i.offsetWidth,n=i.offsetHeight;return i.style.visibility=e,{width:t,height:n}})(),f=e.clientWidth,m=e.clientHeight;let p=t+12,h=n+12;if(p+c>f-8&&(p=t-12-c),h+d>m-8&&(h=n-12-d),p=Sn(p,8,f-8-c),h=Sn(h,8,m-8-d),i.style.left=`${p}px`,i.style.top=`${h}px`,i.style.visibility="visible",u){i.style.opacity="0";const e=o;s=window.requestAnimationFrame(()=>{s=null,!r&&e===o&&(i.style.opacity="1")})}else i.style.opacity="1"},hide:()=>{if(r)return;if(o+=1,l(),"none"===i.style.display||"hidden"===i.style.visibility)return i.style.opacity="0",i.style.visibility="hidden",void(i.style.display="none");i.style.opacity="0";const e=o;a=window.setTimeout(()=>{a=null,!r&&e===o&&(i.style.visibility="hidden",i.style.display="none")},190)},dispose:()=>{if(!r){r=!0;try{l(),i.remove()}finally{null!==n&&(e.style.position=n)}}}}}function In(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;")}function Pn(e){if(!Number.isFinite(e))return"—";const t=(Object.is(e,-0)?0:e).toFixed(2).replace(/\.?0+$/,"");return"-0"===t?"0":t}function Rn(e){const t=e.seriesName.trim();return t.length>0?t:`Series ${e.seriesIndex+1}`}function En(e){const t=e.trim();return 0===t.length?"#888":/^#[0-9a-fA-F]{3}$/.test(t)||/^#[0-9a-fA-F]{6}$/.test(t)||/^#[0-9a-fA-F]{8}$/.test(t)||/^rgba?\(\s*\d{1,3}\s*(?:,\s*|\s+)\d{1,3}\s*(?:,\s*|\s+)\d{1,3}(?:\s*(?:,\s*|\/\s*)(?:0|1|0?\.\d+))?\s*\)$/.test(t)||/^[a-zA-Z]+$/.test(t)?t:"#888"}function Bn(e){return 5===e.length}function Tn(e,t){const n=In(Rn(e)),i=In(t);return['<div style="display:flex;align-items:center;justify-content:space-between;gap:12px;">','<span style="display:flex;align-items:center;gap:8px;min-width:0;">',`<span style="width:8px;height:8px;border-radius:999px;flex:0 0 auto;background-color:${In(En(e.color))};"></span>`,`<span style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${n}</span>`,"</span>",`<span style="font-variant-numeric:tabular-nums;white-space:nowrap;">${i}</span>`,"</div>"].join("")}function Dn(e){const[,t,n,i,r]=e.value,o=In(Rn(e)),a=In(En(e.color)),s=Pn(t),l=Pn(r),u=Pn(i),c=Pn(n),d=n>t,f=d?"▲":"▼",m=d?"#22c55e":"#ef4444",p=function(e,t){if(!Number.isFinite(e)||!Number.isFinite(t)||0===e)return"—";const n=(t-e)/e*100;return Number.isFinite(n)?`${n>0?"+":""}${n.toFixed(2)}%`:"—"}(t,n),h=In(`O: ${s} H: ${l} L: ${u} C: ${c}`),g=In(f),b=In(p),v=In(m);return['<div style="display:flex;flex-direction:column;gap:4px;">','<div style="display:flex;align-items:center;gap:8px;">',`<span style="width:8px;height:8px;border-radius:999px;flex:0 0 auto;background-color:${a};"></span>`,`<span style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:600;">${o}</span>`,"</div>",`<div style="font-variant-numeric:tabular-nums;white-space:nowrap;font-size:0.9em;">${h}</div>`,'<div style="display:flex;align-items:center;gap:6px;font-variant-numeric:tabular-nums;">',`<span style="color:${v};font-weight:700;">${g}</span>`,`<span style="color:${v};font-weight:600;">${b}</span>`,"</div>","</div>"].join("")}function Un(e){return Bn(e.value)?function(e){return Dn(e)}(e):Tn(e,Pn(e.value[1]))}function kn(e){return 0===e.length?"":`<div style="margin:0 0 6px 0;font-weight:600;font-variant-numeric:tabular-nums;white-space:nowrap;">${In(`x: ${Pn(e[0].value[0])}`)}</div>${e.map(e=>Bn(e.value)?Dn(e):Tn(e,Pn(e.value[1]))).join('<div style="height:4px;"></div>')}`}const Gn=e=>Number.isFinite(e)?e:0;function zn(){const e=new Map;return{animate:function(t,n,i,r,o,a){const s=Symbol("Animation");if(Array.isArray(t)||Array.isArray(n)){if(!Array.isArray(t)||!Array.isArray(n))throw new Error('Array animation requires both "from" and "to" to be arrays');if(t.length!==n.length)throw new Error(`Array animation length mismatch: from.length=${t.length}, to.length=${n.length}`);const l=new Array(t.length);return e.set(s,{kind:"array",from:t,to:n,duration:i,easing:r,onUpdate:o,onComplete:a,startTime:null,out:l}),s}return e.set(s,{kind:"scalar",from:t,to:n,duration:i,easing:r,onUpdate:o,onComplete:a,startTime:null}),s},cancel:function(t){e.delete(t)},cancelAll:function(){e.clear()},update:function(t){var n;const i=(e=>Number.isFinite(e)?e:null)(t);if(null===i)return;const r=Array.from(e.keys());for(const t of r){const r=e.get(t);if(!r)continue;const o=r.startTime??i;null===r.startTime&&e.set(t,{...r,startTime:o});const a=Gn(r.duration),s=Math.max(0,i-o),l=a<=0||s>=a,u=a<=0?1:s/a,c=l?1:r.easing(u);if("scalar"===r.kind){const n=r.from+(r.to-r.from)*c;if(r.onUpdate(n),!e.has(t))continue}else{const n=r.out.length;for(let e=0;e<n;e++){const t=r.from[e]??0,n=r.to[e]??0;r.out[e]=t+(n-t)*c}if(r.onUpdate(r.out),!e.has(t))continue}l&&(null==(n=r.onComplete)||n.call(r),e.delete(t))}}}}const Vn=e=>Number.isNaN(e)||e<=0?0:e>=1?1:e;function Ln(e){return Vn(e)}function Wn(e){const t=1-Vn(e);return 1-t*t*t}function On(e){const t=Vn(e);if(t<.5)return 4*t*t*t;const n=-2*t+2;return 1-n*n*n/2}function _n(e){const t=Vn(e),n=7.5625,i=2.75;if(t<1/i)return n*t*t;if(t<2/i){const e=t-1.5/i;return n*e*e+.75}if(t<2.5/i){const e=t-2.25/i;return n*e*e+.9375}const r=t-2.625/i;return n*r*r+.984375}function Yn(e){switch(e){case"linear":default:return Ln;case"cubicOut":return Wn;case"cubicInOut":return On;case"bounceOut":return _n}}const $n=function(e){return typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement},Xn=864e5,Hn=30*Xn,qn=365*Xn,jn=e=>"number"==typeof e&&Number.isFinite(e)?e:null,Zn=e=>"number"==typeof e&&Number.isFinite(e)?e:void 0,Jn=e=>{throw new Error(`RenderCoordinator: unreachable value: ${String(e)}`)},Kn=e=>Array.isArray(e),Qn=e=>{const t=s(e);if(0===t)return{x:[],y:[]};const n=new Array(t),i=new Array(t);let r,o=!1;for(let a=0;a<t;a++){n[a]=l(e,a),i[a]=u(e,a);const t=c(e,a);void 0!==t?(o=!0,r||(r=new Array(a)),r[a]=t):r&&(r[a]=void 0)}return o&&r?{x:n,y:i,size:r}:{x:n,y:i}},ei=(e,t)=>{const n=f(t);if(!n)return e;if(!e)return n;let i=Math.min(e.xMin,n.xMin),r=Math.max(e.xMax,n.xMax),o=Math.min(e.yMin,n.yMin),a=Math.max(e.yMax,n.yMax);return i===r&&(r=i+1),o===a&&(a=o+1),{xMin:i,xMax:r,yMin:o,yMax:a}},ti=(e,t)=>{if(0===t.length)return e;let n=(null==e?void 0:e.xMin)??Number.POSITIVE_INFINITY,i=(null==e?void 0:e.xMax)??Number.NEGATIVE_INFINITY,r=(null==e?void 0:e.yMin)??Number.POSITIVE_INFINITY,o=(null==e?void 0:e.yMax)??Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const a=t[e],s=fi(a)?a[0]:a.timestamp,l=fi(a)?a[3]:a.low,u=fi(a)?a[4]:a.high;!Number.isFinite(s)||!Number.isFinite(l)||!Number.isFinite(u)||(s<n&&(n=s),s>i&&(i=s),l<r&&(r=l),u>o&&(o=u))}return Number.isFinite(n)&&Number.isFinite(i)&&Number.isFinite(r)&&Number.isFinite(o)?(n===i&&(i=n+1),r===o&&(o=r+1),{xMin:n,xMax:i,yMin:r,yMax:o}):e},ni=(e,t)=>{let n=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,r=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let a=0;a<e.length;a++){const c=e[a];if("pie"===c.type)continue;const d=(null==t?void 0:t[a])??null;if(d){const e=d;if(Number.isFinite(e.xMin)&&Number.isFinite(e.xMax)&&Number.isFinite(e.yMin)&&Number.isFinite(e.yMax)){e.xMin<n&&(n=e.xMin),e.xMax>i&&(i=e.xMax),e.yMin<r&&(r=e.yMin),e.yMax>o&&(o=e.yMax);continue}}const f=c.rawBounds;if(f){const e=f;if(Number.isFinite(e.xMin)&&Number.isFinite(e.xMax)&&Number.isFinite(e.yMin)&&Number.isFinite(e.yMax)){e.xMin<n&&(n=e.xMin),e.xMax>i&&(i=e.xMax),e.yMin<r&&(r=e.yMin),e.yMax>o&&(o=e.yMax);continue}}if("candlestick"===c.type){const e=c.rawData??c.data;for(let t=0;t<e.length;t++){const a=e[t];if(fi(a)){const e=a[0],t=a[3],s=a[4];if(!Number.isFinite(e)||!Number.isFinite(t)||!Number.isFinite(s))continue;const l=Math.min(t,s),u=Math.max(t,s);e<n&&(n=e),e>i&&(i=e),l<r&&(r=l),u>o&&(o=u)}else{const e=a.timestamp,t=a.low,s=a.high;if(!Number.isFinite(e)||!Number.isFinite(t)||!Number.isFinite(s))continue;const l=Math.min(t,s),u=Math.max(t,s);e<n&&(n=e),e>i&&(i=e),l<r&&(r=l),u>o&&(o=u)}}continue}const m=c.data,p=s(m);for(let e=0;e<p;e++){const t=l(m,e),a=u(m,e);!Number.isFinite(t)||!Number.isFinite(a)||(t<n&&(n=t),t>i&&(i=t),a<r&&(r=a),a>o&&(o=a))}}return Number.isFinite(n)&&Number.isFinite(i)&&Number.isFinite(r)&&Number.isFinite(o)?(n===i&&(i=n+1),r===o&&(o=r+1),{xMin:n,xMax:i,yMin:r,yMax:o}):{xMin:0,xMax:1,yMin:0,yMax:1}},ii=(e,t)=>{let n=e,i=t;if((!Number.isFinite(n)||!Number.isFinite(i))&&(n=0,i=1),n===i)i=n+1;else if(n>i){const e=n;n=i,i=e}return{min:n,max:i}},ri=(e,t)=>{const n=e.canvas;if(!n)throw new Error("RenderCoordinator: gpuContext.canvas is required.");const i=e.devicePixelRatio??1,r=Number.isFinite(i)&&i>0?i:1,o=n.width,a=n.height;if(!Number.isFinite(o)||!Number.isFinite(a))throw new Error(`RenderCoordinator: Invalid canvas dimensions: width=${o}, height=${a}. Canvas must be initialized with finite dimensions before rendering.`);const s=Math.max(1,Math.floor(o)),l=Math.max(1,Math.floor(a)),u=Number.isFinite(t.grid.left)?t.grid.left:0,c=Number.isFinite(t.grid.right)?t.grid.right:0,d=Number.isFinite(t.grid.top)?t.grid.top:0,f=Number.isFinite(t.grid.bottom)?t.grid.bottom:0;return{left:Math.max(0,u),right:Math.max(0,c),top:Math.max(0,d),bottom:Math.max(0,f),canvasWidth:s,canvasHeight:l,devicePixelRatio:r}},oi=(e,t)=>{const n=W(e);if(!n)return e;const i=Math.max(0,Math.min(1,n[3]*t));return(e=>`rgba(${Math.max(0,Math.min(255,Math.round(255*e[0])))},${Math.max(0,Math.min(255,Math.round(255*e[1])))},${Math.max(0,Math.min(255,Math.round(255*e[2])))},${Math.max(0,Math.min(1,e[3]))})`)([n[0],n[1],n[2],i])},ai=e=>Math.min(1,Math.max(0,e)),si=(e,t,n)=>Math.min(n,Math.max(t,0|e)),li=(e,t,n)=>e+(t-e)*ai(n),ui=(e,t,n)=>ii(li(e.min,t.min,n),li(e.max,t.max,n)),ci=(e,t)=>(e+1)/2*t,di=(e,t)=>(1-e)/2*t,fi=C,mi=(e,t)=>{if("number"==typeof e)return Number.isFinite(e)?e:null;if("string"!=typeof e)return null;const n=e.trim();if(0===n.length)return null;if(n.endsWith("%")){const e=Number.parseFloat(n.slice(0,-1));return Number.isFinite(e)?e/100*t:null}const i=Number.parseFloat(n);return Number.isFinite(i)?i:null},pi=(e,t,n)=>{const i=(null==e?void 0:e[0])??"50%",r=(null==e?void 0:e[1])??"50%",o=mi(i,t),a=mi(r,n);return{x:Number.isFinite(o)?o:.5*t,y:Number.isFinite(a)?a:.5*n}},hi=(e,t)=>{if(null==e)return{inner:0,outer:.7*t};if((e=>Array.isArray(e))(e)){const n=mi(e[0],t),i=mi(e[1],t),r=Math.max(0,Number.isFinite(n)?n:0),o=Math.max(r,Number.isFinite(i)?i:.7*t);return{inner:r,outer:Math.min(t,o)}}const n=mi(e,t),i=Math.max(0,Number.isFinite(n)?n:.7*t);return{inner:0,outer:Math.min(t,i)}},gi=e=>String(Math.trunc(e)).padStart(2,"0"),bi=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],vi=(e,t)=>{if(!Number.isFinite(e))return null;(!Number.isFinite(t)||t<0)&&(t=0);const n=new Date(e);if(!Number.isFinite(n.getTime()))return null;const i=n.getFullYear(),r=n.getMonth()+1,o=n.getDate(),a=n.getHours(),s=n.getMinutes();return t<Xn?`${gi(a)}:${gi(s)}`:t<=7*Xn?`${gi(r)}/${gi(o)} ${gi(a)}:${gi(s)}`:t<3*Hn?`${gi(r)}/${gi(o)}`:t<=qn?`${bi[n.getMonth()]??gi(r)} ${gi(o)}`:`${i}/${gi(r)}`},yi=(e,t,n)=>{const i=Math.max(1,Math.floor(n)),r=new Array(i);for(let n=0;n<i;n++){const o=1===i?.5:n/(i-1);r[n]=e+o*(t-e)}return r},xi=(e,t)=>{const n=ni(e.series,t),i=Zn(e.xAxis.min)??n.xMin,r=Zn(e.xAxis.max)??n.xMax;return ii(i,r)},wi=(e,t,n)=>{const i=Zn(e.yAxis.min),r=Zn(e.yAxis.max);if(void 0!==i&&void 0!==r)return ii(i,r);let o;o="visible"===(e.yAxis.autoBounds??"visible")&&n?n:ni(e.series,t);const a=i??o.yMin,s=r??o.yMax;return ii(a,s)},Mi=(e,t)=>{if(!t)return{...e,spanFraction:1};const n=e.max-e.min;if(!Number.isFinite(n)||0===n)return{...e,spanFraction:1};const i=t.start,r=t.end,o=e.min+i/100*n,a=e.min+r/100*n,s=ii(o,a),l=(r-i)/100,u=Number.isFinite(l)?Math.max(0,Math.min(1,l)):1;return{min:s.min,max:s.max,spanFraction:u}},Fi=e=>{if(!1===e||null==e)return null;const t=!0===e?{}:e;if(!t)return null;const n=t.duration??300,i=t.delay??0;return{durationMs:Number.isFinite(n)?Math.max(0,n):300,delayMs:Number.isFinite(i)?Math.max(0,i):0,easing:Yn(t.easing)}},Ni=(e,t,n,i,r)=>{const o=e.point,a=fi(o)?o[0]:o.timestamp,s=fi(o)?o[1]:o.open,l=fi(o)?o[2]:o.close;if(!Number.isFinite(a)||!Number.isFinite(s)||!Number.isFinite(l))return null;const u=(s+l)/2,c=t.scale(a),d=n.scale(u);if(!Number.isFinite(c)||!Number.isFinite(d))return null;const f=i.left+c,m=i.top+d,p=$n(r)?r.offsetLeft+f:f,h=$n(r)?r.offsetTop+m:m;return Number.isFinite(p)&&Number.isFinite(h)?{x:p,y:h}:null},Ci=e=>{let t=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;for(let i=0;i<e.length;i++){const r=e[i].data,o=s(r);for(let e=0;e<o;e++){const i=u(r,e);Number.isFinite(i)&&(i<t&&(t=i),i>n&&(n=i))}}return!Number.isFinite(t)||!Number.isFinite(n)||t<=0&&0<=n?0:Math.abs(t)<Math.abs(n)?t:n};function Si(e,t,n){var i,r,o;if(!e.initialized)throw new Error("RenderCoordinator: gpuContext must be initialized.");const a=e.device;if(!a)throw new Error("RenderCoordinator: gpuContext.device is required.");if(!e.canvas)throw new Error("RenderCoordinator: gpuContext.canvas is required.");if(!e.canvasContext)throw new Error("RenderCoordinator: gpuContext.canvasContext is required.");const b=e.preferredFormat??"bgra8unorm",v=null==n?void 0:n.pipelineCache,y=$n(e.canvas)?e.canvas.parentElement:null,x=y?wn(y):null,w=y?wn(y,{clip:!0}):null,C=y&&!1!==(null==(i=t.legend)?void 0:i.show)?function(e,t="right",n){const i="static"===getComputedStyle(e).position,r=i?e.style.position:null;i&&(e.style.position="relative");const o=document.createElement("div");o.style.position="absolute",o.style.pointerEvents="auto",o.style.userSelect="none",o.style.boxSizing="border-box",o.style.padding="8px",o.style.borderRadius="8px",o.style.borderStyle="solid",o.style.borderWidth="1px",o.style.maxHeight="calc(100% - 16px)",o.style.overflow="auto";const a=document.createElement("div");a.style.display="flex",a.style.gap="8px",o.appendChild(a),n&&(a.addEventListener("click",e=>{const t=e.target.closest("[data-series-index]");if(t){const e=parseInt(t.dataset.seriesIndex,10);if(!isNaN(e)){const i=t.dataset.sliceIndex;if(void 0!==i){const t=parseInt(i,10);if(!isNaN(t))return void n(e,t)}n(e)}}}),a.addEventListener("keydown",e=>{if("Enter"===e.key||" "===e.key){const t=e.target.closest("[data-series-index]");if(t){e.preventDefault();const i=parseInt(t.dataset.seriesIndex,10);if(!isNaN(i)){const e=t.dataset.sliceIndex;if(void 0!==e){const t=parseInt(e,10);if(!isNaN(t))return void n(i,t)}n(i)}}}})),(e=>{switch(o.style.top="",o.style.right="",o.style.bottom="",o.style.left="",o.style.maxWidth="",a.style.flexDirection="",a.style.flexWrap="",a.style.alignItems="",e){case"right":return o.style.top="8px",o.style.right="8px",o.style.maxWidth="40%",a.style.flexDirection="column",a.style.flexWrap="nowrap",void(a.style.alignItems="flex-start");case"left":return o.style.top="8px",o.style.left="8px",o.style.maxWidth="40%",a.style.flexDirection="column",a.style.flexWrap="nowrap",void(a.style.alignItems="flex-start");case"top":return o.style.top="8px",o.style.left="8px",o.style.right="8px",a.style.flexDirection="row",a.style.flexWrap="wrap",void(a.style.alignItems="center");case"bottom":o.style.bottom="8px",o.style.left="8px",o.style.right="8px",a.style.flexDirection="row",a.style.flexWrap="wrap",a.style.alignItems="center"}})(t),e.appendChild(o);let s=!1;return{update:(e,t)=>{if(s)return;o.style.color=t.textColor,o.style.background=t.backgroundColor,o.style.borderColor=t.axisLineColor,o.style.fontFamily=t.fontFamily,o.style.fontSize=`${t.fontSize}px`;const i=[];for(let r=0;r<e.length;r++){const o=e[r];if("pie"===o.type)for(let e=0;e<o.data.length;e++){const a=o.data[e],s=!1!==(null==a?void 0:a.visible),l=document.createElement("div");l.style.display="flex",l.style.alignItems="center",l.style.gap="6px",l.style.lineHeight="1.1",l.style.whiteSpace="nowrap",l.style.cursor=n?"pointer":"default",l.style.opacity=s?"1":"0.5",l.style.transition="opacity 0.2s",n&&(l.setAttribute("role","button"),l.setAttribute("aria-pressed",String(s)),l.setAttribute("aria-label",`Toggle ${Nn(null==a?void 0:a.name,e)} visibility`),l.tabIndex=0,l.dataset.seriesIndex=String(r),l.dataset.sliceIndex=String(e));const u=document.createElement("div");u.style.width="10px",u.style.height="10px",u.style.borderRadius="2px",u.style.flex="0 0 auto",u.style.background=Cn(null==a?void 0:a.color,r,e,t),u.style.border=`1px solid ${t.axisLineColor}`;const c=document.createElement("span");c.textContent=Nn(null==a?void 0:a.name,e),c.style.textDecoration=s?"none":"line-through",l.appendChild(u),l.appendChild(c),i.push(l)}else{const e=!1!==o.visible,a=document.createElement("div");a.style.display="flex",a.style.alignItems="center",a.style.gap="6px",a.style.lineHeight="1.1",a.style.whiteSpace="nowrap",a.style.cursor=n?"pointer":"default",a.style.opacity=e?"1":"0.5",a.style.transition="opacity 0.2s",n&&(a.setAttribute("role","button"),a.setAttribute("aria-pressed",String(e)),a.setAttribute("aria-label",`Toggle ${Mn(o,r)} visibility`),a.tabIndex=0,a.dataset.seriesIndex=String(r));const s=document.createElement("div");s.style.width="10px",s.style.height="10px",s.style.borderRadius="2px",s.style.flex="0 0 auto",s.style.background=Fn(o,r,t),s.style.border=`1px solid ${t.axisLineColor}`;const l=document.createElement("span");l.textContent=Mn(o,r),l.style.textDecoration=e?"none":"line-through",a.appendChild(s),a.appendChild(l),i.push(a)}}a.replaceChildren(...i)},dispose:()=>{if(!s){s=!0;try{o.remove()}finally{null!==r&&(e.style.position=r)}}}}}(y,null==(r=t.legend)?void 0:r.position,(e,t)=>{if(I)return;const n=P.series;if(e<0||e>=n.length)return;const i=n[e];if(!i)return;if(void 0!==t&&"pie"===i.type){const r=i.data;if(t<0||t>=r.length)return;const o=r.map((e,n)=>n===t?{...e,visible:!1===e.visible}:e),a=n.map((t,n)=>n===e?{...t,data:o}:t);return void Sn({...P,series:a})}const r=n.map((t,n)=>n===e?{...t,visible:!1===t.visible}:t);Sn({...P,series:r})}):null,S=(()=>{if(typeof document>"u")return null;try{return document.createElement("canvas").getContext("2d")}catch{return null}})(),A=S?new Map:null;let I=!1,P=t,R=t.series.length,E="pending",B=0;const k=zn();let G=null,z=!1;const V=zn();let L=null,Y=1,H=null;const q={cartesianDataBySeriesIndex:[],pieDataBySeriesIndex:[]},j=()=>{q.cartesianDataBySeriesIndex.length=0,q.pieDataBySeriesIndex.length=0},Z=(e,t,n,i,r)=>{if(0===n)return r??[];const o=r&&r.length===n?r:(()=>{const e=new Array(n);for(let i=0;i<n;i++){const n=l(t,i);e[i]=[n,0]}return e})(),a=ai(i);for(let i=0;i<n;i++){const n=l(e,i),r=l(t,i),s=u(e,i),c=u(t,i),d=Number.isFinite(n)&&Number.isFinite(r)?li(n,r,a):r,f=Number.isFinite(s)&&Number.isFinite(c)?li(s,c,a):c,m=o[i];Kn(m)?(m[0]=d,m[1]=f):(m.x=d,m.y=f)}return o},J=(e,t,n,i)=>{var r,o;const a=e.data,s=t.data;if(a.length!==s.length)return t;const l=s.length,u=i&&i.length===l?i:(()=>{const e=new Array(l);for(let t=0;t<l;t++)e[t]={...s[t],value:0};return e})(),c=ai(n);for(let e=0;e<l;e++){const t=null==(r=a[e])?void 0:r.value,n=null==(o=s[e])?void 0:o.value,i="number"==typeof t&&"number"==typeof n&&Number.isFinite(t)&&Number.isFinite(n)?Math.max(0,li(t,n,c)):"number"==typeof n&&Number.isFinite(n)?n:0;u[e].value=i}return{...t,data:u}},Q=(e,t,n,i)=>{if(e.length!==t.length)return t;const r=new Array(t.length);for(let o=0;o<t.length;o++){const a=e[o],l=t[o];if(a.type!==l.type){r[o]=l;continue}if("pie"===l.type){const e=(null==i?void 0:i.pieDataBySeriesIndex[o])??null,t=J(a,l,n,e);i&&(i.pieDataBySeriesIndex[o]=t.data),r[o]=t;continue}const u=a.data,c=l.data,d=s(u),f=s(c);if(d!==f){r[o]=l;continue}if(f>2e4){r[o]=l;continue}const m=(null==i?void 0:i.cartesianDataBySeriesIndex[o])??null,p=Z(u,c,d,n,m);p?(i&&(i.cartesianDataBySeriesIndex[o]=p),r[o]={...l,data:p}):r[o]=l}return r},ce=new Set,me=new Set;let pe=new Array(t.series.length).fill(null),he=new Array(t.series.length).fill(null),ge=P.series,be=P.series,ve=null;const ye=()=>{ve=(e=>{if("visible"!==(e.yAxis.autoBounds??"visible"))return!1;const t=Zn(e.yAxis.min),n=Zn(e.yAxis.max);return!(void 0!==t&&void 0!==n)})(P)?(e=>{let t=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;for(let i=0;i<e.length;i++){const r=e[i];if("pie"===r.type)continue;if("candlestick"===r.type){const e=r.data;for(let i=0;i<e.length;i++){const r=e[i],o=fi(r)?r[3]:r.low,a=fi(r)?r[4]:r.high;if(!Number.isFinite(o)||!Number.isFinite(a))continue;const s=Math.min(o,a),l=Math.max(o,a);s<t&&(t=s),l>n&&(n=l)}continue}const o=r.data,a=s(o);for(let e=0;e<a;e++){const i=u(o,e);Number.isFinite(i)&&(i<t&&(t=i),i>n&&(n=i))}}return Number.isFinite(t)&&Number.isFinite(n)?(t===n&&(n=t+1),{xMin:0,xMax:1,yMin:t,yMax:n}):{xMin:0,xMax:1,yMin:0,yMax:1}})(be):null};let xe=[],we=!1,Ee=null,Be=null,De=null,Ge=!1,ze=!1;const We=new Map;let Oe=new Array(P.series.length).fill("unknown");const _e=new Set;let $e=y&&!1!==(null==(o=P.tooltip)?void 0:o.show)?An(y):null,Xe=null,He=null,je=null;const Ze=(e,t,n,i)=>{null==$e||$e.show(e,t,n)},Je=()=>{null==$e||$e.hide()},Ke=()=>{Xe=null,He=null,je=null,Je()};var et,tt;et=P.series,tt=P.theme,null==C||C.update(et,tt);let nt=function(e){const t=new Map;let n=!1;const i=()=>{if(n)throw new Error("DataStore is disposed.")},r=e=>{i();const n=t.get(e);if(!n)throw new Error(`Series ${e} has no data. Call setSeries(${e}, data) first.`);return n};return{setSeries:(n,r,o)=>{i();const a=(null==o?void 0:o.xOffset)??0,l=s(r),u=((e,t)=>{const n=s(e);if(0===n)return new Float32Array(0);const i=new ArrayBuffer(2*n*4),r=new Float32Array(i);return d(r,0,e,0,n,t),r})(r,a),c=g(u),f=m(u.byteLength),h=Math.max(4,f),b=t.get(n);if(b&&b.pointCount===l&&b.hash32===c)return;let v=(null==b?void 0:b.buffer)??null,y=(null==b?void 0:b.capacityBytes)??0;if(!v||h>y){const t=e.limits.maxBufferSize;if(h>t)throw new Error(`DataStore.setSeries(${n}): required buffer size ${h} exceeds device.limits.maxBufferSize (${t}).`);if(v)try{v.destroy()}catch{}const i=p(y,h);y=i>t?h:i,v=e.createBuffer({size:y,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})}u.byteLength>0&&e.queue.writeBuffer(v,0,u.buffer,u.byteOffset,u.byteLength);const x=new Float32Array(y/4);x.set(u),t.set(n,{buffer:v,capacityBytes:y,pointCount:l,hash32:c,xOffset:a,stagingBuffer:x})},appendSeries:(n,o)=>{i();const a=s(o);if(0===a)return;const l=r(n),u=l.pointCount,c=u+a,f=m(2*c*4),b=Math.max(4,f);let v=l.buffer,y=l.capacityBytes,x=l.stagingBuffer;const w=e.limits.maxBufferSize;if(b>y){if(b>w)throw new Error(`DataStore.appendSeries(${n}): required buffer size ${b} exceeds device.limits.maxBufferSize (${w}).`);try{v.destroy()}catch{}const i=p(y,b);y=i>w?b:i,v=e.createBuffer({size:y,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});const r=new Float32Array(y/4);r.set(x.subarray(0,2*u)),d(r,2*u,o,0,a,l.xOffset);const s=r.subarray(0,2*c);return s.byteLength>0&&e.queue.writeBuffer(v,0,s.buffer,s.byteOffset,s.byteLength),void t.set(n,{buffer:v,capacityBytes:y,pointCount:c,hash32:g(s),xOffset:l.xOffset,stagingBuffer:r})}d(x,2*u,o,0,a,l.xOffset);const M=x.subarray(2*u,2*c);if(M.byteLength>0){const t=2*u*4;e.queue.writeBuffer(v,t,M.buffer,M.byteOffset,M.byteLength)}const F=new Uint32Array(M.buffer,M.byteOffset,M.byteLength/4),N=h(l.hash32,F);t.set(n,{buffer:v,capacityBytes:y,pointCount:c,hash32:N,xOffset:l.xOffset,stagingBuffer:x})},removeSeries:e=>{i();const n=t.get(e);if(n){try{n.buffer.destroy()}catch{}t.delete(e)}},getSeriesBuffer:e=>r(e).buffer,getSeriesPointCount:e=>r(e).pointCount,dispose:()=>{if(!n){n=!0;for(const e of t.values())try{e.buffer.destroy()}catch{}t.clear()}}}}(a);const it=function(e,t){let n=!1;const i=(null==t?void 0:t.targetFormat)??"bgra8unorm",r=null==t?void 0:t.sampleCount,o=Number.isFinite(r)?Math.max(1,Math.floor(r)):1,a=null==t?void 0:t.pipelineCache,s=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),l=Ue(e,64,{label:"gridRenderer/vsUniforms"}),u=Ue(e,16,{label:"gridRenderer/fsUniforms"}),c=e.createBindGroup({layout:s,entries:[{binding:0,resource:{buffer:l}},{binding:1,resource:{buffer:u}}]}),d=Te(e,{label:"gridRenderer/pipeline",bindGroupLayouts:[s],vertex:{code:Re,label:"grid.wgsl",buffers:[{arrayStride:8,stepMode:"vertex",attributes:[{shaderLocation:0,format:"float32x2",offset:0}]}]},fragment:{code:Re,label:"grid.wgsl",formats:i,blend:{color:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}}},primitive:{topology:"line-list",cullMode:"none"},multisample:{count:o}},a);let f=null,m=null,p=[];const h=()=>{if(n)throw new Error("GridRenderer is disposed.")};return{prepare:(t,n)=>{h();const i=null!=n&&"object"==typeof n&&("lineCount"in n||"color"in n||"append"in n),r=i?n:void 0,o=i?null==r?void 0:r.lineCount:n,a=(null==o?void 0:o.horizontal)??5,s=(null==o?void 0:o.vertical)??6,u=(null==r?void 0:r.color)??"rgba(255,255,255,0.15)",c=!0===(null==r?void 0:r.append);if(a<0||s<0)throw new Error("GridRenderer.prepare: line counts must be non-negative.");if(!(Number.isFinite(t.left)&&Number.isFinite(t.right)&&Number.isFinite(t.top)&&Number.isFinite(t.bottom)&&Number.isFinite(t.canvasWidth)&&Number.isFinite(t.canvasHeight)))throw new Error("GridRenderer.prepare: gridArea dimensions must be finite numbers.");if(t.canvasWidth<=0||t.canvasHeight<=0)throw new Error("GridRenderer.prepare: canvas dimensions must be positive.");if(0===a&&0===s)return void(c||(m=null,p=[]));const d=((e,t,n)=>{const{left:i,right:r,top:o,bottom:a,canvasWidth:s,canvasHeight:l}=e,u=Number.isFinite(e.devicePixelRatio)&&e.devicePixelRatio>0?e.devicePixelRatio:1,c=i*u,d=s-r*u,f=o*u,m=l-a*u,p=d-c,h=m-f,g=new Float32Array(2*(t+n)*2);let b=0;for(let e=0;e<t;e++){const n=c/s*2-1,i=d/s*2-1,r=1-(f+(1===t?.5:e/(t-1))*h)/l*2;g[b++]=n,g[b++]=r,g[b++]=i,g[b++]=r}for(let e=0;e<n;e++){const t=(c+(1===n?.5:e/(n-1))*p)/s*2-1,i=1-f/l*2,r=1-m/l*2;g[b++]=t,g[b++]=i,g[b++]=t,g[b++]=r}return g})(t,a,s),g=2*(a+s),b=W(u)??Le;let v=0;if(c&&m&&m.byteLength>0&&p.length>0){v=m.byteLength;const e=new Float32Array(m.length+d.length);e.set(m,0),e.set(d,m.length),m=e,p=p.concat([{vertexOffsetBytes:v,vertexCount:g,rgba:b}])}else m=d,p=[{vertexOffsetBytes:0,vertexCount:g,rgba:b}];const y=m.byteLength,x=Math.max(4,y);if(!f||f.size<x){if(f)try{f.destroy()}catch{}f=e.createBuffer({label:"gridRenderer/vertexBuffer",size:x,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST})}e.queue.writeBuffer(f,0,m.buffer,0,m.byteLength);const w=(()=>{const e=new ArrayBuffer(64);return new Float32Array(e).set([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),e})();ke(e,l,w)},render:t=>{if(h(),0!==p.length&&f){t.setPipeline(d),t.setBindGroup(0,c);for(const n of p){const i=new ArrayBuffer(16);new Float32Array(i).set([n.rgba[0],n.rgba[1],n.rgba[2],n.rgba[3]]),ke(e,u,i),t.setVertexBuffer(0,f,n.vertexOffsetBytes),t.draw(n.vertexCount)}}},dispose:()=>{if(!n){n=!0;try{l.destroy()}catch{}try{u.destroy()}catch{}if(f)try{f.destroy()}catch{}f=null,m=null,p=[]}}}}(a,{targetFormat:b,sampleCount:4,pipelineCache:v}),rt=Ve(a,{targetFormat:b,pipelineCache:v}),ot=Ve(a,{targetFormat:b,pipelineCache:v}),at=Wt(a,{targetFormat:b,pipelineCache:v});at.setVisible(!1);const st=function(e,t){let n=!1,i=!0;const r=(null==t?void 0:t.targetFormat)??"bgra8unorm",o=(null==t?void 0:t.sampleCount)??1,a=Number.isFinite(o)?Math.max(1,Math.floor(o)):1,s=null==t?void 0:t.pipelineCache,l=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),u=Ue(e,48,{label:"highlightRenderer/uniforms"}),c=e.createBindGroup({layout:l,entries:[{binding:0,resource:{buffer:u}}]}),d=Te(e,{label:"highlightRenderer/pipeline",bindGroupLayouts:[l],vertex:{code:Ot,label:"highlight.wgsl"},fragment:{code:Ot,label:"highlight.wgsl",formats:r,blend:{color:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}}},primitive:{topology:"triangle-list",cullMode:"none"},multisample:{count:a}},s);let f=0,m=0,p={x:0,y:0,w:0,h:0},h=!1;const g=()=>{if(n)throw new Error("HighlightRenderer is disposed.")};return{prepare:(t,n,i)=>{if(g(),!Number.isFinite(t.centerDeviceX)||!Number.isFinite(t.centerDeviceY))throw new Error("HighlightRenderer.prepare: point center must be finite.");if(!Number.isFinite(t.canvasWidth)||!Number.isFinite(t.canvasHeight)||t.canvasWidth<=0||t.canvasHeight<=0)throw new Error("HighlightRenderer.prepare: canvasWidth/canvasHeight must be positive finite numbers.");if(!(e=>Number.isFinite(e.x)&&Number.isFinite(e.y)&&Number.isFinite(e.w)&&Number.isFinite(e.h))(t.scissor))throw new Error("HighlightRenderer.prepare: scissor must be finite.");if(!Number.isFinite(i)||i<0)throw new Error("HighlightRenderer.prepare: size must be a finite non-negative number.");const r=t.devicePixelRatio,o=i*(Number.isFinite(r)&&r>0?r:1),a=Math.max(1,1.5*o),s=Math.max(1,Math.round(Math.max(2,.25*a))),l=W(n)??_t,c=(e=>{const t=Number.isFinite(1.25)?1.25:1;return[Yt(e[0]*t),Yt(e[1]*t),Yt(e[2]*t),Yt(e[3])]})(l),d=(e=>.2126*e[0]+.7152*e[1]+.0722*e[2])(l)>.7?[0,0,0,.9]:[1,1,1,.9],b=new ArrayBuffer(48);new Float32Array(b).set([t.centerDeviceX,t.centerDeviceY,a,s,c[0],c[1],c[2],1,d[0],d[1],d[2],d[3]]),ke(e,u,b),f=t.canvasWidth,m=t.canvasHeight;const v=$t(Math.floor(t.scissor.x),0,Math.max(0,t.canvasWidth)),y=$t(Math.floor(t.scissor.y),0,Math.max(0,t.canvasHeight)),x=$t(Math.ceil(t.scissor.x+t.scissor.w),0,Math.max(0,t.canvasWidth)),w=$t(Math.ceil(t.scissor.y+t.scissor.h),0,Math.max(0,t.canvasHeight));p={x:v,y,w:Math.max(0,x-v),h:Math.max(0,w-y)},h=!0},render:e=>{g(),i&&h&&(f<=0||m<=0||0===p.w||0===p.h||(e.setScissorRect(p.x,p.y,p.w,p.h),e.setPipeline(d),e.setBindGroup(0,c),e.draw(3),e.setScissorRect(0,0,f,m)))},setVisible:e=>{g(),i=!!e},dispose:()=>{if(!n){n=!0;try{u.destroy()}catch{}f=0,m=0,p={x:0,y:0,w:0,h:0},h=!1}}}}(a,{targetFormat:b,pipelineCache:v});st.setVisible(!1);const lt=qt(a,{targetFormat:b,sampleCount:4,pipelineCache:v}),ct=Kt(a,{targetFormat:b,sampleCount:4,pipelineCache:v}),dt=qt(a,{targetFormat:b,sampleCount:4,pipelineCache:v}),ft=Kt(a,{targetFormat:b,sampleCount:4,pipelineCache:v}),mt=function(e){const{device:t,targetFormat:n}=e,i={mainColorTexture:null,mainColorView:null,mainResolveTexture:null,mainResolveView:null,overlayMsaaTexture:null,overlayMsaaView:null,overlayBlitBindGroup:null,overlayTargetsWidth:0,overlayTargetsHeight:0,overlayTargetsFormat:null},r=t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d"}}]}),o=Te(t,{label:"textureManager/overlayBlitPipeline",bindGroupLayouts:[r],vertex:{code:Bt,label:"textureManager/overlayBlit.wgsl"},fragment:{code:Bt,label:"textureManager/overlayBlit.wgsl",formats:n},primitive:{topology:"triangle-list",cullMode:"none"},multisample:{count:4}},e.pipelineCache);let a=null;return{ensureTextures:function(e,o){const s=Number.isFinite(e)?Math.max(1,Math.floor(e)):1,l=Number.isFinite(o)?Math.max(1,Math.floor(o)):1;i.mainColorTexture&&i.mainResolveTexture&&i.overlayMsaaTexture&&i.overlayBlitBindGroup&&i.overlayTargetsWidth===s&&i.overlayTargetsHeight===l&&i.overlayTargetsFormat===n||(Tt(i.mainColorTexture),Tt(i.mainResolveTexture),Tt(i.overlayMsaaTexture),i.mainColorTexture=t.createTexture({label:"textureManager/mainColorTexture",size:{width:s,height:l},sampleCount:4,format:n,usage:GPUTextureUsage.RENDER_ATTACHMENT}),i.mainColorView=i.mainColorTexture.createView(),i.mainResolveTexture=t.createTexture({label:"textureManager/mainResolveTexture",size:{width:s,height:l},format:n,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),i.mainResolveView=i.mainResolveTexture.createView(),i.overlayMsaaTexture=t.createTexture({label:"textureManager/annotationOverlayMsaaTexture",size:{width:s,height:l},sampleCount:4,format:n,usage:GPUTextureUsage.RENDER_ATTACHMENT}),i.overlayMsaaView=i.overlayMsaaTexture.createView(),i.overlayBlitBindGroup=t.createBindGroup({label:"textureManager/overlayBlitBindGroup",layout:r,entries:[{binding:0,resource:i.mainResolveView}]}),i.overlayTargetsWidth=s,i.overlayTargetsHeight=l,i.overlayTargetsFormat=n,a=null)},getState:function(){return a||(a={mainColorView:i.mainColorView,mainResolveView:i.mainResolveView,overlayMsaaView:i.overlayMsaaView,overlayBlitBindGroup:i.overlayBlitBindGroup,overlayBlitPipeline:o,msaaSampleCount:4,mainSceneMsaaSampleCount:4}),a},dispose:function(){Tt(i.mainColorTexture),Tt(i.mainResolveTexture),Tt(i.overlayMsaaTexture),i.mainColorTexture=null,i.mainColorView=null,i.mainResolveTexture=null,i.mainResolveView=null,i.overlayMsaaTexture=null,i.overlayMsaaView=null,i.overlayBlitBindGroup=null,i.overlayTargetsWidth=0,i.overlayTargetsHeight=0,i.overlayTargetsFormat=null,a=null}}}({device:a,targetFormat:b,pipelineCache:v}),pt=ri(e,P),ht=$n(e.canvas)?function(e,t){let n=!1,i=t;const r={mousemove:new Set,click:new Set,mouseleave:new Set};let o=null,a=null;const s=(t,n)=>{const o=(t=>{const n=e.getBoundingClientRect();if(0===n.width||0===n.height)return null;const r=t.clientX-n.left,o=t.clientY-n.top,a=i.left,s=i.top,l=n.width-i.left-i.right,u=n.height-i.top-i.bottom,c=r-a,d=o-s;return{x:r,y:o,gridX:c,gridY:d,plotWidthCss:l,plotHeightCss:u,isInGrid:c>=0&&c<=l&&d>=0&&d<=u,originalEvent:t}})(n);if(o)for(const e of r[t])e(o)},l=e=>{o&&e.isPrimary&&e.pointerId===o.pointerId&&(o=null)},u=e=>{n||s("mousemove",e)},c=e=>{n||(l(e),s("mouseleave",e))},d=e=>{n||(l(e),s("mouseleave",e))},f=e=>{if(!n){if(a===e.pointerId)return void(a=null);l(e),s("mouseleave",e)}},m=t=>{if(n||!t.isPrimary||"mouse"===t.pointerType&&0!==t.button)return;const i=e.getBoundingClientRect();if(0!==i.width&&0!==i.height){o={pointerId:t.pointerId,startClientX:t.clientX,startClientY:t.clientY,startTimeMs:t.timeStamp};try{e.setPointerCapture(t.pointerId)}catch{}}},p=t=>{if(n||!t.isPrimary||!o||t.pointerId!==o.pointerId)return;const i=t.timeStamp-o.startTimeMs,r=t.clientX-o.startClientX,l=t.clientY-o.startClientY,u=r*r+l*l;o=null;try{e.hasPointerCapture(t.pointerId)&&(a=t.pointerId,e.releasePointerCapture(t.pointerId))}catch{}i<=500&&u<=36&&s("click",t)};return e.addEventListener("pointermove",u,{passive:!0}),e.addEventListener("pointerleave",c,{passive:!0}),e.addEventListener("pointercancel",d,{passive:!0}),e.addEventListener("lostpointercapture",f,{passive:!0}),e.addEventListener("pointerdown",m,{passive:!0}),e.addEventListener("pointerup",p,{passive:!0}),{canvas:e,on:(e,t)=>{n||r[e].add(t)},off:(e,t)=>{r[e].delete(t)},updateGridArea:e=>{i=e},dispose:()=>{n||(n=!0,o=null,a=null,e.removeEventListener("pointermove",u),e.removeEventListener("pointerleave",c),e.removeEventListener("pointercancel",d),e.removeEventListener("lostpointercapture",f),e.removeEventListener("pointerdown",m),e.removeEventListener("pointerup",p),r.mousemove.clear(),r.click.clear(),r.mouseleave.clear())}}}(e.canvas,pt):null;let gt,bt={source:"mouse",x:0,y:0,gridX:0,gridY:0,isInGrid:!1,hasPointer:!1},vt=null;const xt=new Set;let wt=null;const Mt=(e,t)=>{const n=null!==e&&Number.isFinite(e)?e:null;vt===n&&gt===t||(vt=n,gt=t,((e,t)=>{const n=Array.from(xt);for(const i of n)i(e,t)})(vt,gt))},Ft=()=>{var e;null==(e=null==n?void 0:n.onRequestRender)||e.call(n)},Nt=e=>!e||Number.isFinite(e.start)&&Number.isFinite(e.end)&&e.start<=0&&e.end>=100,Ct=()=>{null!==Ee&&(cancelAnimationFrame(Ee),Ee=null),null!==Be&&(clearTimeout(Be),Be=null),we=!1},Dt=()=>{null!==De&&(clearTimeout(De),De=null)},Ut=e=>{if(I)return;const t=(null==e?void 0:e.requestRenderAfter)??!0,n=(()=>{var e;if(0===We.size)return!1;_e.clear();const t=(null==jt?void 0:jt.getRange())??null,n=Nt(t),i=!0===P.autoScroll&&null!=jt&&null==P.xAxis.min&&null==P.xAxis.max,r=xi(P,he),o=t?Mi(r,t):null;let a=!1;for(const[e,t]of We){if(0===t.length)continue;const i=P.series[e];if(i&&"pie"!==i.type){if(a=!0,"candlestick"===i.type){let n=pe[e];if(!n){const t=i.rawData??i.data;n=0===t.length?[]:t.slice(),pe[e]=n,he[e]=i.rawBounds??null}for(const i of t){const t=i;n.push(...t),he[e]=ti(he[e],t)}}else{let r=pe[e];if(!r){const t=i.rawData??i.data;r=Qn(t),pe[e]=r,he[e]=i.rawBounds??f(t)}const o="line"===i.type&&"none"===i.sampling&&n&&"fullRawLine"===Oe[e];for(const n of t){const t=n;if(o)try{nt.appendSeries(e,t),_e.add(e)}catch{}else"line"===i.type&&"none"!==i.sampling&&!me.has(e)&&(me.add(e),console.warn(`[ChartGPU] appendData() on series ${e} with sampling='${i.sampling}' causes full buffer re-upload every frame. For optimal streaming performance, use sampling='none'. See docs/internal/INCREMENTAL_APPEND_OPTIMIZATION.md for details.`));const a=s(t),d=r.x.length;for(let e=0;e<a;e++){r.x.push(l(t,e)),r.y.push(u(t,e));const n=c(t,e);void 0!==n?(r.size||(r.size=new Array(d+e)),r.size.push(n)):r.size&&r.size.push(void 0)}he[e]=ei(he[e],t)}}xe[e]=null}}if(We.clear(),!a)return!1;if(i&&(Ht="auto-scroll"),jt){const t=ln(),n=jt;null==(e=n.setSpanConstraints)||e.call(n,t.minSpan,t.maxSpan)}if(i&&t&&o){Ht="auto-scroll";const e=t;if(e.end>=99.5){const t=e.end-e.start,n=jt;n.setRangeAnchored?n.setRangeAnchored(100-t,100,"end"):jt.setRange(100-t,100)}else{const e=xi(P,he),t=e.max-e.min;if(Number.isFinite(t)&&t>0){const n=(o.min-e.min)/t*100,i=(o.max-e.min)/t*100,r=Math.max(0,Math.min(100,n)),a=Math.max(0,Math.min(100,i));jt.setRange(r,a)}}}i&&(Ht=void 0),fn();const d=(null==jt?void 0:jt.getRange())??null;return(null==d||Nt(d))&&(be=ge,ye()),!0})(),i=(null==jt?void 0:jt.getRange())??null,r=Nt(i),o=null!=i&&!r;let a=!1;Ge?(Ge=!1,Dt(),!i||r?(be=ge,ye()):mn(),a=!0):n&&o&&(Ge=!1,Dt(),mn(),a=!0),(n||a)&&t&&Ft()},kt=e=>{I||we||(null!==Ee&&(cancelAnimationFrame(Ee),Ee=null),null!==Be&&(clearTimeout(Be),Be=null),we=!0,Ee=requestAnimationFrame(()=>{Ee=null,I?Ct():(null!==Be&&(clearTimeout(Be),Be=null),we=!1,Ut())}),Be=(typeof self<"u"?self:window).setTimeout(()=>{I?Ct():we&&(null!==Ee&&(cancelAnimationFrame(Ee),Ee=null),we=!1,Be=null,Ut())},16))},Gt=(e,t)=>{let n,i;const r=e.getBoundingClientRect();if(!(r.width>0&&r.height>0))return null;n=r.width,i=r.height;const o=n-t.left-t.right,a=i-t.top-t.bottom;return o>0&&a>0?{plotWidthCss:o,plotHeightCss:a}:null},zt=(e,t,n)=>{const i=P.series[e],{x:r,y:o}=(e=>Kn(e)?{x:e[0],y:e[1]}:{x:e.x,y:e.y})(n);return{seriesName:(null==i?void 0:i.name)??"",seriesIndex:e,dataIndex:t,value:[r,o],color:(null==i?void 0:i.color)??"#888"}},Vt=(e,t,n)=>{const i=P.series[e];return fi(n)?{seriesName:(null==i?void 0:i.name)??"",seriesIndex:e,dataIndex:t,value:[n[0],n[1],n[2],n[3],n[4]],color:(null==i?void 0:i.color)??"#888"}:{seriesName:(null==i?void 0:i.name)??"",seriesIndex:e,dataIndex:t,value:[n.timestamp,n.open,n.close,n.low,n.high],color:(null==i?void 0:i.color)??"#888"}},Lt=(e,t,n,i,r)=>{const o=.5*Math.min(i,r);if(!(o>0))return null;for(let a=e.length-1;a>=0;a--){const s=e[a];if("pie"!==s.type||!1===s.visible)continue;const l=s,u=vn(t,n,{seriesIndex:a,series:l},pi(l.center,i,r),hi(l.radius,o));if(u)return u}return null},Xt=(e,t,n,i)=>{for(let r=e.length-1;r>=0;r--){const o=e[r];if("candlestick"!==o.type||!1===o.visible)continue;const a=o,s=dn(a,a.data,i.xScale,i.plotWidthCss),l=hn([a],t,n,i.xScale,i.yScale,s);if(l)return{params:Vt(r,l.dataIndex,l.point),match:{point:l.point},seriesIndex:r}}return null};ht&&(ht.on("mousemove",e=>{if(bt={source:"mouse",x:e.x,y:e.y,gridX:e.gridX,gridY:e.gridY,isInGrid:e.isInGrid,hasPointer:!0},e.isInGrid&&wt){const t=wt.xScale.invert(e.gridX);Mt(Number.isFinite(t)?t:null,"mouse")}else e.isInGrid||Mt(null,"mouse");at.setVisible(e.isInGrid),Ft()}),ht.on("mouseleave",e=>{"mouse"===bt.source&&(bt={...bt,isInGrid:!1,hasPointer:!1},at.setVisible(!1),Ke(),Mt(null,"mouse"),Ft())}));let Ht,jt=null,Zt=null,Jt=null,rn=null;const on=new Set,an=e=>Math.min(100,Math.max(0,e)),ln=()=>{const e=(e=>{let t=null,n=null;const i=e.dataZoom??[];for(const e of i)if(e&&("inside"===e.type||"slider"===e.type)){if(Number.isFinite(e.minSpan)){const n=an(e.minSpan);t=null==t?n:Math.max(t,n)}if(Number.isFinite(e.maxSpan)){const t=an(e.maxSpan);n=null==n?t:Math.min(n,t)}}return{minSpan:t??void 0,maxSpan:n??void 0}})(P),t=(()=>{if("category"===P.xAxis.type)return null;let e=0;for(let t=0;t<P.series.length;t++){const n=P.series[t];if("pie"===n.type)continue;if("candlestick"===n.type){const i=pe[t]??n.rawData??n.data;e=Math.max(e,i.length);continue}const i=pe[t]??null,r=i?i.x.length:s(n.rawData??n.data);e=Math.max(e,r)}if(e<2)return null;const t=100/(e-1);return Number.isFinite(t)?an(t):null})();return{minSpan:Number.isFinite(e.minSpan)?an(e.minSpan):t??.5,maxSpan:Number.isFinite(e.maxSpan)?an(e.maxSpan):100}},un=()=>{var e;const t=(e=>{var t,n;const i=null==(t=e.dataZoom)?void 0:t.find(e=>"inside"===(null==e?void 0:e.type)),r=null==(n=e.dataZoom)?void 0:n.find(e=>"slider"===(null==e?void 0:e.type)),o=i??r;return o?{start:Number.isFinite(o.start)?o.start:0,end:Number.isFinite(o.end)?o.end:100,hasInside:!!i}:null})(P);if(!t)return null==Zt||Zt.dispose(),Zt=null,null==Jt||Jt(),Jt=null,jt=null,void(rn=null);if(jt){const n=ln(),i=jt;null==(e=i.setSpanConstraints)||e.call(i,n.minSpan,n.maxSpan),(null==rn||rn.start!==t.start||rn.end!==t.end)&&(jt.setRange(t.start,t.end),rn={start:t.start,end:t.end})}else{const e=ln();jt=function(e,t,n){let i=0,r=100,o=null;const a=new Set;let s=(()=>{const e=Number.isFinite(null==n?void 0:n.minSpan)?n.minSpan:.5;return en(Number.isFinite(e)?e:0,0,100)})(),l=(()=>{const e=Number.isFinite(null==n?void 0:n.maxSpan)?n.maxSpan:100;return en(Number.isFinite(e)?e:100,0,100)})(),u=Math.min(s,l),c=Math.max(s,l);const d=(e,t,n)=>{if(n){if("string"==typeof n)switch(n){case"start":return{center:e,ratio:0};case"end":return{center:t,ratio:1};case"center":return{center:.5*(e+t),ratio:.5}}if(n&&Number.isFinite(n.center)&&Number.isFinite(n.ratio))return{center:n.center,ratio:n.ratio}}},f=(e,t,n)=>{if(!Number.isFinite(e)||!Number.isFinite(t))return;let s=e,l=t;if(s>l){const e=s;s=l,l=e}let d=l-s;if(!Number.isFinite(d)||d<0)return;const f=en(d,u,c);if(f!==d&&(s=(null!=n&&n.anchor&&Number.isFinite(n.anchor.center)?en(n.anchor.center,0,100):.5*(s+l))-(null!=n&&n.anchor&&Number.isFinite(n.anchor.ratio)?tn(n.anchor.ratio):.5)*f,l=s+f,d=f),d>100&&(s=0,l=100,d=100),s<0){const e=-s;s+=e,l+=e}if(l>100){const e=l-100;s-=e,l-=e}s=en(s,0,100),l=en(l,0,100),s=nn(s),l=nn(l),(s!==i||l!==r)&&(i=s,r=l,!1!==(null==n?void 0:n.emit)&&(()=>{const e={start:i,end:r};if(null!==o&&o.start===e.start&&o.end===e.end)return;o=(e=>({start:e.start,end:e.end}))(e);const t=Array.from(a);for(const e of t)e({start:i,end:r})})())};return f(e,t,{emit:!1}),{getRange:()=>({start:i,end:r}),setRange:(e,t)=>{f(e,t)},setRangeAnchored:(e,t,n)=>{f(e,t,{anchor:d(e,t,n)})},setSpanConstraints:(e,t)=>{const n="number"==typeof e&&Number.isFinite(e)?en(e,0,100):s,o="number"==typeof t&&Number.isFinite(t)?en(t,0,100):l;if(n===s&&o===l)return;s=n,l=o,u=Math.min(s,l),c=Math.max(s,l);const a=1e-6;f(i,r,{anchor:d(i,r,r>=100-a?"end":i<=0+a?"start":"center")})},zoomIn:(e,t)=>{if(!Number.isFinite(e)||!Number.isFinite(t)||t<=1)return;const n=en(e,0,100),o=r-i,a=0===o?.5:tn((n-i)/o),s=o/t,l=n-a*s;f(l,l+s,{anchor:{center:n,ratio:a}})},zoomOut:(e,t)=>{if(!Number.isFinite(e)||!Number.isFinite(t)||t<=1)return;const n=en(e,0,100),o=r-i,a=0===o?.5:tn((n-i)/o),s=o*t,l=n-a*s;f(l,l+s,{anchor:{center:n,ratio:a}})},pan:e=>{Number.isFinite(e)&&f(i+e,r+e)},onChange:e=>(a.add(e),()=>{a.delete(e)})}}(t.start,t.end,e),rn={start:t.start,end:t.end},Jt=jt.onChange(e=>{ze=!0,Ft(),I||(Dt(),Ge=!1,De=(typeof self<"u"?self:window).setTimeout(()=>{De=null,!I&&(Ge=!0,kt())},100));const t=Ht;((e,t)=>{const n=Array.from(on);for(const i of n)i(e,t)})({start:e.start,end:e.end},t),Ht=void 0})}t.hasInside&&ht?Zt||(Zt=function(e,t){let n=!1,i=!1,r=null,o=!1,a=0;const s=()=>{o=!1,a=0},l=e=>{if(r=e,!i)return;const n=e.originalEvent;if(!e.isInGrid||!(e=>"mouse"===e.pointerType&&e.shiftKey&&!!(1&e.buttons))(n)&&!(e=>"mouse"===e.pointerType&&!!(4&e.buttons))(n))return void s();const l=e.plotWidthCss;if(!(l>0&&Number.isFinite(l)))return void s();if(!o)return o=!0,void(a=e.gridX);const u=e.gridX-a;if(a=e.gridX,!Number.isFinite(u)||0===u)return;const{start:c,end:d}=t.getRange(),f=d-c;if(!Number.isFinite(f)||0===f)return;const m=-u/l*f;!Number.isFinite(m)||0===m||t.pan(m)},u=e=>{r=null,s()},c=e=>{if(!i||n)return;const o=r;if(!o||!o.isInGrid)return;const a=o.plotWidthCss,s=o.plotHeightCss;if(!(a>0&&s>0))return;const l=((e,t)=>{const n=e.deltaY;if(!Number.isFinite(n)||0===n)return 0;switch(e.deltaMode){case WheelEvent.DOM_DELTA_PIXEL:return n;case WheelEvent.DOM_DELTA_LINE:return 16*n;case WheelEvent.DOM_DELTA_PAGE:return n*(Number.isFinite(t)&&t>0?t:800);default:return n}})(e,s),u=((e,t)=>{const n=e.deltaX;if(!Number.isFinite(n)||0===n)return 0;switch(e.deltaMode){case WheelEvent.DOM_DELTA_PIXEL:return n;case WheelEvent.DOM_DELTA_LINE:return 16*n;case WheelEvent.DOM_DELTA_PAGE:return n*(Number.isFinite(t)&&t>0?t:800);default:return n}})(e,a);if(Math.abs(u)>Math.abs(l)&&0!==u){const{start:n,end:i}=t.getRange(),r=i-n;if(!Number.isFinite(r)||0===r)return;const o=u/a*r;if(!Number.isFinite(o)||0===o)return;return e.preventDefault(),void t.pan(o)}if(0===l)return;const c=(e=>{const t=Math.abs(e);if(!Number.isFinite(t)||0===t)return 1;const n=Math.min(t,200);return Math.exp(.002*n)})(l);if(!(c>1))return;const{start:d,end:f}=t.getRange(),m=f-d;if(!Number.isFinite(m)||0===m)return;const p=Qt(o.gridX/a,0,1),h=Qt(d+p*m,0,100);e.preventDefault(),l<0?t.zoomIn(h,c):t.zoomOut(h,c)},d=()=>{n||!i||(i=!1,e.off("mousemove",l),e.off("mouseleave",u),e.canvas.removeEventListener("wheel",c),r=null,s())};return{enable:()=>{n||i||(i=!0,e.on("mousemove",l),e.on("mouseleave",u),e.canvas.addEventListener("wheel",c,{passive:!1}))},disable:d,dispose:()=>{n||(d(),n=!0)}}}(ht,jt),Zt.enable()):(null==Zt||Zt.dispose(),Zt=null)},cn=()=>{const e=P.series.length;pe=new Array(e).fill(null),he=new Array(e).fill(null),We.clear();for(let t=0;t<e;t++){const e=P.series[t];if("pie"===e.type)continue;if("candlestick"===e.type){const n=e.rawData??e.data,i=0===n.length?[]:n.slice();pe[t]=i,he[t]=e.rawBounds??null;continue}const n=e.rawData??e.data,i=Qn(n);pe[t]=i,he[t]=e.rawBounds??f(n)}},fn=()=>{const e=new Array(P.series.length);for(let t=0;t<P.series.length;t++){const n=P.series[t];if("pie"===n.type){e[t]=n;continue}if("candlestick"===n.type){const i=pe[t]??n.rawData??n.data,r=he[t]??n.rawBounds??void 0,o="ohlc"===n.sampling&&i.length>n.samplingThreshold?F(i,n.samplingThreshold):i;e[t]={...n,rawData:i,rawBounds:r,data:o};continue}const i=pe[t]??n.rawData??n.data,r=he[t]??n.rawBounds??void 0,o=M(i,n.sampling,n.samplingThreshold);e[t]={...n,rawData:i,rawBounds:r,data:o}}ge=e};function mn(){const e=(null==jt?void 0:jt.getRange())??null,t=xi(P,he),n=Mi(t,e),i=.1*(n.max-n.min),r=n.min-i,o=n.max+i,a=2e5,s=Math.max(.001,Math.min(1,n.spanFraction)),l=new Array(ge.length);for(let t=0;t<ge.length;t++){const i=ge[t];if("pie"===i.type){l[t]=i;continue}if(null==e||Number.isFinite(e.start)&&Number.isFinite(e.end)&&e.start<=0&&e.end>=100){l[t]=i;continue}if("candlestick"===i.type){const e=U(pe[t]??i.rawData??i.data,r,o),u=i.sampling,c=i.samplingThreshold,d=Number.isFinite(c)?Math.max(1,0|c):1,f=Math.min(a,Math.max(2,32*d)),m=si(Math.round(d/s),2,f),p="ohlc"===u&&e.length>m?F(e,m):e;xe[t]={data:p,cachedRange:{min:r,max:o},timestamp:Date.now()};const h=U(p,n.min,n.max);l[t]={...i,data:h};continue}const u=T(pe[t]??i.rawData??i.data,r,o),c=i.sampling,d=i.samplingThreshold,f=Number.isFinite(d)?Math.max(1,0|d):1,m=Math.min(a,Math.max(2,32*f)),p=M(u,c,si(Math.round(f/s),2,m));xe[t]={data:p,cachedRange:{min:r,max:o},timestamp:Date.now()};const h=T(p,n.min,n.max);l[t]={...i,data:h}}be=l,ye()}cn(),fn(),un(),mn(),xe=new Array(P.series.length).fill(null);const pn=function(e){const{device:t,targetFormat:n,pipelineCache:i,sampleCount:r}=e,o=[],a=[],c=[],d=[],f=[],m=[],p=function(e,t){let n=!1;const i=(null==t?void 0:t.targetFormat)??"bgra8unorm",r=null==t?void 0:t.sampleCount,o=Number.isFinite(r)?Math.max(1,Math.floor(r)):1,a=null==t?void 0:t.pipelineCache,c=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),d=Ue(e,64,{label:"barRenderer/vsUniforms"});ke(e,d,(()=>{const e=new ArrayBuffer(64);return new Float32Array(e).set([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),e})());const f=e.createBindGroup({layout:c,entries:[{binding:0,resource:{buffer:d}}]}),m=Te(e,{label:"barRenderer/pipeline",bindGroupLayouts:[c],vertex:{code:At,label:"bar.wgsl",buffers:[{arrayStride:32,stepMode:"instance",attributes:[{shaderLocation:0,format:"float32x4",offset:0},{shaderLocation:1,format:"float32x4",offset:16}]}]},fragment:{code:At,label:"bar.wgsl",formats:i,blend:{color:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}}},primitive:{topology:"triangle-list",cullMode:"none"},multisample:{count:o}},a);let p=null,h=0,g=new ArrayBuffer(0),b=new Float32Array(g);const v=[],y=()=>{if(n)throw new Error("BarRenderer is disposed.")},x=e=>{let t=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;for(let i=0;i<e.length;i++){const r=e[i].data,o=s(r);for(let e=0;e<o;e++){const i=u(r,e);Number.isFinite(i)&&(i<t&&(t=i),i>n&&(n=i))}}return!Number.isFinite(t)||!Number.isFinite(n)||t<=0&&0<=n?0:Math.abs(t)<Math.abs(n)?t:n};return{prepare:(t,n,i,r,o)=>{if(y(),0===t.length)return void(h=0);const a=(e=>{const t=e.devicePixelRatio;if(!(t>0))return null;const n=e.canvasWidth/t,i=e.canvasHeight/t,r=n-e.left-e.right,o=i-e.top-e.bottom;return r>0&&o>0?{plotWidthCss:r,plotHeightCss:o}:null})(o);if(!a)return void(h=0);const c=(e=>{const{left:t,right:n,top:i,bottom:r,canvasWidth:o,canvasHeight:a,devicePixelRatio:s}=e;return{left:t*s/o*2-1,right:(o-n*s)/o*2-1,top:1-i*s/a*2,bottom:1-(a-r*s)/a*2}})(o),d=c.right-c.left,f=a.plotWidthCss>0?d/a.plotWidthCss:0,m=new Map,w=new Array(t.length);let M=0;for(let e=0;e<t.length;e++){const n=Et(t[e].stack);if(""!==n){const t=m.get(n);if(void 0!==t)w[e]=t;else{const t=M++;m.set(n,t),w[e]=t}}else w[e]=M++}M=Math.max(1,M);const F=(e=>{v.length=0;for(let t=0;t<e.length;t++){const n=e[t].data,i=s(n);for(let e=0;e<i;e++){const t=l(n,e);Number.isFinite(t)&&v.push(t)}}if(v.length<2)return 1;v.sort((e,t)=>e-t);let t=Number.POSITIVE_INFINITY;for(let e=1;e<v.length;e++){const n=v[e]-v[e-1];n>0&&n<t&&(t=n)}return Number.isFinite(t)&&t>0?t:1})(t),N=(e=>{let t,n,i;for(let r=0;r<e.length;r++){const o=e[r];void 0===t&&void 0!==o.barWidth&&(t=o.barWidth),void 0===n&&void 0!==o.barGap&&(n=o.barGap),void 0===i&&void 0!==o.barCategoryGap&&(i=o.barCategoryGap)}return{barWidth:t,barGap:n,barCategoryGap:i}})(t),C=It(N.barGap??.01),S=It(N.barCategoryGap??.2);let A=1;for(let e=0;e<t.length;e++){const n=s(t[e].data);A=Math.max(A,Math.floor(n))}const I=((e,t,n,i)=>{if(Number.isFinite(t)&&t>0){const n=e.scale(0),i=e.scale(0+t),r=Math.abs(i-n);if(Number.isFinite(r)&&r>0)return r}const r=Math.abs(n.right-n.left);return r>0?r/Math.max(1,Math.floor(i)):0})(i,F,c,A),P=Math.max(0,I*(1-S)),R=M+Math.max(0,M-1)*C,E=R>0?P/R:0;let B=0;const T=N.barWidth;if("number"==typeof T)B=Math.max(0,T)*f,B=Math.min(B,E);else if("string"==typeof T){const e=(e=>{const t=e.trim().match(/^(\d+(?:\.\d+)?)%$/);if(!t)return null;const n=Number(t[1])/100;return Number.isFinite(n)?n:null})(T);B=null==e?0:E*It(e)}B>0||(B=E);const D=B*C,U=M*B+Math.max(0,M-1)*D;let k=((e,t,n)=>{const i=t.invert(n.bottom),r=t.invert(n.top),o=Math.min(i,r),a=Math.max(i,r);return Number.isFinite(o)&&Number.isFinite(a)?o<=0&&0<=a?0:o>0?o:a<0?a:x(e):x(e)})(t,r,c),G=r.scale(k);if(!Number.isFinite(G)){const e=x(t);if(k=e,G=r.scale(e),Number.isFinite(G)||(k=0,G=r.scale(0)),!Number.isFinite(G))return void(h=0)}let z=0;for(let e=0;e<t.length;e++)z+=Math.max(0,s(t[e].data));(e=>{if(e<=b.length)return;const t=Math.max(8,Rt(e));g=new ArrayBuffer(4*t),b=new Float32Array(g)})(8*z);const V=b;let L=0;const W=new Map;for(let e=0;e<t.length;e++){const n=t[e],o=n.data,[a,d,f,m]=Pt(n.color),p=Et(n.stack),h=w[e]??0,g=s(o);for(let e=0;e<g;e++){const t=l(o,e),n=u(o,e),s=i.scale(t);if(!Number.isFinite(s)||!Number.isFinite(n))continue;const g=s-U/2+h*(B+D);let b=G,v=0;if(""!==p){let e,i=W.get(p);i||(i=new Map,W.set(p,i)),e=Number.isFinite(I)&&I>0&&Number.isFinite(s)?Math.round((s-c.left)/I):Number.isFinite(F)&&F>0?Math.round(t/F):Math.round(1e6*t);let o,a,l=i.get(e);l||(l={posSum:k,negSum:k},i.set(e,l)),n>=0?(o=l.posSum,a=o+n,l.posSum=a):(o=l.negSum,a=o+n,l.negSum=a);const u=r.scale(o),d=r.scale(a);if(!Number.isFinite(u)||!Number.isFinite(d))continue;b=u,v=d-u}else{const e=r.scale(n);if(!Number.isFinite(e))continue;v=e-G}V[L+0]=g,V[L+1]=b,V[L+2]=B,V[L+3]=v,V[L+4]=a,V[L+5]=d,V[L+6]=f,V[L+7]=m,L+=8}}h=L/8;const O=Math.max(4,32*h);if(!p||p.size<O){const t=Math.max(Math.max(4,Rt(O)),p?p.size:0);if(p)try{p.destroy()}catch{}p=e.createBuffer({label:"barRenderer/instanceBuffer",size:t,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST})}h>0&&e.queue.writeBuffer(p,0,g,0,32*h)},render:e=>{y(),p&&0!==h&&(e.setPipeline(m),e.setBindGroup(0,f),e.setVertexBuffer(0,p),e.draw(6,h))},dispose:()=>{if(!n){if(n=!0,p)try{p.destroy()}catch{}p=null,h=0;try{d.destroy()}catch{}}}}}(t,{targetFormat:n,pipelineCache:i,sampleCount:r});let h=null;return{ensureAreaRendererCount:function(e){for(;o.length>e;){const e=o.pop();null==e||e.dispose()}for(;o.length<e;)o.push(Ye(t,{targetFormat:n,pipelineCache:i,sampleCount:r}))},ensureLineRendererCount:function(e){for(;a.length>e;){const e=a.pop();null==e||e.dispose()}for(;a.length<e;)a.push(qe(t,{targetFormat:n,pipelineCache:i,sampleCount:r}))},ensureScatterRendererCount:function(e){for(;c.length>e;){const e=c.pop();null==e||e.dispose()}for(;c.length<e;)c.push(Qe(t,{targetFormat:n,pipelineCache:i,sampleCount:r}))},ensureScatterDensityRendererCount:function(e){for(;d.length>e;){const e=d.pop();null==e||e.dispose()}for(;d.length<e;)d.push(ut(t,{targetFormat:n,pipelineCache:i,sampleCount:r}))},ensurePieRendererCount:function(e){for(;f.length>e;){const e=f.pop();null==e||e.dispose()}for(;f.length<e;)f.push(yt(t,{targetFormat:n,pipelineCache:i,sampleCount:r}))},ensureCandlestickRendererCount:function(e){for(;m.length>e;){const e=m.pop();null==e||e.dispose()}for(;m.length<e;)m.push(St(t,{targetFormat:n,pipelineCache:i,sampleCount:r}))},getState:function(){return h||(h={areaRenderers:o,lineRenderers:a,scatterRenderers:c,scatterDensityRenderers:d,pieRenderers:f,candlestickRenderers:m,barRenderer:p}),h},dispose:function(){for(let e=0;e<o.length;e++)o[e].dispose();o.length=0;for(let e=0;e<a.length;e++)a[e].dispose();a.length=0;for(let e=0;e<c.length;e++)c[e].dispose();c.length=0;for(let e=0;e<d.length;e++)d[e].dispose();d.length=0;for(let e=0;e<f.length;e++)f[e].dispose();f.length=0;for(let e=0;e<m.length;e++)m[e].dispose();m.length=0,p.dispose()}}}({device:a,targetFormat:b,pipelineCache:v,sampleCount:4});pn.ensureAreaRendererCount(P.series.length),pn.ensureLineRendererCount(P.series.length),pn.ensureScatterRendererCount(P.series.length),pn.ensureScatterDensityRendererCount(P.series.length),pn.ensurePieRendererCount(P.series.length),pn.ensureCandlestickRendererCount(P.series.length);const gn=()=>{if(I)throw new Error("RenderCoordinator is disposed.")},bn=()=>{if(L)try{V.cancel(L)}catch{}L=null,Y=1,H=null,j()},yn=(e,t)=>e.min===t.min&&e.max===t.max,Sn=e=>{var t;gn();const n=(null==jt?void 0:jt.getRange())??null,i=(()=>{if(H&&L){try{V.update(performance.now())}catch{}return((e,t,n)=>{const i=ui(e.from.xBaseDomain,e.to.xBaseDomain,t),r=Mi(i,n),o=ui(e.from.yBaseDomain,e.to.yBaseDomain,t),a=Q(e.from.series,e.to.series,t,null);return{xBaseDomain:i,xVisibleDomain:{min:r.min,max:r.max},yBaseDomain:o,series:a}})(H,Y,n)}const e=xi(P,he),t=Mi(e,n),i=wi(P,he,ve);return{xBaseDomain:e,xVisibleDomain:{min:t.min,max:t.max},yBaseDomain:i,series:be}})();bn();const r=((e,t)=>{if(e.length!==t.length)return!0;for(let n=0;n<e.length;n++){const i=e[n],r=t[n];if(i.type!==r.type)return!0;if("pie"===i.type){const e=i,t=r;if(e.data!==t.data||e.data.length!==t.data.length)return!0}else{const e=i,t=r,n=e.rawData??e.data,o=t.rawData??t.data;if(n!==o||n.length!==o.length)return!0}}return!1})(P.series,e.series);if(P=e,r&&(ge=e.series,be=e.series,Oe=new Array(e.series.length).fill("unknown"),xe=new Array(e.series.length).fill(null),Dt(),Ge=!1,Ct(),cn()),ve=null,null==C||C.update(e.series,e.theme),fn(),un(),mn(),y){const e=!1!==(null==(t=P.tooltip)?void 0:t.show);e&&!$e&&($e=An(y),Xe=null,He=null,je=null),!e&&$e&&Ke()}else Ke();const o=e.series.length;if(pn.ensureAreaRendererCount(o),pn.ensureLineRendererCount(o),pn.ensureScatterRendererCount(o),pn.ensureScatterDensityRendererCount(o),pn.ensurePieRendererCount(o),pn.ensureCandlestickRendererCount(o),o<R)for(let e=o;e<R;e++)nt.removeSeries(e);if(R=o,!1===P.animation&&"running"===E&&(k.cancelAll(),G=null,E="done",B=1),!1===P.animation)return bn(),void Ft();const a=(null==jt?void 0:jt.getRange())??null,s=xi(P,he),l=Mi(s,a),u=wi(P,he,ve),c=be,d=!yn(i.xBaseDomain,s)||!yn(i.yBaseDomain,u);if(!z||!d&&!r)return void Ft();const f=(e=>Fi(e))(P.animation);if(!f)return;H={from:{xBaseDomain:i.xBaseDomain,xVisibleDomain:i.xVisibleDomain,yBaseDomain:i.yBaseDomain,series:i.series},to:{xBaseDomain:s,xVisibleDomain:{min:l.min,max:l.max},yBaseDomain:u,series:c}},j();const m=f.delayMs+f.durationMs;Y=0;const p=V.animate(0,1,m,e=>{const t=ai(e);if(!(m>0))return 1;const n=t*m;if(n<=f.delayMs)return 0;if(!(f.durationMs>0))return 1;const i=(n-f.delayMs)/f.durationMs;return f.easing(i)},e=>{I||L!==p||(Y=ai(e),Y<1&&Ft())},()=>{I||L!==p||(Y=1,H=null,L=null,j())});L=p,Ft()};return{setOptions:Sn,appendData:(e,t)=>{if(gn(),!Number.isFinite(e)||e<0||e>=P.series.length||!t)return;const n=P.series[e];if("pie"===n.type)return void(ce.has(e)||(ce.add(e),console.warn(`RenderCoordinator.appendData(${e}, ...): pie series are not supported by streaming append.`)));if(0===("candlestick"===n.type?t.length:s(t)))return;const i=We.get(e);i?i.push(t):We.set(e,[t]),kt()},getInteractionX:()=>vt,setInteractionX:(e,t)=>{gn();const n=null!==e&&Number.isFinite(e)?e:null;bt={...bt,source:null===n?"mouse":"sync"},Mt(n,t),null===n&&!1===bt.hasPointer&&(at.setVisible(!1),st.setVisible(!1),Je()),Ft()},onInteractionXChange:e=>(gn(),xt.add(e),()=>{xt.delete(e)}),getZoomRange:()=>(null==jt?void 0:jt.getRange())??null,setZoomRange:(e,t)=>{gn(),jt&&jt.setRange(e,t)},onZoomRangeChange:e=>(gn(),on.add(e),()=>{on.delete(e)}),render:()=>{var t,n,i;if(gn(),!e.canvasContext||!e.canvas)return;(We.size>0||Ge)&&(Ct(),Ut({requestRenderAfter:!1})),ze&&(ze=!1,function(){const e=(null==jt?void 0:jt.getRange())??null,t=xi(P,he),n=Mi(t,e);if(null==e||Number.isFinite(e.start)&&Number.isFinite(e.end)&&e.start<=0&&e.end>=100)return be=ge,void ye();const i=new Array(ge.length);for(let e=0;e<ge.length;e++){const t=ge[e];if("pie"===t.type){i[e]=t;continue}const r=xe[e];r&&n.min>=r.cachedRange.min&&n.max<=r.cachedRange.max?"candlestick"===t.type?i[e]={...t,data:U(r.data,n.min,n.max)}:i[e]={...t,data:T(r.data,n.min,n.max)}:"candlestick"===t.type?i[e]={...t,data:U(t.data,n.min,n.max)}:i[e]={...t,data:T(t.data,n.min,n.max)}}be=i,ye()}());const r=P.series.some(e=>"pie"!==e.type),o=be;if("done"!==E){const e=(e=>Fi(e))(P.animation),t=(()=>{for(let e=0;e<o.length;e++){const t=o[e];switch(t.type){case"pie":if(t.data.some(e=>"number"==typeof(null==e?void 0:e.value)&&Number.isFinite(e.value)&&e.value>0))return!0;break;case"line":case"area":case"bar":case"scatter":if(s(t.data)>0)return!0;break;case"candlestick":if(t.data.length>0)return!0;break;default:Jn(t)}}return!1})();if("pending"===E&&e&&t){const t=e.delayMs+e.durationMs,n=n=>{const i=ai(n);if(!(t>0))return 1;const r=i*t;if(r<=e.delayMs)return 0;if(!(e.durationMs>0))return 1;const o=(r-e.delayMs)/e.durationMs;return e.easing(o)};B=0,E="running",G=k.animate(0,1,t,n,e=>{I||"running"!==E||(B=ai(e),B<1&&Ft())},()=>{I||(E="done",B=1,G=null)})}k.update(performance.now())}null!==H&&L&&V.update(performance.now());const u=ri(e,P);null==ht||ht.updateGridArea(u);const c=(null==jt?void 0:jt.getRange())??null,d=H?ai(Y):1,f=H?ui(H.from.xBaseDomain,H.to.xBaseDomain,d):xi(P,he),m=H?ui(H.from.yBaseDomain,H.to.yBaseDomain,d):wi(P,he,ve),p=Mi(f,c),h=(e=>{const{left:t,right:n,top:i,bottom:r,canvasWidth:o,canvasHeight:a,devicePixelRatio:s}=e;return{left:t*s/o*2-1,right:(o-n*s)/o*2-1,top:1-i*s/a*2,bottom:1-(a-r*s)/a*2}})(u),g=(e=>{const{canvasWidth:t,canvasHeight:n,devicePixelRatio:i}=e,r=e.left*i,o=t-e.right*i,a=e.top*i,s=n-e.bottom*i,l=si(Math.floor(r),0,Math.max(0,t)),u=si(Math.floor(a),0,Math.max(0,n)),c=si(Math.ceil(o),0,Math.max(0,t)),d=si(Math.ceil(s),0,Math.max(0,n));return{x:l,y:u,w:Math.max(0,c-l),h:Math.max(0,d-u)}})(u),b=xn().domain(p.min,p.max).range(h.left,h.right),v=xn().domain(m.min,m.max).range(h.bottom,h.top),M=e.canvas,F=function(e){if(!e)return{width:0,height:0};const t=Number.isFinite(devicePixelRatio)&&devicePixelRatio>0?devicePixelRatio:1;return{width:e.width/t,height:e.height/t}}(M),C=F.width,R=F.height,j=C>0?ci(h.left,C):0,Z=C>0?ci(h.right,C):0,J=R>0?di(h.top,R):0,ce=R>0?di(h.bottom,R):0,me=Math.max(0,Z-j),pe=Math.max(0,ce-J),we=function(e){var t,n,i,r,o,a,s,l,u,c,d,f,m,p;const{annotations:h,xScale:g,yScale:b,plotBounds:v,canvasCssWidth:y,canvasCssHeight:x,theme:w,offsetX:M=0,offsetY:F=0}=e,{leftCss:N,topCss:C,widthCss:S,heightCss:A}=v,I=[],P=[],R=[],E=[],B=[];if(0===h.length||y<=0||x<=0||S<=0||A<=0)return{linesBelow:I,linesAbove:P,markersBelow:R,markersAbove:E,labels:B};for(let e=0;e<h.length;e++){const T=h[e],D=T.layer??"aboveSeries",U="belowSeries"===D?I:P,k="belowSeries"===D?R:E,G=null==(t=T.style)?void 0:t.color,z=null==(n=T.style)?void 0:n.opacity,V="number"==typeof(null==(i=T.style)?void 0:i.lineWidth)&&Number.isFinite(T.style.lineWidth)?Math.max(0,T.style.lineWidth):1,L=null==(r=T.style)?void 0:r.lineDash,W=Ne(G,z,w.textColor);switch(T.type){case"lineX":{const e=g.scale(T.x),t=$(e,y);if(!Number.isFinite(t))break;U.push({axis:"vertical",positionCssPx:t,lineWidth:V,lineDash:L,rgba:W});break}case"lineY":{const e=b.scale(T.y),t=X(e,x);if(!Number.isFinite(t))break;U.push({axis:"horizontal",positionCssPx:t,lineWidth:V,lineDash:L,rgba:W});break}case"point":{const e=g.scale(T.x),t=b.scale(T.y),n=$(e,y),i=X(t,x);if(!Number.isFinite(n)||!Number.isFinite(i))break;const r="number"==typeof(null==(o=T.marker)?void 0:o.size)&&Number.isFinite(T.marker.size)?Math.max(1,T.marker.size):6,f=Ne((null==(s=null==(a=T.marker)?void 0:a.style)?void 0:s.color)??(null==(l=T.style)?void 0:l.color),(null==(c=null==(u=T.marker)?void 0:u.style)?void 0:c.opacity)??(null==(d=T.style)?void 0:d.opacity),w.textColor);k.push({xCssPx:n,yCssPx:i,sizeCssPx:r,fillRgba:f});break}case"text":break;default:_(T)}const O=T.label;if(null==O&&"text"!==T.type)continue;let Y=null,H=null,q={name:T.id??""};switch(T.type){case"lineX":{const e=g.scale(T.x);Y=$(e,y),H=C,q={...q,x:T.x,value:T.x};break}case"lineY":{const e=b.scale(T.y);Y=N,H=X(e,x)-8,q={...q,y:T.y,value:T.y};break}case"point":{const e=g.scale(T.x),t=b.scale(T.y);Y=$(e,y),H=X(t,x),q={...q,x:T.x,y:T.y,value:T.y};break}case"text":if("data"===T.position.space){const e=g.scale(T.position.x),t=b.scale(T.position.y);Y=$(e,y),H=X(t,x),q={...q,x:T.position.x,y:T.position.y,value:T.position.y}}else Y=N+T.position.x*S,H=C+T.position.y*A,q={...q,x:T.position.x,y:T.position.y,value:T.position.y};break;default:_(T)}if(null==Y||null==H||!Number.isFinite(Y)||!Number.isFinite(H))continue;const j=200;if(Y<v.leftCss-j||Y>v.leftCss+v.widthCss+j||H<v.topCss-j||H>v.topCss+v.heightCss+j)continue;const Z=Y+((null==(f=null==O?void 0:O.offset)?void 0:f[0])??0),J=H+((null==(m=null==O?void 0:O.offset)?void 0:m[1])??0),K=(null==O?void 0:O.text)??(null!=O&&O.template?Se(O.template,q,O.decimals):O?(()=>{const e="lineX"===T.type?"x={x}":"lineY"===T.type?"y={y}":"point"===T.type?"({x}, {y})":"text"===T.type?T.text:"";return e.includes("{")?Se(e,q,O.decimals):e})():"text"===T.type?T.text:""),Q="string"==typeof K?K.trim():"";if(0===Q.length)continue;const ee=Ae(null==O?void 0:O.anchor),te=(null==(p=T.style)?void 0:p.color)??w.textColor,ne=w.fontSize,ie=null==O?void 0:O.background,re=null!=(null==ie?void 0:ie.color)?Ce(ie.color,ie.opacity??1):void 0,oe=(()=>{const e=null==ie?void 0:ie.padding;return"number"==typeof e&&Number.isFinite(e)?[e,e,e,e]:Array.isArray(e)&&4===e.length&&e.every(e=>"number"==typeof e&&Number.isFinite(e))?[e[0],e[1],e[2],e[3]]:ie?[2,4,2,4]:void 0})(),ae="number"==typeof(null==ie?void 0:ie.borderRadius)&&Number.isFinite(ie.borderRadius)?ie.borderRadius:void 0,se={text:Q,x:M+Z,y:F+J,anchor:ee,color:te,fontSize:ne,...re?{background:{backgroundColor:re,...oe?{padding:oe}:{},...null!=ae?{borderRadius:ae}:{}}}:{}};B.push(se)}return{linesBelow:I,linesAbove:P,markersBelow:R,markersAbove:E,labels:B}}({annotations:r?P.annotations??[]:[],xScale:b,yScale:v,plotBounds:{leftCss:j,rightCss:Z,topCss:J,bottomCss:ce,widthCss:me,heightCss:pe},canvasCssWidth:C,canvasCssHeight:R,theme:P.theme}),Re=we.linesBelow.length+we.linesAbove.length>0?[...we.linesBelow,...we.linesAbove]:[],Ee=we.markersBelow.length+we.markersAbove.length>0?[...we.markersBelow,...we.markersAbove]:[],Be=we.linesBelow.length,Te=we.linesAbove.length,De=we.markersBelow.length,Ue=we.markersAbove.length,ke=function(e){return e?e.clientWidth:0}(e.canvas),Ve=Math.abs(p.max-p.min);let Le=5,Ye=[];if("time"===P.xAxis.type){const e=(e=>{const{axisMin:t,axisMax:n,xScale:i,plotClipLeft:r,plotClipRight:o,canvasCssWidth:a,visibleRangeMs:s,measureCtx:l,measureCache:u,fontSize:c,fontFamily:d}=e,f=jn(t)??i.invert(r),m=jn(n)??i.invert(o);if(!l||a<=0)return{tickCount:5,tickValues:yi(f,m,5)};l.font=`${c}px ${d}`,u&&u.size>2e3&&u.clear();const p=u?`${c}px ${d}@@`:null;for(let e=9;e>=1;e--){const t=yi(f,m,e);let n=Number.NEGATIVE_INFINITY,r=!0;for(let o=0;o<t.length;o++){const c=t[o],d=vi(c,s);if(null==d)continue;const f=(()=>{if(!p)return l.measureText(d).width;const e=p+d,t=u.get(e);if(null!=t)return t;const n=l.measureText(d).width;return u.set(e,n),n})(),m=i.scale(c),h=ci(m,a),g=1===e?"middle":0===o?"start":o===t.length-1?"end":"middle",b="start"===g?h+f:"end"===g?h:h+.5*f;if(("start"===g?h:"end"===g?h-f:h-.5*f)<n+6){r=!1;break}n=b}if(r)return{tickCount:e,tickValues:t}}return{tickCount:1,tickValues:yi(f,m,1)}})({axisMin:jn(P.xAxis.min),axisMax:jn(P.xAxis.max),xScale:b,plotClipLeft:h.left,plotClipRight:h.right,canvasCssWidth:ke,visibleRangeMs:Ve,measureCtx:S,measureCache:A??void 0,fontSize:P.theme.fontSize,fontFamily:P.theme.fontFamily||"sans-serif"});Le=e.tickCount,Ye=e.tickValues}else{const e=Zn(P.xAxis.min)??b.invert(h.left),t=Zn(P.xAxis.max)??b.invert(h.right);Ye=yi(e,t,Le)}const $e=((t,n)=>{const i=e.canvas;if(!i)return null;const r=Gt(i,t);return r?{xScale:xn().domain(n.xDomain.min,n.xDomain.max).range(0,r.plotWidthCss),yScale:xn().domain(n.yDomain.min,n.yDomain.max).range(r.plotHeightCss,0),plotWidthCss:r.plotWidthCss,plotHeightCss:r.plotHeightCss}:null})(u,{xDomain:{min:p.min,max:p.max},yDomain:m});wt=$e;const qe=H&&d<1?Q(H.from.series,H.to.series,d,q):be;if("mouse"===bt.source&&bt.hasPointer&&bt.isInGrid&&$e){const e=$e.xScale.invert(bt.gridX);Mt(Number.isFinite(e)?e:null,"mouse")}let Je=bt;if("sync"===bt.source)if(null!==vt&&$e){const e=$e.xScale.scale(vt),t=.5*$e.plotHeightCss,n=Number.isFinite(e)&&Number.isFinite(t)&&e>=0&&e<=$e.plotWidthCss&&t>=0&&t<=$e.plotHeightCss;Je={source:"sync",gridX:Number.isFinite(e)?e:0,gridY:Number.isFinite(t)?t:0,x:u.left+(Number.isFinite(e)?e:0),y:u.top+(Number.isFinite(t)?t:0),isInGrid:n,hasPointer:n}}else Je={...bt,hasPointer:!1,isInGrid:!1};if(Fe({gridRenderer:it,xAxisRenderer:rt,yAxisRenderer:ot,crosshairRenderer:at,highlightRenderer:st},{currentOptions:P,xScale:b,yScale:v,gridArea:u,xTickCount:Le,hasCartesianSeries:r,effectivePointer:Je,interactionScales:$e,seriesForRender:qe,withAlpha:oi}),Je.hasPointer&&Je.isInGrid&&!1!==(null==(t=P.tooltip)?void 0:t.show)){const t=e.canvas;if($e&&t&&$n(t)){const e=null==(n=P.tooltip)?void 0:n.formatter,r=(null==(i=P.tooltip)?void 0:i.trigger)??"item",o=t.offsetLeft+Je.x,a=t.offsetTop+Je.y;if("sync"===Je.source){const t=sn(qe,Je.gridX,$e.xScale);if(0===t.length)Ke();else if("axis"===r){const n=t.map(e=>zt(e.seriesIndex,e.dataIndex,e.point)),i=e?e(n):kn(n);!i||i===Xe&&o===He&&a===je?i||Ke():(Xe=i,He=o,je=a,Ze(o,a,i))}else{const n=t[0],i=zt(n.seriesIndex,n.dataIndex,n.point),r=e?e(i):Un(i);!r||r===Xe&&o===He&&a===je?r||Ke():(Xe=r,He=o,je=a,Ze(o,a,r))}}else if("axis"===r){const n=Lt(qe,Je.gridX,Je.gridY,$e.plotWidthCss,$e.plotHeightCss);if(n){const t={seriesName:n.slice.name,seriesIndex:n.seriesIndex,dataIndex:n.dataIndex,value:[0,n.slice.value],color:n.slice.color},i=e?e([t]):Un(t);!i||i===Xe&&o===He&&a===je?i||Ke():(Xe=i,He=o,je=a,Ze(o,a,i))}else{const n=Xt(qe,Je.gridX,Je.gridY,$e),i=sn(qe,Je.gridX,$e.xScale);if(0===i.length)if(n){const i=[n.params],r=e?e(i):kn(i);if(r){const e=Ni(n.match,$e.xScale,$e.yScale,u,t),i=(null==e?void 0:e.x)??o,s=(null==e?void 0:e.y)??a;(r!==Xe||i!==He||s!==je)&&(Xe=r,He=i,je=s,Ze(i,s,r))}else Ke()}else Ke();else{const r=i.map(e=>zt(e.seriesIndex,e.dataIndex,e.point));n&&r.push(n.params);const s=e?e(r):kn(r);if(s){let e=o,i=a;if(n){const r=Ni(n.match,$e.xScale,$e.yScale,u,t);r&&(e=r.x,i=r.y)}(s!==Xe||e!==He||i!==je)&&(Xe=s,He=e,je=i,Ze(e,i,s))}else Ke()}}}else{const n=Lt(qe,Je.gridX,Je.gridY,$e.plotWidthCss,$e.plotHeightCss);if(n){const t={seriesName:n.slice.name,seriesIndex:n.seriesIndex,dataIndex:n.dataIndex,value:[0,n.slice.value],color:n.slice.color},i=e?e(t):Un(t);!i||i===Xe&&o===He&&a===je?i||Ke():(Xe=i,He=o,je=a,Ze(o,a,i))}else{const n=Xt(qe,Je.gridX,Je.gridY,$e);if(n){const i=e?e(n.params):Un(n.params);if(i){const e=Ni(n.match,$e.xScale,$e.yScale,u,t),r=(null==e?void 0:e.x)??o,s=(null==e?void 0:e.y)??a;(i!==Xe||r!==He||s!==je)&&(Xe=i,He=r,je=s,Ze(r,s,i,n.params))}else Ke();return}const i=Me(qe,Je.gridX,Je.gridY,$e.xScale,$e.yScale);if(i){const t=zt(i.seriesIndex,i.dataIndex,i.point),n=e?e(t):Un(t);!n||n===Xe&&o===He&&a===je?n||Ke():(Xe=n,He=o,je=a,Ze(o,a,n))}else Ke()}}}else Ke()}else Ke();const Qe=$e??(M&&$n(M)?Gt(M,u):null),et=Qe&&"number"==typeof Qe.plotWidthCss&&"number"==typeof Qe.plotHeightCss?.5*Math.min(Qe.plotWidthCss,Qe.plotHeightCss):0,tt=pn.getState(),ut=function(e,t){const{currentOptions:n,seriesForRender:i,xScale:r,yScale:o,gridArea:a,dataStore:u,appendedGpuThisFrame:c,gpuSeriesKindByIndex:d,zoomState:f,visibleXDomain:m,introPhase:p,introProgress01:h,withAlpha:g,maxRadiusCss:b}=t,v=n.yAxis.min??n.yAxis.min??0,y=[],x="running"===p?Ie(h):1;for(let t=0;t<i.length;t++){const p=i[t];switch(p.type){case"area":{const n=p.baseline??v;e.areaRenderers[t].prepare(p,p.data,r,o,n);break}case"line":{const i=(()=>{if("time"!==n.xAxis.type)return 0;const e=p.data,t=s(e);for(let n=0;n<t;n++){const t=l(e,n);if(Number.isFinite(t))return t}return 0})();c.has(t)||u.setSeries(t,p.data,{xOffset:i});const m=u.getSeriesBuffer(t);e.lineRenderers[t].prepare(p,m,r,o,i,a.devicePixelRatio,a.canvasWidth,a.canvasHeight);const h=(null==f?void 0:f.getRange())??null;if((null==h||Number.isFinite(h.start)&&Number.isFinite(h.end)&&h.start<=0&&h.end>=100)&&"none"===p.sampling?d[t]="fullRawLine":d[t]="other",p.areaStyle){const n={type:"area",name:p.name,rawData:p.data,data:p.data,color:p.areaStyle.color,areaStyle:p.areaStyle,sampling:p.sampling,samplingThreshold:p.samplingThreshold};e.areaRenderers[t].prepare(n,n.data,r,o,v)}break}case"bar":y.push(p);break;case"scatter":if("density"===p.mode){const n=p.rawData??p.data,i=D(n,m.min,m.max);c.has(t)||u.setSeries(t,n);const s=u.getSeriesBuffer(t),l=u.getSeriesPointCount(t);e.scatterDensityRenderers[t].prepare(p,s,l,i.start,i.end,r,o,a,p.rawBounds),d[t]="other"}else{const n=x<1?{...p,color:g(p.color,x)}:p;e.scatterRenderers[t].prepare(n,p.data,r,o,a)}break;case"pie":if(x<1&&b>0){const n=K(p.radius,b),i=Math.max(0,n.inner)*x,r=Math.max(i,n.outer)*x,o={...p,radius:[i,r]};e.pieRenderers[t].prepare(o,a);break}e.pieRenderers[t].prepare(p,a);break;case"candlestick":e.candlestickRenderers[t].prepare(p,p.data,r,o,a,n.theme.backgroundColor);break;default:throw new Error(`Unhandled series type: ${p.type}`)}}const w=i.map((e,t)=>({series:e,originalIndex:t})).filter(({series:e})=>!1!==e.visible),M=y.filter(e=>!1!==e.visible);return{visibleSeriesForRender:w,barSeriesConfigs:y,visibleBarSeriesConfigs:M}}(tt,{currentOptions:P,seriesForRender:qe,xScale:b,yScale:v,gridArea:u,dataStore:nt,appendedGpuThisFrame:_e,gpuSeriesKindByIndex:Oe,zoomState:jt,visibleXDomain:p,introPhase:E,introProgress01:B,withAlpha:oi,maxRadiusCss:et}),{visibleBarSeriesConfigs:pt}=ut,gt="running"===E?ai(B):1,yt=gt<1?((e,t,n,i)=>{const r=ai(i);if(r>=1)return e;const o=((e,t,n)=>{const i=t.invert(n.bottom),r=t.invert(n.top),o=Math.min(i,r),a=Math.max(i,r);return Number.isFinite(o)&&Number.isFinite(a)?o<=0&&0<=a?0:o>0?o:a<0?a:Ci(e):Ci(e)})(n,e,t),a=e.scale(o),s={domain:(t,n)=>(e.domain(t,n),s),range:(t,n)=>(e.range(t,n),s),scale(t){const n=e.scale(t);return Number.isFinite(n)&&Number.isFinite(a)?a+(n-a)*r:n},invert:t=>e.invert(t)};return s})(v,h,pt,gt):v;tt.barRenderer.prepare(pt,nt,b,yt,u),r?(lt.prepare(u,Re),dt.prepare(u,Re),ct.prepare({canvasWidth:u.canvasWidth,canvasHeight:u.canvasHeight,devicePixelRatio:u.devicePixelRatio,instances:Ee}),ft.prepare({canvasWidth:u.canvasWidth,canvasHeight:u.canvasHeight,devicePixelRatio:u.devicePixelRatio,instances:Ee})):(lt.prepare(u,[]),dt.prepare(u,[]),ct.prepare({canvasWidth:u.canvasWidth,canvasHeight:u.canvasHeight,devicePixelRatio:u.devicePixelRatio,instances:[]}),ft.prepare({canvasWidth:u.canvasWidth,canvasHeight:u.canvasHeight,devicePixelRatio:u.devicePixelRatio,instances:[]})),mt.ensureTextures(u.canvasWidth,u.canvasHeight);const xt=mt.getState(),Nt=e.canvasContext.getCurrentTexture().createView(),St=a.createCommandEncoder({label:"renderCoordinator/commandEncoder"}),At=((e,t={r:0,g:0,b:0,a:1})=>{const n=W(e);if(!n)return t;const[i,r,o,a]=n;return{r:i,g:r,b:o,a}})(P.theme.backgroundColor,{r:0,g:0,b:0,a:1});!function(e,t,n){for(let i=0;i<t.length;i++){const r=t[i];!1!==r.visible&&"scatter"===r.type&&"density"===r.mode&&e.scatterDensityRenderers[i].encodeCompute(n)}}(tt,qe,St);const It=St.beginRenderPass({label:"renderCoordinator/mainPass",colorAttachments:[{view:xt.mainColorView,resolveTarget:xt.mainResolveView,clearValue:At,loadOp:"clear",storeOp:"discard"}]});it&&it.render(It),function(e,t,n,i){const{hasCartesianSeries:r,gridArea:o,mainPass:a,plotScissor:s,introPhase:l,introProgress01:u,referenceLineBelowCount:c,markerBelowCount:d}=n,{visibleSeriesForRender:f}=i,m="running"===l?Ie(u):1;for(let t=0;t<f.length;t++){const{series:n,originalIndex:i}=f[t];"pie"===n.type&&e.pieRenderers[i].render(a)}r&&s.w>0&&s.h>0&&(c>0||d>0)&&(a.setScissorRect(s.x,s.y,s.w,s.h),c>0&&t.referenceLineRenderer.render(a,0,c),d>0&&t.annotationMarkerRenderer.render(a,0,d),a.setScissorRect(0,0,o.canvasWidth,o.canvasHeight));for(let t=0;t<f.length;t++){const{series:n,originalIndex:i}=f[t];if(Pe(n))if(m<1){const t=N(Math.floor(s.w*m),0,s.w);t>0&&s.h>0&&(a.setScissorRect(s.x,s.y,t,s.h),e.areaRenderers[i].render(a),a.setScissorRect(0,0,o.canvasWidth,o.canvasHeight))}else a.setScissorRect(s.x,s.y,s.w,s.h),e.areaRenderers[i].render(a),a.setScissorRect(0,0,o.canvasWidth,o.canvasHeight)}s.w>0&&s.h>0&&(a.setScissorRect(s.x,s.y,s.w,s.h),e.barRenderer.render(a),a.setScissorRect(0,0,o.canvasWidth,o.canvasHeight));for(let t=0;t<f.length;t++){const{series:n,originalIndex:i}=f[t];"candlestick"===n.type&&e.candlestickRenderers[i].render(a)}for(let t=0;t<f.length;t++){const{series:n,originalIndex:i}=f[t];"scatter"===n.type&&("density"===n.mode?e.scatterDensityRenderers[i].render(a):e.scatterRenderers[i].render(a))}for(let t=0;t<f.length;t++){const{series:n,originalIndex:i}=f[t];if("line"===n.type)if(m<1){const t=N(Math.floor(s.w*m),0,s.w);t>0&&s.h>0&&(a.setScissorRect(s.x,s.y,t,s.h),e.lineRenderers[i].render(a),a.setScissorRect(0,0,o.canvasWidth,o.canvasHeight))}else a.setScissorRect(s.x,s.y,s.w,s.h),e.lineRenderers[i].render(a),a.setScissorRect(0,0,o.canvasWidth,o.canvasHeight)}}(tt,{referenceLineRenderer:lt,annotationMarkerRenderer:ct},{hasCartesianSeries:r,gridArea:u,mainPass:It,plotScissor:g,introPhase:E,introProgress01:B,referenceLineBelowCount:Be,markerBelowCount:De},ut),It.end();const Pt=St.beginRenderPass({label:"renderCoordinator/annotationOverlayMsaaPass",colorAttachments:[{view:xt.overlayMsaaView,resolveTarget:Nt,clearValue:At,loadOp:"clear",storeOp:"discard"}]});Pt.setPipeline(xt.overlayBlitPipeline),Pt.setBindGroup(0,xt.overlayBlitBindGroup),Pt.draw(3),function(e,t){const{hasCartesianSeries:n,gridArea:i,overlayPass:r,plotScissor:o,referenceLineBelowCount:a,referenceLineAboveCount:s,markerBelowCount:l,markerAboveCount:u}=t;if(n&&o.w>0&&o.h>0&&(s>0||u>0)){const t=a,n=l;r.setScissorRect(o.x,o.y,o.w,o.h),s>0&&e.referenceLineRendererMsaa.render(r,t,s),u>0&&e.annotationMarkerRendererMsaa.render(r,n,u),r.setScissorRect(0,0,i.canvasWidth,i.canvasHeight)}}({referenceLineRendererMsaa:dt,annotationMarkerRendererMsaa:ft},{hasCartesianSeries:r,gridArea:u,overlayPass:Pt,plotScissor:g,referenceLineBelowCount:Be,referenceLineAboveCount:Te,markerBelowCount:De,markerAboveCount:Ue}),Pt.end();const Rt=St.beginRenderPass({label:"renderCoordinator/topOverlayPass",colorAttachments:[{view:Nt,loadOp:"load",storeOp:"store"}]});st.render(Rt),r&&(rt.render(Rt),ot.render(Rt)),at.render(Rt),Rt.end(),a.queue.submit([St.finish()]),z=!0,function(e,t,n){var i,r,o;const{gpuContext:a,currentOptions:s,xScale:l,yScale:u,xTickValues:c,plotClipRect:d,visibleXRangeMs:f}=n;if(!s.series.some(e=>"pie"!==e.type)||!e||!t)return;const m=a.canvas;if(!m)return;const p=function(e){return e?e.clientWidth:0}(m),h=function(e){return e?e.clientHeight:0}(m);if(p<=0||h<=0)return;const g=m.offsetLeft||0,b=m.offsetTop||0,v=ie(d.left,p),y=ie(d.right,p),x=re(d.top,h),w=re(d.bottom,h);e.clear();const M=w+(s.xAxis.tickLength??6)+4+.5*s.theme.fontSize,F="time"===s.xAxis.type,N=(()=>{if(F)return null;const e=O(s.xAxis.min)??l.invert(d.left),t=O(s.xAxis.max)??l.invert(d.right),n=c.length;return te(1===n?0:(t-e)/(n-1))})();for(let t=0;t<c.length;t++){const n=c[t],i=ie(l.scale(n),p),r=1===c.length?"middle":0===t?"start":t===c.length-1?"end":"middle",o=F?ee(n,f):ne(N,n);null!=o&&oe(e.addLabel(o,g+i,b+M,{fontSize:s.theme.fontSize,color:s.theme.textColor,anchor:r}),!1,s.theme)}const C=s.yAxis.tickLength??6,S=O(s.yAxis.min)??u.invert(d.bottom),A=O(s.yAxis.max)??u.invert(d.top),I=te((A-S)/4),P=v-C-4,R=[];for(let t=0;t<5;t++){const n=S+t/4*(A-S),i=re(u.scale(n),h),r=ne(I,n);if(null==r)continue;const o=e.addLabel(r,g+P,b+i,{fontSize:s.theme.fontSize,color:s.theme.textColor,anchor:"end"});oe(o,!1,s.theme),R.push(o)}const E=function(e){return Math.max(e+1,Math.round(1.15*e))}(s.theme.fontSize),B=(null==(i=s.xAxis.name)?void 0:i.trim())??"";if(B.length>0){const t=(v+y)/2,n=(M+.5*s.theme.fontSize+((null==(r=s.dataZoom)?void 0:r.some(e=>"slider"===(null==e?void 0:e.type)))?h-32:h))/2;oe(e.addLabel(B,g+t,b+n,{fontSize:E,color:s.theme.textColor,anchor:"middle"}),!0,s.theme)}const T=(null==(o=s.yAxis.name)?void 0:o.trim())??"";if(T.length>0){const t=(x+w)/2,n=P-(0===R.length?0:R.reduce((e,t)=>Math.max(e,t.getBoundingClientRect().width),0))-4-.5*E;oe(e.addLabel(T,g+n,b+t,{fontSize:E,color:s.theme.textColor,anchor:"middle",rotation:-90}),!0,s.theme)}}(x,y,{gpuContext:e,currentOptions:P,xScale:b,yScale:v,xTickValues:Ye,plotClipRect:h,visibleXRangeMs:Ve}),function(e,t,n){var i,r,o;const{currentOptions:a,xScale:s,yScale:l,canvasCssWidthForAnnotations:u,canvasCssHeightForAnnotations:c,plotLeftCss:d,plotTopCss:f,plotWidthCss:m,plotHeightCss:p,canvas:h}=n;if(!a.series.some(e=>"pie"!==e.type)||!e||!t)return;if(!h||u<=0||c<=0||m<=0||p<=0)return void e.clear();const g=ae(h)?h.offsetLeft:0,b=ae(h)?h.offsetTop:0;e.clear();const v=a.annotations??[];if(0!==v.length)for(let t=0;t<v.length;t++){const n=v[t],h=n.label;if(null==h&&"text"!==n.type)continue;let y=null,x=null,w={name:n.id??""};switch(n.type){case"lineX":y=se(s.scale(n.x),u),x=f,w={...w,x:n.x,value:n.x};break;case"lineY":y=d,x=le(l.scale(n.y),c)-8,w={...w,y:n.y,value:n.y};break;case"point":{const e=s.scale(n.x),t=l.scale(n.y);y=se(e,u),x=le(t,c),w={...w,x:n.x,y:n.y,value:n.y};break}case"text":if("data"===n.position.space){const e=s.scale(n.position.x),t=l.scale(n.position.y);y=se(e,u),x=le(t,c),w={...w,x:n.position.x,y:n.position.y,value:n.position.y}}else y=d+n.position.x*m,x=f+n.position.y*p,w={...w,x:n.position.x,y:n.position.y,value:n.position.y};break;default:_(n)}if(null==y||null==x||!Number.isFinite(y)||!Number.isFinite(x))continue;const M=200;if(y<d-M||y>d+m+M||x<f-M||x>f+p+M)continue;const F=y+((null==(i=null==h?void 0:h.offset)?void 0:i[0])??0),N=x+((null==(r=null==h?void 0:h.offset)?void 0:r[1])??0),C=(null==h?void 0:h.text)??(null!=h&&h.template?de(h.template,w,h.decimals):h?(()=>{const e="lineX"===n.type?"x={x}":"lineY"===n.type?"y={y}":"point"===n.type?"({x}, {y})":"text"===n.type?n.text:"";return e.includes("{")?de(e,w,h.decimals):e})():"text"===n.type?n.text:""),S="string"==typeof C?C.trim():"";if(0===S.length)continue;const A=fe(null==h?void 0:h.anchor),I=(null==(o=n.style)?void 0:o.color)??a.theme.textColor,P=a.theme.fontSize,R=null==h?void 0:h.background,E=null!=(null==R?void 0:R.color)?ue(R.color,R.opacity??1):void 0,B=(()=>{const e=null==R?void 0:R.padding;return"number"==typeof e&&Number.isFinite(e)?[e,e,e,e]:Array.isArray(e)&&4===e.length&&e.every(e=>"number"==typeof e&&Number.isFinite(e))?[e[0],e[1],e[2],e[3]]:R?[2,4,2,4]:void 0})(),T="number"==typeof(null==R?void 0:R.borderRadius)&&Number.isFinite(R.borderRadius)?R.borderRadius:void 0,D={x:g+F,y:b+N,...E?{background:{backgroundColor:E,...B?{padding:B}:{},...null!=T?{borderRadius:T}:{}}}:{}},U=e.addLabel(S,D.x,D.y,{fontSize:P,color:I,anchor:A});if(D.background){if(U.style.backgroundColor=D.background.backgroundColor,U.style.display="inline-block",U.style.boxSizing="border-box",D.background.padding){const[e,t,n,i]=D.background.padding;U.style.padding=`${e}px ${t}px ${n}px ${i}px`}null!=D.background.borderRadius&&(U.style.borderRadius=`${D.background.borderRadius}px`)}}}(w,y,{currentOptions:P,xScale:b,yScale:v,canvasCssWidthForAnnotations:C,canvasCssHeightForAnnotations:R,plotLeftCss:j,plotTopCss:J,plotWidthCss:me,plotHeightCss:pe,canvas:M})},dispose:()=>{if(!I){I=!0;try{G&&k.cancel(G),k.cancelAll()}catch{}G=null,E="done",B=1;try{L&&V.cancel(L),V.cancelAll()}catch{}L=null,Y=1,H=null,Ct(),Dt(),Ge=!1,We.clear(),null==Zt||Zt.dispose(),Zt=null,null==Jt||Jt(),Jt=null,jt=null,rn=null,on.clear(),null==ht||ht.dispose(),at.dispose(),st.dispose(),pn.dispose(),it.dispose(),rt.dispose(),ot.dispose(),lt.dispose(),ct.dispose(),dt.dispose(),ft.dispose(),mt.dispose(),nt.dispose(),null==$e||$e.dispose(),$e=null,null==C||C.dispose(),null==x||x.dispose(),null==w||w.dispose()}}}}const Ai=["#5470C6","#91CC75","#FAC858","#EE6666","#73C0DE","#3BA272","#FC8452","#9A60B4","#EA7CCC"],Ii="#22c55e",Pi="#ef4444",Ri="#22c55e",Ei="#ef4444",Bi=1,Ti=5,Di=6,Ui={grid:{left:60,right:20,top:40,bottom:40},xAxis:{type:"value"},yAxis:{type:"value",autoBounds:"visible"},autoScroll:!1,theme:"dark",palette:Ai,series:[]},ki={backgroundColor:"#1a1a2e",textColor:"#e0e0e0",axisLineColor:"rgba(224,224,224,0.35)",axisTickColor:"rgba(224,224,224,0.55)",gridLineColor:"rgba(255,255,255,0.1)",colorPalette:["#00E5FF","#FF2D95","#B026FF","#00F5A0","#FFD300","#FF6B00","#4D5BFF","#FF3D3D"],fontFamily:'system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"',fontSize:12},Gi={backgroundColor:"#ffffff",textColor:"#333333",axisLineColor:"rgba(0,0,0,0.35)",axisTickColor:"rgba(0,0,0,0.55)",gridLineColor:"rgba(0,0,0,0.1)",colorPalette:["#1F77B4","#FF7F0E","#2CA02C","#D62728","#9467BD","#8C564B","#E377C2","#17BECF"],fontFamily:'system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"',fontSize:12};function zi(e){return"dark"===e?ki:Gi}const Vi=e=>{if(!Array.isArray(e))return;const t=[];for(const n of e){if(null===n||"object"!=typeof n||Array.isArray(n))continue;const e=n,i=e.type;if("inside"!==i&&"slider"!==i)continue;const r=e.xAxisIndex,o=e.start,a=e.end,s=e.minSpan,l=e.maxSpan,u="number"==typeof r&&Number.isFinite(r)?r:void 0,c="number"==typeof o&&Number.isFinite(o)?o:void 0,d="number"==typeof a&&Number.isFinite(a)?a:void 0,f="number"==typeof s&&Number.isFinite(s)?s:void 0,m="number"==typeof l&&Number.isFinite(l)?l:void 0;t.push({type:i,xAxisIndex:u,start:c,end:d,minSpan:f,maxSpan:m})}return t},Li=e=>{if(!Array.isArray(e))return;const t=[],n=e=>"start"===e||"center"===e||"end"===e,i=e=>"circle"===e||"rect"===e||"triangle"===e,r=e=>{if("string"!=typeof e)return;const t=e.trim();return t.length>0?t:void 0},o=e=>"number"==typeof e&&Number.isFinite(e)?e:void 0,a=e=>{const t=o(e);if(null!=t)return Math.min(1,Math.max(0,t))},s=e=>{if(!Array.isArray(e))return;const t=e.filter(e=>"number"==typeof e&&Number.isFinite(e)).map(e=>e);return 0!==t.length?(Object.freeze(t),t):void 0},l=e=>{if("number"==typeof e&&Number.isFinite(e))return e;if(!Array.isArray(e)||4!==e.length)return;const t=o(e[0]),n=o(e[1]),i=o(e[2]),r=o(e[3]);return null!=t&&null!=n&&null!=i&&null!=r?[t,n,i,r]:void 0};for(const u of e){if(null===u||"object"!=typeof u||Array.isArray(u))continue;const e=u,c=e.type;if("lineX"!==c&&"lineY"!==c&&"point"!==c&&"text"!==c)continue;const d=r(e.id),f=e.layer,m="belowSeries"===f||"aboveSeries"===f?f:void 0,p=e.style,h=p&&"object"==typeof p&&!Array.isArray(p)?(()=>{const e=p,t=r(e.color),n=o(e.lineWidth),i=s(e.lineDash),l=a(e.opacity),u={...t?{color:t}:{},...null!=n?{lineWidth:n}:{},...i?{lineDash:i}:{},...null!=l?{opacity:l}:{}};return Object.keys(u).length>0?u:void 0})():void 0,g=e.label,b=g&&"object"==typeof g&&!Array.isArray(g)?(()=>{const e=g,t=r(e.text),i=r(e.template),s=e.decimals,u="number"==typeof s&&Number.isFinite(s)&&s>=0?Math.min(20,Math.floor(s)):void 0,c=e.offset,d=Array.isArray(c)&&2===c.length&&"number"==typeof c[0]&&Number.isFinite(c[0])&&"number"==typeof c[1]&&Number.isFinite(c[1])?[c[0],c[1]]:void 0,f=e.anchor,m=n(f)?f:void 0,p=e.background,h=p&&"object"==typeof p&&!Array.isArray(p)?(()=>{const e=p,t=r(e.color),n=a(e.opacity),i=l(e.padding),s=o(e.borderRadius),u={...t?{color:t}:{},...null!=n?{opacity:n}:{},...null!=i?{padding:i}:{},...null!=s?{borderRadius:s}:{}};return Object.keys(u).length>0?u:void 0})():void 0,b={...t?{text:t}:{},...i?{template:i}:{},...null!=u?{decimals:u}:{},...d?{offset:d}:{},...m?{anchor:m}:{},...h?{background:h}:{}};return Object.keys(b).length>0?b:void 0})():void 0;if("lineX"===c){const n=o(e.x);if(null==n)continue;const i={type:"lineX",x:n,...d?{id:d}:{},...m?{layer:m}:{},...h?{style:h}:{},...b?{label:b}:{}};t.push(i);continue}if("lineY"===c){const n=o(e.y);if(null==n)continue;const i={type:"lineY",y:n,...d?{id:d}:{},...m?{layer:m}:{},...h?{style:h}:{},...b?{label:b}:{}};t.push(i);continue}if("point"===c){const n=o(e.x),l=o(e.y);if(null==n||null==l)continue;const u=e.marker,c=u&&"object"==typeof u&&!Array.isArray(u)?(()=>{const e=u,t=e.symbol,n=i(t)?t:void 0,l=o(e.size),c=e.style,d=c&&"object"==typeof c&&!Array.isArray(c)?(()=>{const e=c,t=r(e.color),n=a(e.opacity),i=o(e.lineWidth),l=s(e.lineDash),u={...t?{color:t}:{},...null!=n?{opacity:n}:{},...null!=i?{lineWidth:i}:{},...l?{lineDash:l}:{}};return Object.keys(u).length>0?u:void 0})():void 0,f={...n?{symbol:n}:{},...null!=l?{size:l}:{},...d?{style:d}:{}};return Object.keys(f).length>0?f:void 0})():void 0,f={type:"point",x:n,y:l,...c?{marker:c}:{},...d?{id:d}:{},...m?{layer:m}:{},...h?{style:h}:{},...b?{label:b}:{}};t.push(f);continue}{const n=e.position,i=r(e.text);if(!i||!n||"object"!=typeof n||Array.isArray(n))continue;const a=n,s=a.space;if("data"!==s&&"plot"!==s)continue;const l=o(a.x),u=o(a.y);if(null==l||null==u)continue;const c={type:"text",position:{space:s,x:l,y:u},text:i,...d?{id:d}:{},...m?{layer:m}:{},...h?{style:h}:{},...b?{label:b}:{}};t.push(c);continue}}return 0!==t.length?(Object.freeze(t),t):void 0},Wi=e=>Array.isArray(e)?e.filter(e=>"string"==typeof e).map(e=>e.trim()).filter(e=>e.length>0):[],Oi=e=>{if("string"!=typeof e)return;const t=e.trim();return t.length>0?t:void 0},_i=e=>{if("number"!=typeof e||!Number.isFinite(e))return;const t=Math.floor(e);return t>0?t:void 0},Yi=e=>{if("string"!=typeof e)return;const t=e.trim().toLowerCase();return"global"===t||"visible"===t?t:void 0};let $i=!1;function Xi(e={}){var t,n,i,r;const o=(e=>{const t=zi("dark");if("string"==typeof e)return zi("light"===e.trim().toLowerCase()?"light":"dark");if(null===e||"object"!=typeof e||Array.isArray(e))return t;const n=e,i=e=>{const t=n[e];if("string"!=typeof t)return;const i=t.trim();return i.length>0?i:void 0},r=n.fontSize,o="number"==typeof r&&Number.isFinite(r)?r:void 0,a=Wi(n.colorPalette);return{backgroundColor:i("backgroundColor")??t.backgroundColor,textColor:i("textColor")??t.textColor,axisLineColor:i("axisLineColor")??t.axisLineColor,axisTickColor:i("axisTickColor")??t.axisTickColor,gridLineColor:i("gridLineColor")??t.gridLineColor,colorPalette:a.length>0?a:Array.from(t.colorPalette),fontFamily:i("fontFamily")??t.fontFamily,fontSize:o??t.fontSize}})(e.theme),a=e.autoScroll,s="boolean"==typeof a?a:Ui.autoScroll,l=e.animation,u=("boolean"==typeof l||null!==l&&"object"==typeof l&&!Array.isArray(l)?l:void 0)??!0,c=Wi(e.palette),d=c.length>0?{...o,colorPalette:c}:o,m=Wi(d.colorPalette),p=m.length>0?m:Wi(Ui.palette??Ai).length>0?Wi(Ui.palette??Ai):Array.from(Ai),h=p.length>0?p:["#000000"],g={...d,colorPalette:h.slice()},b={left:(null==(t=e.grid)?void 0:t.left)??Ui.grid.left,right:(null==(n=e.grid)?void 0:n.right)??Ui.grid.right,top:(null==(i=e.grid)?void 0:i.top)??Ui.grid.top,bottom:(null==(r=e.grid)?void 0:r.bottom)??Ui.grid.bottom},v=((e,t)=>{const n=!1!==(null==e?void 0:e.show),i=Oi(null==e?void 0:e.color)??t.gridLineColor,r="number"==typeof(null==e?void 0:e.opacity)&&Number.isFinite(e.opacity)?Math.min(1,Math.max(0,e.opacity)):1,o=(e,t)=>{if(1===t)return e;const n=W(e);return n?`rgba(${Math.round(255*n[0])}, ${Math.round(255*n[1])}, ${Math.round(255*n[2])}, ${n[3]*t})`:e},a=o(i,r),s=(e,t)=>{if(!1===e)return{show:!1,count:0,color:a};if(!0===e||void 0===e)return{show:n,count:t,color:a};const i=!1!==e.show&&n,s="number"==typeof e.count&&Number.isFinite(e.count)&&e.count>=0?Math.floor(e.count):t,l=Oi(e.color);return{show:i,count:s,color:null!=l?o(l,r):a}};return{show:n,color:a,opacity:r,horizontal:s(null==e?void 0:e.horizontal,Ti),vertical:s(null==e?void 0:e.vertical,Di)}})(e.gridLines,g),y=e.xAxis?{...Ui.xAxis,...e.xAxis,type:e.xAxis.type??Ui.xAxis.type,autoBounds:Yi(e.xAxis.autoBounds)??Ui.xAxis.autoBounds}:{...Ui.xAxis},x=e.yAxis?{...Ui.yAxis,...e.yAxis,type:e.yAxis.type??Ui.yAxis.type,autoBounds:Yi(e.yAxis.autoBounds)??Ui.yAxis.autoBounds}:{...Ui.yAxis},w=(e.series??[]).map((e,t)=>{var n,i,r,o,a,s,l,u,c,d;const m=Oi(e.color),p=g.colorPalette[t%g.colorPalette.length],h=m??p,b=!1!==e.visible,v=(e=>{if("string"!=typeof e)return;const t=e.trim().toLowerCase();return"none"===t||"lttb"===t||"average"===t||"max"===t||"min"===t||"ohlc"===t?t:void 0})(e.sampling)??"lttb",y=_i(e.samplingThreshold)??5e3;switch(e.type){case"area":{const t=Oi(null==(n=e.areaStyle)?void 0:n.color)??m??p,r={opacity:(null==(i=e.areaStyle)?void 0:i.opacity)??.25,color:t},o=f(e.data)??void 0;return{...e,visible:b,rawData:e.data,data:M(e.data,v,y),color:t,areaStyle:r,sampling:v,samplingThreshold:y,rawBounds:o}}case"line":{const t=Oi(null==(r=e.lineStyle)?void 0:r.color)??m??p,n={width:(null==(o=e.lineStyle)?void 0:o.width)??2,opacity:(null==(a=e.lineStyle)?void 0:a.opacity)??1,color:t},{areaStyle:i,...s}=e,l=f(e.data)??void 0,u=M(e.data,v,y);return{...s,visible:b,rawData:e.data,data:u,color:t,lineStyle:n,...e.areaStyle?{areaStyle:{opacity:e.areaStyle.opacity??.25,color:Oi(e.areaStyle.color)??t}}:{},sampling:v,samplingThreshold:y,rawBounds:l}}case"bar":{const t=f(e.data)??void 0;return{...e,visible:b,rawData:e.data,data:M(e.data,v,y),color:h,sampling:v,samplingThreshold:y,rawBounds:t}}case"scatter":{const t=f(e.data)??void 0,n=(e=>{if("string"!=typeof e)return;const t=e.trim().toLowerCase();return"points"===t||"density"===t?t:void 0})(e.mode)??"points",i=(e=>{if("number"!=typeof e||!Number.isFinite(e))return;const t=Math.floor(e);return t>0?Math.max(1,t):void 0})(e.binSize)??2,r=(e=>{if("string"==typeof e){const t=e.trim().toLowerCase();return"viridis"===t||"plasma"===t||"inferno"===t?t:void 0}if(!Array.isArray(e))return;if(e.length>0&&e.every(e=>"string"==typeof e&&e.length>0&&e===e.trim())){const t=e;return Object.isFrozen(t)||Object.freeze(t),t}const t=e.filter(e=>"string"==typeof e).map(e=>e.trim()).filter(e=>e.length>0);return 0!==t.length?(Object.freeze(t),t):void 0})(e.densityColormap)??"viridis",o=(e=>{if("string"!=typeof e)return;const t=e.trim().toLowerCase();return"linear"===t||"sqrt"===t||"log"===t?t:void 0})(e.densityNormalization)??"log";return{...e,visible:b,rawData:e.data,data:M(e.data,v,y),color:h,mode:n,binSize:i,densityColormap:r,densityNormalization:o,sampling:v,samplingThreshold:y,rawBounds:t}}case"pie":{const{sampling:n,samplingThreshold:i,...r}=e;return{...r,visible:b,color:h,data:(e.data??[]).map((e,n)=>{const i=Oi(null==e?void 0:e.color),r=g.colorPalette[(t+n)%g.colorPalette.length],o=!1!==(null==e?void 0:e.visible);return{...e,color:i??r,visible:o}})}}case"candlestick":{$i||(console.warn("ChartGPU: Candlestick series rendering is not yet implemented. Series will be skipped."),$i=!0);const t=(e=>{if("string"!=typeof e)return;const t=e.trim().toLowerCase();return"none"===t||"ohlc"===t?t:void 0})(e.sampling)??"ohlc",n=_i(e.samplingThreshold)??5e3,i={upColor:Oi(null==(s=e.itemStyle)?void 0:s.upColor)??Ii,downColor:Oi(null==(l=e.itemStyle)?void 0:l.downColor)??Pi,upBorderColor:Oi(null==(u=e.itemStyle)?void 0:u.upBorderColor)??Ri,downBorderColor:Oi(null==(c=e.itemStyle)?void 0:c.downBorderColor)??Ei,borderWidth:"number"==typeof(null==(d=e.itemStyle)?void 0:d.borderWidth)&&Number.isFinite(e.itemStyle.borderWidth)?e.itemStyle.borderWidth:Bi},r=(e=>{if(0===e.length)return;let t=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY,i=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;if((e=>Array.isArray(e))(e[0])){const o=e;for(let e=0;e<o.length;e++){const a=o[e],s=a[0],l=a[3],u=a[4];if(!Number.isFinite(s)||!Number.isFinite(l)||!Number.isFinite(u))continue;const c=Math.min(l,u),d=Math.max(l,u);s<t&&(t=s),s>n&&(n=s),c<i&&(i=c),d>r&&(r=d)}}else{const o=e;for(let e=0;e<o.length;e++){const a=o[e],s=a.timestamp,l=a.low,u=a.high;if(!Number.isFinite(s)||!Number.isFinite(l)||!Number.isFinite(u))continue;const c=Math.min(l,u),d=Math.max(l,u);s<t&&(t=s),s>n&&(n=s),c<i&&(i=c),d>r&&(r=d)}}return Number.isFinite(t)&&Number.isFinite(n)&&Number.isFinite(i)&&Number.isFinite(r)?(t===n&&(n=t+1),i===r&&(r=i+1),{xMin:t,xMax:n,yMin:i,yMax:r}):void 0})(e.data),o="ohlc"===t&&e.data.length>n?F(e.data,n):e.data;return{...e,visible:b,rawData:e.data,data:o,color:h,style:e.style??"classic",itemStyle:i,barWidth:e.barWidth??"80%",barMinWidth:e.barMinWidth??1,barMaxWidth:e.barMaxWidth??50,sampling:t,samplingThreshold:n,rawBounds:r}}default:return(e=>{throw new Error(`Unhandled series type: ${(null==e?void 0:e.type)??"unknown"}`)})(e)}});return{grid:b,gridLines:v,xAxis:y,yAxis:x,autoScroll:s,dataZoom:Vi(e.dataZoom),annotations:Li(e.annotations),animation:u,theme:g,palette:g.colorPalette,series:w,legend:e.legend}}function Hi(e={}){const t={...Xi(e),tooltip:e.tooltip};return(e=>{var t;return(null==(t=e.dataZoom)?void 0:t.some(e=>"slider"===(null==e?void 0:e.type)))??!1})(e)?{...t,grid:{...t.grid,bottom:t.grid.bottom+40}}:t}const qi=(e,t,n)=>Math.min(n,Math.max(t,e));function ji(e,t,n){const i=null==n?void 0:n.height,r=null==n?void 0:n.marginTop,o=(null==n?void 0:n.zIndex)??4,a=(null==n?void 0:n.showPreview)??!1,s=document.createElement("div");s.style.display="block",s.style.width="100%",s.style.height=`${i}px`,s.style.marginTop=`${r}px`,s.style.boxSizing="border-box",s.style.position="relative",s.style.zIndex=`${o}`,s.style.userSelect="none",s.style.touchAction="none";const l=document.createElement("div");l.style.position="relative",l.style.height="100%",l.style.width="100%",l.style.boxSizing="border-box",l.style.borderRadius="8px",l.style.borderStyle="solid",l.style.borderWidth="1px",l.style.overflow="hidden",s.appendChild(l);const u=document.createElement("div");u.style.position="absolute",u.style.inset="0",u.style.pointerEvents="none",u.style.opacity="0.4",u.style.display=a?"block":"none",l.appendChild(u);const c=document.createElement("div");c.style.position="absolute",c.style.top="0",c.style.bottom="0",c.style.left="0%",c.style.width="100%",c.style.boxSizing="border-box",c.style.cursor="grab",l.appendChild(c);const d=document.createElement("div");d.style.position="absolute",d.style.left="0",d.style.top="0",d.style.bottom="0",d.style.width="10px",d.style.cursor="ew-resize",c.appendChild(d);const f=document.createElement("div");f.style.position="absolute",f.style.right="0",f.style.top="0",f.style.bottom="0",f.style.width="10px",f.style.cursor="ew-resize",c.appendChild(f);const m=document.createElement("div");m.style.position="absolute",m.style.left="10px",m.style.right="10px",m.style.top="0",m.style.bottom="0",m.style.cursor="grab",c.appendChild(m),e.appendChild(s);let p=!1,h=null;const g=e=>{const t=(e=>{let{start:t,end:n}=e;if(t>n){const e=t;t=n,n=e}return{start:qi(t,0,100),end:qi(n,0,100)}})(e),n=qi(t.end-t.start,0,100);c.style.left=`${t.start}%`,c.style.width=`${n}%`},b=(e,n)=>{if(p||0!==e.button)return;e.preventDefault(),null==h||h(),h=null;const i=e.clientX,r=t.getRange(),o=e.currentTarget instanceof Element?e.currentTarget:c;((e,t)=>{try{e.setPointerCapture(t)}catch{}})(o,e.pointerId),"pan-window"===n&&(c.style.cursor="grabbing",m.style.cursor="grabbing");const a=o=>{if(p||o.pointerId!==e.pointerId)return;o.preventDefault();const a=(e=>{const t=(()=>{const e=l.getBoundingClientRect().width;return Number.isFinite(e)&&e>0?e:null})();if(null===t)return null;const n=e/t*100;return Number.isFinite(n)?n:null})(o.clientX-i);if(null!==a)switch(n){case"left-handle":{const e=Math.min(r.end,r.start+a),n=t;return void(n.setRangeAnchored?n.setRangeAnchored(e,r.end,"end"):t.setRange(e,r.end))}case"right-handle":{const e=Math.max(r.start,r.end+a),n=t;return void(n.setRangeAnchored?n.setRangeAnchored(r.start,e,"start"):t.setRange(r.start,e))}case"pan-window":return void t.setRange(r.start+a,r.end+a)}};let s=!1;const u=()=>{s||(s=!0,window.removeEventListener("pointermove",a),window.removeEventListener("pointerup",d),window.removeEventListener("pointercancel",d),"pan-window"===n&&(c.style.cursor="grab",m.style.cursor="grab"),((e,t)=>{try{e.releasePointerCapture(t)}catch{}})(o,e.pointerId),h===u&&(h=null))},d=t=>{t.pointerId===e.pointerId&&u()};h=u,window.addEventListener("pointermove",a,{passive:!1}),window.addEventListener("pointerup",d,{passive:!0}),window.addEventListener("pointercancel",d,{passive:!0})},v=e=>b(e,"left-handle"),y=e=>b(e,"right-handle"),x=e=>b(e,"pan-window");d.addEventListener("pointerdown",v,{passive:!1}),f.addEventListener("pointerdown",y,{passive:!1}),m.addEventListener("pointerdown",x,{passive:!1});const w=t.onChange(e=>{p||g(e)});return g(t.getRange()),{update:e=>{if(p)return;l.style.background=e.backgroundColor,l.style.borderColor=e.axisLineColor,u.style.background=e.gridLineColor,c.style.background=e.gridLineColor,c.style.border=`1px solid ${e.axisTickColor}`,c.style.borderRadius="8px",c.style.boxSizing="border-box";const t=`1px solid ${e.axisLineColor}`;d.style.background=e.axisTickColor,d.style.borderRight=t,f.style.background=e.axisTickColor,f.style.borderLeft=t,m.style.background="transparent",m.style.backgroundImage="linear-gradient(90deg, rgba(255,255,255,0.0) 0, rgba(255,255,255,0.0) 42%, rgba(255,255,255,0.18) 42%, rgba(255,255,255,0.18) 46%, rgba(255,255,255,0.0) 46%, rgba(255,255,255,0.0) 54%, rgba(255,255,255,0.18) 54%, rgba(255,255,255,0.18) 58%, rgba(255,255,255,0.0) 58%, rgba(255,255,255,0.0) 100%)",m.style.mixBlendMode="normal"},dispose:()=>{if(!p){p=!0,null==h||h(),h=null;try{w()}catch{}d.removeEventListener("pointerdown",v),f.removeEventListener("pointerdown",y),m.removeEventListener("pointerdown",x),s.remove()}}}}let Zi=null;const Ji=120,Ki=e=>Array.isArray(e),Qi=e=>(e=>Array.isArray(e))(e)?{x:e[0],y:e[1]}:{x:e.x,y:e.y},er=e=>{const t=s(e);if(0===t)return{x:[],y:[]};const n=new Array(t),i=new Array(t),r=[];let o=!1;for(let a=0;a<t;a++){n[a]=l(e,a),i[a]=u(e,a);const t=c(e,a);r[a]=t,void 0!==t&&(o=!0)}return o?{x:n,y:i,size:r}:{x:n,y:i}},tr=e=>Ki(e)?e[0]:e.timestamp,nr=e=>Ki(e)?e[2]:e.close,ir=(e,t,n)=>Math.min(n,Math.max(t,e)),rr=(e,t)=>{let n=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,r=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let a=0;a<e.length;a++){const s=e[a];if("pie"===s.type)continue;const l=(null==t?void 0:t[a])??null;if(l){const e=l;if(Number.isFinite(e.xMin)&&Number.isFinite(e.xMax)&&Number.isFinite(e.yMin)&&Number.isFinite(e.yMax)){e.xMin<n&&(n=e.xMin),e.xMax>i&&(i=e.xMax),e.yMin<r&&(r=e.yMin),e.yMax>o&&(o=e.yMax);continue}}const u=s.rawBounds??null;if(u){const e=u;if(Number.isFinite(e.xMin)&&Number.isFinite(e.xMax)&&Number.isFinite(e.yMin)&&Number.isFinite(e.yMax)){e.xMin<n&&(n=e.xMin),e.xMax>i&&(i=e.xMax),e.yMin<r&&(r=e.yMin),e.yMax>o&&(o=e.yMax);continue}}if("candlestick"===s.type){const e=s.data;for(let t=0;t<e.length;t++){const a=e[t],s=tr(a),l=Ki(a)?a[3]:a.low,u=Ki(a)?a[4]:a.high;!Number.isFinite(s)||!Number.isFinite(l)||!Number.isFinite(u)||(s<n&&(n=s),s>i&&(i=s),l<r&&(r=l),u>o&&(o=u))}continue}const c=f(s.data);c&&(c.xMin<n&&(n=c.xMin),c.xMax>i&&(i=c.xMax),c.yMin<r&&(r=c.yMin),c.yMax>o&&(o=c.yMax))}return Number.isFinite(n)&&Number.isFinite(i)&&Number.isFinite(r)&&Number.isFinite(o)?(n===i&&(i=n+1),r===o&&(o=r+1),{xMin:n,xMax:i,yMin:r,yMax:o}):{xMin:0,xMax:1,yMin:0,yMax:1}},or=(e,t)=>{let n=e,i=t;if((!Number.isFinite(n)||!Number.isFinite(i))&&(n=0,i=1),n===i)i=n+1;else if(n>i){const e=n;n=i,i=e}return{min:n,max:i}},ar=(e,t)=>{if("number"==typeof e)return Number.isFinite(e)?e:null;if("string"!=typeof e)return null;const n=e.trim();if(0===n.length)return null;if(n.endsWith("%")){const e=Number.parseFloat(n.slice(0,-1));return Number.isFinite(e)?e/100*t:null}const i=Number.parseFloat(n);return Number.isFinite(i)?i:null},sr=(e,t,n)=>{const i=(null==e?void 0:e[0])??"50%",r=(null==e?void 0:e[1])??"50%",o=ar(i,t),a=ar(r,n);return{x:Number.isFinite(o)?o:.5*t,y:Number.isFinite(a)?a:.5*n}},lr=(e,t)=>{if(null==e)return{inner:0,outer:.7*t};if((e=>Array.isArray(e))(e)){const n=ar(e[0],t),i=ar(e[1],t),r=Math.max(0,Number.isFinite(n)?n:0),o=Math.max(r,Number.isFinite(i)?i:.7*t);return{inner:r,outer:Math.min(t,o)}}const n=ar(e,t),i=Math.max(0,Number.isFinite(n)?n:.7*t);return{inner:0,outer:Math.min(t,i)}},ur={create:async function(e,t,n){var r;if(n){if(typeof navigator>"u"||!navigator.gpu)throw new Error("ChartGPU: Shared device mode requires WebGPU globals (navigator.gpu) to be available.")}else{const e=await async function(){return Zi||(Zi=(async()=>{if(typeof window>"u")return{supported:!1,reason:"Not running in a browser environment (window is undefined)."};if(typeof navigator>"u")return{supported:!1,reason:"Navigator is not available in this environment."};if(!navigator.gpu)return{supported:!1,reason:"WebGPU API (navigator.gpu) is not available. Your browser does not support WebGPU."};try{let e=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});return e||(e=await navigator.gpu.requestAdapter()),e?{supported:!0}:{supported:!1,reason:"No compatible WebGPU adapter found. This may occur if: (1) no GPU is available, (2) GPU drivers are outdated or incompatible, (3) running in a VM or headless environment, or (4) WebGPU is disabled in browser settings."}}catch(e){let t="Failed to request WebGPU adapter.";return e instanceof DOMException?(t=`Failed to request WebGPU adapter: ${e.name}`,e.message&&(t+=` - ${e.message}`)):t=e instanceof Error?`Failed to request WebGPU adapter: ${e.message}`:`Failed to request WebGPU adapter: ${String(e)}`,{supported:!1,reason:t}}})(),Zi)}();if(!e.supported){const t=e.reason||"Unknown reason";throw new Error(`ChartGPU: WebGPU is not available.\nReason: ${t}\nBrowser support: Chrome/Edge 113+, Safari 18+, Firefox not yet supported.\nResources:\n  - MDN WebGPU API: https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API\n  - Browser compatibility: https://caniuse.com/webgpu\n  - WebGPU specification: https://www.w3.org/TR/webgpu/\n  - Check your system: https://webgpureport.org/`)}}if(null!=n&&n.pipelineCache&&n.pipelineCache.device!==n.device)throw new Error("ChartGPU: pipelineCache.device must match the GPUDevice in the creation context. Create the pipeline cache with the same device: createPipelineCache(device).");const o=document.createElement("canvas");o.style.display="block",o.style.width="100%",o.style.height="100%",e.appendChild(o);const a=!!n;let d,m=!1,p=t.renderMode??"auto",h=!1,g=!1,b=null,v=null,y=null,x=null,w=null,M=!1,F=null,N=null,C=t,S=Hi(C),A=new Array(S.series.length).fill(null).map(()=>({x:[],y:[]})),I=new Array(S.series.length).fill(null),P=null;const R=()=>{A=new Array(S.series.length).fill(null).map(()=>({x:[],y:[]})),I=new Array(S.series.length).fill(null),P=null;for(let e=0;e<S.series.length;e++){const t=S.series[e];if("pie"!==t.type)if("candlestick"===t.type){const n=t.rawData??t.data;A[e]=0===n.length?[]:n.slice(),I[e]=t.rawBounds??null}else{const n=t.rawData??t.data;A[e]=er(n),I[e]=t.rawBounds??null??f(n)}else A[e]={x:[],y:[]}}},E=()=>P||(P=S.series.map((e,t)=>{if("pie"===e.type)return e;if("candlestick"===e.type)return{...e,data:A[t]??e.data};const n=A[t];return{...e,data:n}}),P);R();let B=rr(S.series,I),T=null;const D={click:new Set,mouseover:new Set,mouseout:new Set,crosshairMove:new Set,zoomRangeChange:new Set,deviceLost:new Set,dataAppend:new Set};let U=!1,k=null,G=null,z=null;const V=new Set;let L=null,W=null,O=!0;const _=new Float64Array(Ji);let Y=0,$=0,X=0,H=0,q=0,j=0;const Z=performance.now();let J=0,K=0;const Q=new Set,ee=()=>D.mouseover.size>0||D.mouseout.size>0,te=()=>D.click.size>0,ne=()=>{null!==L&&(cancelAnimationFrame(L),L=null)},ie=e=>{if(m||g||h)return;h=!0;const t=performance.now();try{if(_[Y]=t,Y=(Y+1)%Ji,$<Ji&&$++,X++,e&&(J>0&&(t-J>25?(H++,q++,j=t):q=0),J=t),he(!1),!v||null==b||!b.device)return;if(O){O=!1;try{v.render()}catch{O=!0}}K=performance.now()-t;const n=be();for(const e of Q)try{e(n)}catch(e){console.error("Error in performance update callback:",e)}}finally{h=!1}},re=()=>{m||(O=!0,"external"!==p&&null===L&&(L=requestAnimationFrame(()=>{L=null,!m&&ie(!0)})))},oe=()=>{if(x)try{x()}finally{x=null}},ae=()=>{if(w)try{w()}finally{w=null}},se=()=>{null==N||N.dispose(),N=null},le=()=>{se(),null==F||F.remove(),F=null},ue=(e,t)=>{const n=e.end-e.start;return Number.isFinite(n)&&0!==n?ir((t-e.start)/n,0,1):.5},ce=()=>{if(!(e=>{var t;return(null==(t=e.dataZoom)?void 0:t.some(e=>"slider"===(null==e?void 0:e.type)))??!1})(C))return void le();if(!v||!v.getZoomRange())return;const t=(()=>{if(F)return F;try{"static"===window.getComputedStyle(e).position&&(e.style.position="relative")}catch{}const t=document.createElement("div");return t.style.position="absolute",t.style.left="0",t.style.right="0",t.style.bottom="0",t.style.height="40px",t.style.paddingTop="8px",t.style.boxSizing="border-box",t.style.pointerEvents="auto",t.style.zIndex="5",e.appendChild(t),F=t,t})();N||(N=ji(t,{getRange:()=>(null==v?void 0:v.getZoomRange())??{start:0,end:100},setRange:(e,t)=>{null==v||v.setZoomRange(e,t)},zoomIn:(e,t)=>{if(!Number.isFinite(e)||!Number.isFinite(t)||t<=1)return;const n=null==v?void 0:v.getZoomRange();if(!n)return;const i=ir(e,0,100),r=ue(n,i),o=(n.end-n.start)/t,a=i-r*o;null==v||v.setZoomRange(a,a+o)},zoomOut:(e,t)=>{if(!Number.isFinite(e)||!Number.isFinite(t)||t<=1)return;const n=null==v?void 0:v.getZoomRange();if(!n)return;const i=ir(e,0,100),r=ue(n,i),o=(n.end-n.start)*t,a=i-r*o;null==v||v.setZoomRange(a,a+o)},pan:e=>{if(!Number.isFinite(e))return;const t=null==v?void 0:v.getZoomRange();t&&(null==v||v.setZoomRange(t.start+e,t.end+e))},onChange:e=>(null==v?void 0:v.onZoomRangeChange(e))??(()=>{})},{height:32,marginTop:0})),N.update(S.theme)},de={x:null,source:void 0},fe={start:0,end:100,source:void 0,sourceKind:void 0},me={seriesIndex:0,count:0,xExtent:{min:0,max:0}},pe=()=>{if(m||!b||!b.initialized)return;const e=(null==v?void 0:v.getZoomRange())??null;oe(),ae(),se(),null==v||v.dispose(),M=!1,d=void 0;const t={onRequestRender:re,pipelineCache:null==n?void 0:n.pipelineCache};v=Si(b,S,t),y=b.preferredFormat,oe(),!m&&v&&(x=v.onInteractionXChange((e,t)=>{de.x=e,de.source=t,ye("crosshairMove",de)})),ae(),!m&&v&&(w=v.onZoomRangeChange((e,t)=>{const n=M,i=d;M=!1,d=void 0;const r=void 0!==i?i:void 0,o=t??(n?"api":void 0);fe.start=e.start,fe.end=e.end,fe.source=r,fe.sourceKind=o,ye("zoomRangeChange",fe)})),e&&v.setZoomRange(e.start,e.end),ce()},he=e=>{var t;if(m)return;const n=o.getBoundingClientRect(),i=window.devicePixelRatio||1,r=(null==(t=null==b?void 0:b.device)?void 0:t.limits.maxTextureDimension2D)??8192,a=Math.min(r,Math.max(1,Math.round(n.width*i))),s=Math.min(r,Math.max(1,Math.round(n.height*i))),l=o.width!==a||o.height!==s;l&&(o.width=a,o.height=s);const u=null==b?void 0:b.device,c=null==b?void 0:b.canvasContext,d=null==b?void 0:b.preferredFormat;let f=!1;u&&c&&d&&(l||!W||W.width!==o.width||W.height!==o.height||W.format!==d)&&(c.configure({device:u,format:d,alphaMode:"opaque"}),W={width:o.width,height:o.height,format:d},f=!0,v&&y!==d&&pe()),e&&(l||f)&&re()},ge=e=>{const t=o.getBoundingClientRect();if(!(t.width>0&&t.height>0))return{match:null,isInGrid:!1};const n=e.clientX-t.left,i=e.clientY-t.top,r=S.grid.left,a=S.grid.top,s=t.width-S.grid.left-S.grid.right,l=t.height-S.grid.top-S.grid.bottom;if(!(s>0&&l>0))return{match:null,isInGrid:!1};const u=n-r,c=i-a;if(!(u>=0&&u<=s&&c>=0&&c<=l))return{match:null,isInGrid:!1};const d=S.xAxis.min??B.xMin,f=S.xAxis.max??B.xMax,m=S.yAxis.min??B.yMin,p=S.yAxis.max??B.yMax,h=or(d,f),g=(null==v?void 0:v.getZoomRange())??null,b=(()=>{if(!g)return h;const e=h.max-h.min;if(!Number.isFinite(e)||0===e)return h;const t=g.start,n=g.end,i=h.min+t/100*e,r=h.min+n/100*e;return or(i,r)})(),y=or(m,p);if(null===T||T.rectWidthCss!==t.width||T.rectHeightCss!==t.height||T.plotWidthCss!==s||T.plotHeightCss!==l||T.xDomainMin!==b.min||T.xDomainMax!==b.max||T.yDomainMin!==y.min||T.yDomainMax!==y.max){const e=xn().domain(b.min,b.max).range(0,s),n=xn().domain(y.min,y.max).range(l,0);T={rectWidthCss:t.width,rectHeightCss:t.height,plotWidthCss:s,plotHeightCss:l,xDomainMin:b.min,xDomainMax:b.max,yDomainMin:y.min,yDomainMax:y.max,xScale:e,yScale:n}}const x=T,w=(()=>{const e=.5*Math.min(s,l);if(!(e>0))return null;for(let t=S.series.length-1;t>=0;t--){const n=S.series[t];if("pie"!==n.type||!1===n.visible)continue;const i=n,r=sr(i.center,s,l),o=lr(i.radius,e),a=vn(u,c,{seriesIndex:t,series:i},r,o);if(!a)continue;const d=a.slice.value;return{kind:"pie",seriesIndex:a.seriesIndex,dataIndex:a.dataIndex,sliceValue:"number"==typeof d&&Number.isFinite(d)?d:0}}return null})();if(w)return{match:w,isInGrid:!0};for(let e=S.series.length-1;e>=0;e--){const t=S.series[e];if("candlestick"!==(null==t?void 0:t.type)||!1===t.visible)continue;const n=t,i=dn(n,n.data,x.xScale,s),r=hn([n],u,c,x.xScale,x.yScale,i);if(r)return{match:{kind:"candlestick",seriesIndex:e,dataIndex:r.dataIndex,point:r.point},isInGrid:!0}}const M=Me(E(),u,c,x.xScale,x.yScale);return{match:M?{kind:"cartesian",match:M}:null,isInGrid:!0}},be=()=>{const e=(()=>{if($<2)return 0;const e=(Y-$+Ji)%Ji;let t=0;for(let n=1;n<$;n++){const i=(e+n-1)%Ji;t+=_[(e+n)%Ji]-_[i]}const n=t/($-1);return n>0?1e3/n:0})(),t=(()=>{if($<2)return{min:0,max:0,avg:0,p50:0,p95:0,p99:0};const e=(Y-$+Ji)%Ji,t=new Array($-1);let n=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,r=0;for(let o=1;o<$;o++){const a=(e+o-1)%Ji,s=_[(e+o)%Ji]-_[a];t[o-1]=s,s<n&&(n=s),s>i&&(i=s),r+=s}const o=r/t.length;t.sort((e,t)=>e-t);const a=Math.floor(.5*t.length),s=Math.floor(.95*t.length),l=Math.floor(.99*t.length);return{min:n,max:i,avg:o,p50:t[a],p95:t[s],p99:t[l]}})(),n={enabled:!1,cpuTime:K,gpuTime:0},i="external"===p?{totalDrops:0,consecutiveDrops:0,lastDropTimestamp:0}:{totalDrops:H,consecutiveDrops:q,lastDropTimestamp:j},r=performance.now()-Z;return{fps:e,frameTimeStats:t,gpuTiming:n,memory:{used:0,peak:0,allocated:0},frameDrops:i,totalFrames:X,elapsedTime:r}},ve=(e,t)=>{if(!e)return{seriesIndex:null,dataIndex:null,value:null,seriesName:null,event:t};const n="cartesian"===e.kind?e.match.seriesIndex:e.seriesIndex,i="cartesian"===e.kind?e.match.dataIndex:e.dataIndex,r=S.series[n],o=(null==r?void 0:r.name)??null,a=o&&o.trim().length>0?o:null;if("pie"===e.kind)return{seriesIndex:n,dataIndex:i,value:[0,e.sliceValue],seriesName:a,event:t};if("candlestick"===e.kind)return{seriesIndex:n,dataIndex:i,value:[tr(e.point),nr(e.point)],seriesName:a,event:t};const{x:s,y:l}=Qi(e.match.point);return{seriesIndex:n,dataIndex:i,value:[s,l],seriesName:a,event:t}},ye=(e,t)=>{if(!m)for(const n of D[e])n(t)},xe=(e,t)=>{const n=z;if(z=e,null===n&&null===e)return;if(null===n&&null!==e)return void ye("mouseover",ve(e,t));if(null!==n&&null===e)return void ye("mouseout",ve(n,t));if(null===n||null===e)return;const i="cartesian"===n.kind?n.match.seriesIndex:n.seriesIndex,r="cartesian"===n.kind?n.match.dataIndex:n.dataIndex,o="cartesian"===e.kind?e.match.seriesIndex:e.seriesIndex,a="cartesian"===e.kind?e.match.dataIndex:e.dataIndex;i===o&&r===a||(ye("mouseout",ve(n,t)),ye("mouseover",ve(e,t)))},we=e=>{k&&e.isPrimary&&e.pointerId===k.pointerId&&(k=null)},Fe=e=>{if(m||!ee())return;const{match:t,isInGrid:n}=ge(e);xe(n?t:null,e)},Ne=e=>{m||!ee()&&!k||(we(e),xe(null,e))},Ce=e=>{m||!ee()&&!k||(we(e),xe(null,e))},Se=e=>{if(!m&&(ee()||k||G===e.pointerId)){if(G===e.pointerId)return void(G=null);we(e),xe(null,e)}},Ae=e=>{if(!m&&te()&&e.isPrimary&&("mouse"!==e.pointerType||0===e.button)){k={pointerId:e.pointerId,startClientX:e.clientX,startClientY:e.clientY,startTimeMs:e.timeStamp};try{o.setPointerCapture(e.pointerId)}catch{}}},Ie=e=>{if(m||!te()||!e.isPrimary||!k||e.pointerId!==k.pointerId)return;const t=e.timeStamp-k.startTimeMs,n=e.clientX-k.startClientX,i=e.clientY-k.startClientY,r=n*n+i*i;k=null;try{o.hasPointerCapture(e.pointerId)&&(G=e.pointerId,o.releasePointerCapture(e.pointerId))}catch{}if(!(t<=500&&r<=36))return;const{match:a}=ge(e);ye("click",ve(a,e))};o.addEventListener("pointermove",Fe,{passive:!0}),o.addEventListener("pointerleave",Ne,{passive:!0}),o.addEventListener("pointercancel",Ce,{passive:!0}),o.addEventListener("lostpointercapture",Se,{passive:!0}),o.addEventListener("pointerdown",Ae,{passive:!0}),o.addEventListener("pointerup",Ie,{passive:!0});const Pe=()=>{if(!m){m=!0;try{ne(),le(),oe(),ae(),null==v||v.dispose(),v=null,y=null,null==b||b.destroy()}finally{k=null,G=null,z=null,T=null,M=!1,d=void 0,o.removeEventListener("pointermove",Fe),o.removeEventListener("pointerleave",Ne),o.removeEventListener("pointercancel",Ce),o.removeEventListener("lostpointercapture",Se),o.removeEventListener("pointerdown",Ae),o.removeEventListener("pointerup",Ie),D.click.clear(),D.mouseover.clear(),D.mouseout.clear(),D.crosshairMove.clear(),D.zoomRangeChange.clear(),D.deviceLost.clear(),D.dataAppend.clear(),U=!1,b=null,o.remove()}}},Re={get options(){return C},get disposed(){return m},setOption(e){m||(C=e,S=Hi(e),null==v||v.setOptions(S),R(),B=rr(S.series,I),T=null,ce(),re())},appendData(e,t){if(m||!Number.isFinite(e)||e<0||e>=S.series.length)return;const n=S.series[e];if("pie"===n.type)return void(V.has(e)||(V.add(e),console.warn(`ChartGPU.appendData(${e}, ...): pie series are not supported by streaming append. Use setOption(...) to replace pie data.`)));let i=0;if("candlestick"===n.type){if(!Array.isArray(t))return;i=t.length}else i=s(t);if(0===i)return;null==v||v.appendData(e,t);let r=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY;if("candlestick"===n.type){const n=A[e],a=Array.isArray(n)?n:[],s=t;if(U)for(let e=0;e<i;e++){const t=tr(s[e]);Number.isFinite(t)&&(t<r&&(r=t),t>o&&(o=t))}a.push(...s),A[e]=a,I[e]=((e,t)=>{if(0===t.length)return e;let n=(null==e?void 0:e.xMin)??Number.POSITIVE_INFINITY,i=(null==e?void 0:e.xMax)??Number.NEGATIVE_INFINITY,r=(null==e?void 0:e.yMin)??Number.POSITIVE_INFINITY,o=(null==e?void 0:e.yMax)??Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const a=t[e],s=tr(a),l=Ki(a)?a[3]:a.low,u=Ki(a)?a[4]:a.high;!Number.isFinite(s)||!Number.isFinite(l)||!Number.isFinite(u)||(s<n&&(n=s),s>i&&(i=s),l<r&&(r=l),u>o&&(o=u))}return Number.isFinite(n)&&Number.isFinite(i)&&Number.isFinite(r)&&Number.isFinite(o)?(n===i&&(i=n+1),r===o&&(o=r+1),{xMin:n,xMax:i,yMin:r,yMax:o}):e})(I[e],s)}else{const n=A[e],a=t,d="object"==typeof a&&null!==a&&!Array.isArray(a)&&"x"in a&&"y"in a,m="object"==typeof a&&null!==a&&!Array.isArray(a)&&ArrayBuffer.isView(a);let p=!1;const h=new Array(i);if(d){const e=a;for(let t=0;t<i;t++){const i=e.x[t];n.x.push(i),n.y.push(e.y[t]),U&&Number.isFinite(i)&&(i<r&&(r=i),i>o&&(o=i))}if(e.size){p=!0;for(let t=0;t<i;t++)h[t]=e.size[t]}}else if(m){const e=a;for(let t=0;t<i;t++){const i=e[2*t];n.x.push(i),n.y.push(e[2*t+1]),U&&Number.isFinite(i)&&(i<r&&(r=i),i>o&&(o=i))}}else for(let e=0;e<i;e++){const t=l(a,e);n.x.push(t),n.y.push(u(a,e));const i=c(a,e);h[e]=i,void 0!==i&&(p=!0),U&&Number.isFinite(t)&&(t<r&&(r=t),t>o&&(o=t))}(n.size||p)&&(n.size||(n.size=new Array(n.x.length-i)),n.size.push(...h)),I[e]=((e,t)=>{const n=s(t);if(0===n)return e;let i=e;if(!i)return f(t);let r=i.xMin,o=i.xMax,a=i.yMin,c=i.yMax;const d="object"==typeof t&&null!==t&&!Array.isArray(t)&&"x"in t&&"y"in t,m="object"==typeof t&&null!==t&&!Array.isArray(t)&&ArrayBuffer.isView(t);if(d){const e=t;for(let t=0;t<n;t++){const n=e.x[t],i=e.y[t];!Number.isFinite(n)||!Number.isFinite(i)||(n<r&&(r=n),n>o&&(o=n),i<a&&(a=i),i>c&&(c=i))}}else if(m){const e=t;for(let t=0;t<n;t++){const n=e[2*t],i=e[2*t+1];!Number.isFinite(n)||!Number.isFinite(i)||(n<r&&(r=n),n>o&&(o=n),i<a&&(a=i),i>c&&(c=i))}}else for(let e=0;e<n;e++){const n=l(t,e),i=u(t,e);!Number.isFinite(n)||!Number.isFinite(i)||(n<r&&(r=n),n>o&&(o=n),i<a&&(a=i),i>c&&(c=i))}return r===o&&(o=r+1),a===c&&(c=a+1),{xMin:r,xMax:o,yMin:a,yMax:c}})(I[e],a)}B=rr(S.series,I),P=null,T=null,re(),U&&((!Number.isFinite(r)||!Number.isFinite(o))&&(r=0,o=0),me.seriesIndex=e,me.count=i,me.xExtent.min=r,me.xExtent.max=o,ye("dataAppend",me))},renderFrame(){if(m||g)return!1;if("auto"===p)return console.warn('renderFrame() called in auto mode - this is a no-op. Set renderMode to "external" to use manual rendering.'),!1;if(h||!v||null==b||!b.device||!O)return!1;try{return ie(!1),!0}catch{return!1}},needsRender:()=>!m&&O,getRenderMode:()=>p,setRenderMode(e){if(!m){if("auto"!==e&&"external"!==e)return void console.warn(`setRenderMode(): invalid mode '${String(e)}', ignoring.`);p!==e&&(J=0,H=0,q=0,j=0,Y=0,$=0,p=e,"external"===e?ne():O&&re())}},resize:()=>he(!0),dispose:Pe,on(e,t){m||(D[e].add(t),"dataAppend"===e&&(U=!0))},off(e,t){D[e].delete(t),"dataAppend"===e&&(U=D.dataAppend.size>0)},getInteractionX:()=>m?null:(null==v?void 0:v.getInteractionX())??null,setInteractionX(e,t){m||null==v||v.setInteractionX(e,t)},setCrosshairX(e,t){m||null==v||v.setInteractionX(e,t)},onInteractionXChange:e=>m?()=>{}:(null==v?void 0:v.onInteractionXChange(e))??(()=>{}),getZoomRange:()=>m?null:(null==v?void 0:v.getZoomRange())??null,setZoomRange(e,t,n){if(m||!v)return;const i=v.getZoomRange();if(!i)return;M=!0,d=n,v.setZoomRange(e,t);const r=v.getZoomRange();(!r||r.start===i.start&&r.end===i.end)&&(M=!1,d=void 0)},getPerformanceMetrics:()=>m?null:be(),getPerformanceCapabilities:()=>m?null:{gpuTimingSupported:!1,highResTimerSupported:typeof performance<"u"&&"function"==typeof performance.now,performanceMetricsSupported:!0},onPerformanceUpdate:e=>m?()=>{}:(Q.add(e),()=>{Q.delete(e)}),hitTest(e){const t=o.getBoundingClientRect(),n=e.clientX-t.left,i=e.clientY-t.top;if(m||!(t.width>0)||!(t.height>0))return{isInGrid:!1,canvasX:n,canvasY:i,gridX:0,gridY:0,match:null};const r=S.grid.left,a=S.grid.top,s=t.width-S.grid.left-S.grid.right,l=t.height-S.grid.top-S.grid.bottom,u=n-r,c=i-a;if(!(s>0&&l>0))return{isInGrid:!1,canvasX:n,canvasY:i,gridX:u,gridY:c,match:null};if(!(u>=0&&u<=s&&c>=0&&c<=l))return{isInGrid:!1,canvasX:n,canvasY:i,gridX:u,gridY:c,match:null};const d=S.xAxis.min??B.xMin,f=S.xAxis.max??B.xMax,p=S.yAxis.min??B.yMin,h=S.yAxis.max??B.yMax,g=or(d,f),b=(null==v?void 0:v.getZoomRange())??null,y=(()=>{if(!b)return g;const e=g.max-g.min;if(!Number.isFinite(e)||0===e)return g;const t=b.start,n=b.end,i=g.min+t/100*e,r=g.min+n/100*e;return or(i,r)})(),x=or(p,h);if(null===T||T.rectWidthCss!==t.width||T.rectHeightCss!==t.height||T.plotWidthCss!==s||T.plotHeightCss!==l||T.xDomainMin!==y.min||T.xDomainMax!==y.max||T.yDomainMin!==x.min||T.yDomainMax!==x.max){const e=xn().domain(y.min,y.max).range(0,s),n=xn().domain(x.min,x.max).range(l,0);T={rectWidthCss:t.width,rectHeightCss:t.height,plotWidthCss:s,plotHeightCss:l,xDomainMin:y.min,xDomainMax:y.max,yDomainMin:x.min,yDomainMax:x.max,xScale:e,yScale:n}}const w=T,M=(()=>{const e=.5*Math.min(s,l);if(!(e>0))return null;for(let t=S.series.length-1;t>=0;t--){const n=S.series[t];if("pie"!==n.type||!1===n.visible)continue;const i=n,r=sr(i.center,s,l),o=lr(i.radius,e),a=vn(u,c,{seriesIndex:t,series:i},r,o);if(!a)continue;const d=a.slice.value;return{kind:"pie",seriesIndex:a.seriesIndex,dataIndex:a.dataIndex,sliceValue:"number"==typeof d&&Number.isFinite(d)?d:0}}return null})();if(M)return{isInGrid:!0,canvasX:n,canvasY:i,gridX:u,gridY:c,match:{kind:"pie",seriesIndex:M.seriesIndex,dataIndex:M.dataIndex,value:[0,M.sliceValue]}};for(let e=S.series.length-1;e>=0;e--){const t=S.series[e];if("candlestick"!==(null==t?void 0:t.type)||!1===t.visible)continue;const r=t,o=dn(r,r.data,w.xScale,s),a=hn([r],u,c,w.xScale,w.yScale,o);if(!a)continue;const l=tr(a.point),d=nr(a.point);return{isInGrid:!0,canvasX:n,canvasY:i,gridX:u,gridY:c,match:{kind:"candlestick",seriesIndex:e,dataIndex:a.dataIndex,value:[l,d]}}}const F=Me(E(),u,c,w.xScale,w.yScale);if(F){const{x:e,y:t}=Qi(F.point);return{isInGrid:!0,canvasX:n,canvasY:i,gridX:u,gridY:c,match:{kind:"cartesian",seriesIndex:F.seriesIndex,dataIndex:F.dataIndex,value:[e,t]}}}return{isInGrid:!0,canvasX:n,canvasY:i,gridX:u,gridY:c,match:null}}};try{he(!1);try{const e=n?{device:n.device,adapter:n.adapter}:void 0;b=await i.create(o,e)}catch(e){const t=e instanceof Error?e.message:String(e);throw new Error(`ChartGPU: WebGPU is not available.\nReason: ${t}\nBrowser support: Chrome/Edge 113+, Safari 18+, Firefox not yet supported.\nResources:\n  - MDN WebGPU API: https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API\n  - Browser compatibility: https://caniuse.com/webgpu\n  - WebGPU specification: https://www.w3.org/TR/webgpu/\n  - Check your system: https://webgpureport.org/`)}return null==(r=b.device)||r.lost.then(e=>{g=!0,!m&&("destroyed"!==e.reason&&console.warn("WebGPU device lost:",e),a&&"destroyed"!==e.reason&&ye("deviceLost",{reason:e.reason,message:e.message}),Pe())}),he(!1),pe(),ce(),"auto"===p&&re(),Re}catch(e){throw Re.dispose(),e}}};HTMLWidgets.widget({name:"chartgpu",type:"output",factory:function(e,t,n){return{renderValue:function(t){var n=t.options;const i=document.getElementById(e.id);ur.create(i,n)},resize:function(e,t){}}}})})();